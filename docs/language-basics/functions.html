<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Functions - Idiomatic Rust in Simple Steps</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="Learn idiomatic Rust in simple steps even if you have no former knowledge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../introduction/why.html"><strong aria-hidden="true">1.1.</strong> Why or Why Not</a></li><li class="chapter-item expanded "><a href="../introduction/resources.html"><strong aria-hidden="true">1.2.</strong> Other Learning Resources</a></li></ol></li><li class="chapter-item expanded "><a href="../getting-started/index.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting-started/setup.html"><strong aria-hidden="true">2.1.</strong> Getting Set Up</a></li><li class="chapter-item expanded "><a href="../getting-started/environment.html"><strong aria-hidden="true">2.2.</strong> Environment</a></li><li class="chapter-item expanded "><a href="../getting-started/hello-world.html"><strong aria-hidden="true">2.3.</strong> Hello World</a></li></ol></li><li class="chapter-item expanded "><a href="../language-basics/index.html"><strong aria-hidden="true">3.</strong> Language Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../language-basics/memory.html"><strong aria-hidden="true">3.1.</strong> Memory</a></li><li class="chapter-item expanded "><a href="../language-basics/data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="../language-basics/control-flow.html"><strong aria-hidden="true">3.3.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="../language-basics/functions.html" class="active"><strong aria-hidden="true">3.4.</strong> Functions</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.5.</strong> Documentation</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.6.</strong> Tests</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.7.</strong> Clippy and Fmt</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.8.</strong> Conversions</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.9.</strong> Pattern Matching</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.10.</strong> Error Handling</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.11.</strong> Collections</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.12.</strong> Iterators</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.13.</strong> Attributes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.14.</strong> Derive</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.15.</strong> Threads</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.16.</strong> Unsafe</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.17.</strong> Macros</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Patterns</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> Derive</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.</strong> Monads</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.3.</strong> Interior Mutability</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.4.</strong> New Types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.5.</strong> RAII / Drop and Finalise</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.6.</strong> Prefer Borrows</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.7.</strong> Type State</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.8.</strong> Builder</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Rust Ecosystem</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Project Structure</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> rustup</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Error Handling with ThisError and Anyhow</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.4.</strong> log</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.</strong> mdbook</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.</strong> Itertools</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.7.</strong> Rayon</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.8.</strong> Clap</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.9.</strong> Async with Tokio and async_std</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.10.</strong> Serialisation with Serde</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.11.</strong> Parsing with Nom</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.12.</strong> Regex</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.13.</strong> reqwest</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.14.</strong> Crossbeam?</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.15.</strong> bitvec</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.16.</strong> Derive More</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Advanced Rust</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Foreign Function Interfaces</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Proc Macro</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Intro to Web Dev</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.</strong> Intro to Embedded</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.5.</strong> Intro to Game Dev</div></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Idiomatic Rust in Simple Steps</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Functions are reusable blocks of code. They have inputs, usually perform some sort of process, then have an output.</p>
<p>We’ve been using a function called <code>main</code> to run all of our programs and example so far. This is a special function
that is called as the program starts. We’ve also used a few other kinds of functions and methods (special functions
attached to data types) that are built into Rust. We can make and use our own functions too though.</p>
<p>Functions can be pure, or impure. A pure function takes an input, does some processing and returns an output. This makes
the function extremely predictable. Given the same input they will always produce the same output, and nothing else
within the system will change.</p>
<pre class="mermaid">---
title: Pure Function
---
graph LR;
    Input --&gt; Process
    Process --&gt; Output
</pre>
<p>An impure function, might not always produce the same output given the same input, or may have side effects within the
system, either changing something else in the system or having some other part of the system</p>
<pre class="mermaid">---
title: Impure Function
---
graph LR;
%%    subgraph Function;
%%        direction LR
%%    end
    
    Process &lt;--&gt; SE[&quot;Side Effect&quot;]
        Input --&gt; Process
        Process --&gt; Output
    
</pre>
<h2 id="creating-and-calling-functions"><a class="header" href="#creating-and-calling-functions">Creating and calling functions</a></h2>
<p>Functions are defined with the <code>fn</code> keyword (short for FuNction), followed by a name, followed by brackets <code>()</code> which
may or may not contain parameters, possibly followed by an arrow <code>-&gt;</code> and a return type (if no return type is specified
the return type is the Unit Type <code>()</code>, see the <a href="./data-types.html">data types chapter</a>), and are completed by a code
block which is the body of the function.</p>
<p>So lets create the simplest possible function:</p>
<pre><pre class="playground"><code class="language-rust">fn say_hello() {
    println!("Hello, world");
}

<span class="boring">fn main() {
</span><span class="boring">    say_hello();
</span><span class="boring">}</span></code></pre></pre>
<p>This function is called <code>say_hello</code>, it has no parameters and does not return anything. Because it writes to the
terminal, this function is considered to be impure.</p>
<p>We can call the function using its name and empty brackets.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn say_hello() {
</span><span class="boring">    println!("Hello, world");
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    say_hello();
}</code></pre></pre>
<p>You’ll notice this function doesn’t actually have any inputs or outputs. Let’s start by providing an input.</p>
<h2 id="passing-parameters"><a class="header" href="#passing-parameters">Passing Parameters</a></h2>
<pre><pre class="playground"><code class="language-rust">fn say_hello(name: &amp;str) {
    println!("Hello, {name}");
}

<span class="boring">fn main() {
</span><span class="boring">    say_hello("Yuki");
</span><span class="boring">}</span></code></pre></pre>
<p>Now the function has one input (we call it a parameter) called <code>name</code>. You can see that we also provide type information
for the parameter, in this case it’s a string slice (<code>&amp;str</code>). The parameter can be used as a variable within the
function, so we use it in our <code>println!</code>.</p>
<p>To pass the data into the function we place it between the brackets:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn say_hello(name: &amp;str) {
</span><span class="boring">    println!("Hello, {name}");
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    say_hello("Yuki");
}</code></pre></pre>
<p>We can have multiple parameters too. Parameters are ordered so when you call the function, you need to match the order
they’re specified. For example:</p>
<pre><pre class="playground"><code class="language-rust">fn say_hello_two(first_person: &amp;str, second_person: &amp;str) {
    println!("Hello, {first_person} and {second_person}");
}

fn main() {
    say_hello_two("Indra", "Yuki");
}</code></pre></pre>
<h2 id="returning-from-functions"><a class="header" href="#returning-from-functions">Returning from Functions</a></h2>
<p>Let’s fix our function to remove the side effect. Instead of directly printing to the terminal from the function, we’ll
return the string we want to display and move the side effect to main.</p>
<p>We’ll make the following changes:</p>
<ul>
<li>We’ll rename the function to reflect the change in behaviour (see <a href="#best-practices">Best Practices</a> below)</li>
<li>We’ll add the return type (in this case <code>String</code>) to the function header, after <code>-&gt;</code></li>
<li>We’ll create the String using the <code>format!</code> macro and store it in a variable <code>message</code> (note: the variable isn’t
necessary, it’s just for clarity)</li>
<li>We’ll return the <code>message</code> from the function, remember the code blocks can be expressions, we don’t need to explicitly
write <code>return</code> (though we can), we just need to make the thing we want to return the last bit of the block and forgo
the semicolon</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn create_greeting(name: &amp;str) -&gt; String {
    let message = format!("Hello, {name}");
    message
}

fn main() {
    let greeting = create_greeting("Yuki");
    println!("{greeting}");
}</code></pre></pre>
<h2 id="recursion"><a class="header" href="#recursion">Recursion</a></h2>
<p>See also: <a href="#recursion">recursion</a></p>
<p>In Rust, functions can call other functions, like how our <code>main()</code> function calls our <code>create_greeting(...)</code> function in
the previous example. A function that calls itself is described as recursive. Take for example this method for finding
the nth number in the fibonacci sequence</p>
<pre><pre class="playground"><code class="language-rust">fn find_fibonacci(n: u128) -&gt; u128 {
    if n == 0 || n == 1 { // if n equals 0 or n equals 1
        n
    } else {
        find_fibonacci(n - 1) + find_fibonacci(n - 2)
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let n = 11u8;
</span><span class="boring">    let fibonacci = find_fibonacci(n);
</span><span class="boring">    println!("The {n} value of fibonacci is {fibonacci}");
</span><span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Note in this function that we use a boolean OR (<code>||</code>) in the <code>if</code> so the larger expression evaluates to true of either
the left or right parts of the expression evaluate to true. I.e. the expression is true if n is equal to 0 OR if n is
equal to 1.</p>
<p>We also use the <code>if</code>/<code>else</code> as an expression so the return of the function is equal to the values in the <code>if</code>/<code>else</code>
blocks. If the expression in the <code>if</code> is true, then we return <code>n</code>, otherwise we return the result of calling the same
function with new parameters.</p>
</blockquote>
<p>Because we call <code>find_fibonacci</code> inside of <code>find_fibonacci</code>, this is a recursion. Each time we call the function in this
way, we add another layer on <a href="./memory.html">the stack</a>. The stack is finite, so if we give the function a
large enough number, it will eventually run out of space in the stack, causing a stack overflow, and you’ll see
something like:</p>
<pre><code class="language-text">thread 'main' has overflowed its stack
</code></pre>
<p>Rust does support “tail recursion” which is technique for turning a recursive function into a loop at compile time. This
not only minimises stack usage to effectively a single function call but is also much faster. However, I think this is
an overrated feature. In any language that supports tail recursion, it’s hard to guarantee the compiler will optimise
this way, and it’s easy to break. My recommendation is if you need to recurse a <em>lot</em>, then consider whether you can
manually rewrite your function as a loop instead of depending on a compiler optimization.</p>
<h2 id="impl"><a class="header" href="#impl">Impl</a></h2>
<p>As you can imagine, you can pass your own data types into functions, and typically that’s fine, but there are some
issues, take the example below:</p>
<pre><pre class="playground"><code class="language-rust">struct User {
    name: String,
    fur_color: String,
}

fn to_string(user: User) -&gt; String {
    let User { name, fur_color } = user;
    format!("User name: {name}\nUser fur color: {fur_color}")
}

fn main() {
    let yuki = User {
        name: "Yuki".to_string(),
        fur_color: "White".to_string(),
    };
    println!("{}", to_string(yuki));
}</code></pre></pre>
<p>We have a nicely named function that does what it says, taking a User and turning it into a string, however, because
there is no function overloading in Rust (you are unable to have multiple functions with the same name but different
parameter lists), we can only have this one <code>to_string</code> function in scope at any time.</p>
<p>There are a few ways around this: in the case where the types are similar enough, you might be able to use a generic,
you could “rename” the function using <code>as</code> (we’ll talk about that more in the section on modules), or you could rename
the function to something even more specific such as <code>user_to_string</code>…</p>
<p>Or, you could make the function part of the implementation of the type itself using an <code>impl</code> block. This will make the
function a part of the <code>User</code> type itself, and can be used to make functions called from <code>User</code> or on an instantiated
object like <code>yuki</code>.</p>
<p>Let’s make an impl block starting with a function that provides an easier way to create a user:</p>
<pre><pre class="playground"><code class="language-rust">struct User {
    name: String,
    fur_color: String,
}

impl User {
    fn new(name: String, fur_color: String) -&gt; Self {
        User {
            name,
            fur_color,
        }
    }
}

<span class="boring">fn to_string(user: User) -&gt; String {
</span><span class="boring">   let User { name, fur_color } = user;
</span><span class="boring">   format!("User name: {name}\nUser fur color: {fur_color}")
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    let yuki = User::new("Yuki".to_string(), "White".to_string());
    println!("{}", to_string(yuki));
}</code></pre></pre>
<p>The function <code>new</code> is called from the <code>User</code> type, and returns <code>Self</code>, this is a special keyword meaning the type that
is being used for the call, which in this case is <code>User</code>. So, when we call <code>User::new</code> with the parameters for <code>name</code>
and <code>fur_color</code>, it will return a new <code>User</code> object with those fields filled in. You’ll also notice that when the
properties of the object are the same as the variables being used to set them, we don’t need to add the colon, eg, you
don’t need to do <code>name: name</code>, just putting <code>name</code> is fine.</p>
<p>You can also create “methods”, which are functions that can be called on the instantiated data. We do this by making the
first parameter <code>self</code>, <code>&amp;self</code> or <code>&amp;mut self</code>. We’ll talk more about the difference between these in the
<a href="#generic-functions">generic functions</a> section below.</p>
<p>For now, we’ll replicate the existing behaviour of our <code>to_string</code> function into the <code>User</code> implementation:</p>
<pre><pre class="playground"><code class="language-rust">struct User {
    name: String,
    fur_color: String,
}

impl User {
    fn new(name: String, fur_color: String) -&gt; Self {
        // ...
<span class="boring">        User {
</span><span class="boring">            name,
</span><span class="boring">            fur_color,
</span><span class="boring">        }
</span>    }
  
    fn to_string(self) -&gt; String {
        let User { name, fur_color } = self;
        format!("User name: {name}\nUser fur color: {fur_color}")
    }
}

fn main() {
    let yuki = User::new("Yuki".to_string(), "White".to_string());
    println!("{}", yuki.to_string());
}</code></pre></pre>
<p>We moved the function into the impl block, changed the first parameter from <code>user: User</code> to just <code>self</code>, we don’t need
to specify the type. We also changed the way we call the function from <code>to_string(yuki)</code> to <code>yuki.to_string()</code>.</p>
<h2 id="traits"><a class="header" href="#traits">Traits</a></h2>
<p><code>impl</code> is cool, but we can take it a step further and define behaviour that can be implemented for multiple types.</p>
<p>For example, lets say that we have a similar type to our <code>User</code> type called <code>Admin</code>.</p>
<pre><code class="language-rust noplayground">struct User {
    name: String,
    fur_color: String,
}

struct Admin {
    name: String,
}</code></pre>
<p>We might want both <code>User</code> and <code>Admin</code> to have the method <code>to_string</code>. We can define it in a trait.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait ExampleToString {
    fn to_string(self) -&gt; String;
}
<span class="boring">}</span></code></pre></pre>
<p>We don’t need to define the body of the function (though you can, if you want to provide some default behaviour), we
just need to describe its properties and return type. We can then implement that trait for a given type using
<code>impl &lt;trait&gt; for &lt;type&gt;</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct User {
</span><span class="boring">    name: String,
</span><span class="boring">    fur_color: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl User {
</span><span class="boring">    fn new(name: String, fur_color: String) -&gt; Self {
</span><span class="boring">        User {
</span><span class="boring">            name,
</span><span class="boring">            fur_color,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait ExampleToString {
</span><span class="boring">    fn to_string(self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>impl ExampleToString for User {
    fn to_string(self) -&gt; String {
        let User { name, fur_color } = self;
        format!("User name: {name}\nUser fur color: {fur_color}")
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let yuki = User::new("Yuki".to_string(), "White".to_string());
</span><span class="boring">    println!("{}", yuki.to_string());
</span><span class="boring">}</span></code></pre></pre>
<p>Now we’ve moved the method from <code>impl User</code> to <code>impl ExampleToString for User</code> we can still access the method on <code>yuki</code>
with <code>yuki.to_string()</code>. We can also implement the same trait for <code>Admin</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Admin {
</span><span class="boring">    name: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Admin {
</span><span class="boring">    fn new(name: String) -&gt; Self {
</span><span class="boring">        Admin { name }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">trait ExampleToString {
</span><span class="boring">    fn to_string(self) -&gt; String;
</span><span class="boring">}
</span><span class="boring">
</span>impl ExampleToString for Admin {
    fn to_string(self) -&gt; String {
        let Admin { name } = self;
        format!("Admin name: {name}")
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let indra = Admin::new("Indra".to_string());
</span><span class="boring">    println!("{}", indra.to_string());
</span><span class="boring">}</span></code></pre></pre>
<p>Why is this better than just implementing the <code>to_string</code> function on to <code>User</code> and <code>Admin</code>, if anything, this is more
work right? Well, the cool thing about this is that we can use the trait as a trait guard in generics, which we’ll see
in just a moment.</p>
<h2 id="generic-functions"><a class="header" href="#generic-functions">Generic Functions</a></h2>
<h2 id="ownership"><a class="header" href="#ownership">Ownership</a></h2>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../language-basics/control-flow.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../language-basics/control-flow.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>


    </div>
    </body>
</html>

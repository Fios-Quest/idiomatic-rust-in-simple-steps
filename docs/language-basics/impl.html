<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Giving types functionality - Idiomatic Rust in Simple Steps</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="Learn idiomatic Rust in simple steps even if you have no former knowledge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../introduction/why.html"><strong aria-hidden="true">1.1.</strong> Why or Why Not</a></li><li class="chapter-item expanded "><a href="../introduction/resources.html"><strong aria-hidden="true">1.2.</strong> Other Learning Resources</a></li></ol></li><li class="chapter-item expanded "><a href="../getting-started/index.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting-started/setup.html"><strong aria-hidden="true">2.1.</strong> Getting Set Up</a></li><li class="chapter-item expanded "><a href="../getting-started/environment.html"><strong aria-hidden="true">2.2.</strong> Environment</a></li><li class="chapter-item expanded "><a href="../getting-started/hello-world.html"><strong aria-hidden="true">2.3.</strong> Hello World</a></li></ol></li><li class="chapter-item expanded "><a href="../language-basics/index.html"><strong aria-hidden="true">3.</strong> Language Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../language-basics/memory.html"><strong aria-hidden="true">3.1.</strong> Memory</a></li><li class="chapter-item expanded "><a href="../language-basics/data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="../language-basics/control-flow.html"><strong aria-hidden="true">3.3.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="../language-basics/functions.html"><strong aria-hidden="true">3.4.</strong> Functions</a></li><li class="chapter-item expanded "><a href="../language-basics/tests.html"><strong aria-hidden="true">3.5.</strong> Tests</a></li><li class="chapter-item expanded "><a href="../language-basics/documentation.html"><strong aria-hidden="true">3.6.</strong> Documentation</a></li><li class="chapter-item expanded "><a href="../language-basics/clippy-and-fmt.html"><strong aria-hidden="true">3.7.</strong> Clippy and Fmt</a></li><li class="chapter-item expanded "><a href="../language-basics/impl.html" class="active"><strong aria-hidden="true">3.8.</strong> Giving types functionality</a></li><li class="chapter-item expanded "><a href="../language-basics/traits.html"><strong aria-hidden="true">3.9.</strong> Traits Intro</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.10.</strong> Common Traits</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.11.</strong> Error Handling</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.12.</strong> Collections</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.13.</strong> Iterators</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.14.</strong> Attributes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.15.</strong> Derive</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.16.</strong> Threads</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.17.</strong> Unsafe</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.18.</strong> Macros</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Common Patterns</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> Derive</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.</strong> Monads</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.3.</strong> Interior Mutability</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.4.</strong> New Types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.5.</strong> RAII / Drop and Finalise</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.6.</strong> Prefer Borrows</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.7.</strong> Type State</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.8.</strong> Builder</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Rust Ecosystem</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Project Structure</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> rustup</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Error Handling with ThisError and Anyhow</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.4.</strong> log</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.</strong> mdbook</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.</strong> Itertools</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.7.</strong> Rayon</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.8.</strong> Clap</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.9.</strong> Async with Tokio and async_std</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.10.</strong> Serialisation with Serde</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.11.</strong> Parsing with Nom</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.12.</strong> Regex</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.13.</strong> reqwest</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.14.</strong> Crossbeam?</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.15.</strong> bitvec</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.16.</strong> Derive More</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Advanced Rust</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Foreign Function Interfaces</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Proc Macro</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Intro to Web Dev</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.</strong> Intro to Embedded</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.5.</strong> Intro to Game Dev</div></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Idiomatic Rust in Simple Steps</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="giving-types-functionality"><a class="header" href="#giving-types-functionality">Giving types functionality</a></h1>
<p>Next we‚Äôre going to learn how to add functionality to data by modelling a common emotional pattern followed by my cat,
Yuki.</p>
<h2 id="yuki-states"><a class="header" href="#yuki-states">Yuki States</a></h2>
<p>We‚Äôll model 3 emotional states of my Cat, give him behaviours unique to each state, and allow him to transition between
those states.</p>
<style>
  img {
    display: block;
    margin: 0 auto;
  }
</style>
<p><img src="./impl/YukiStateMachine.svg" alt="YukiStateMachine.svg" /></p>
<p>So what is the behaviour we want to model in these states?</p>
<h3 id="mischievous"><a class="header" href="#mischievous">Mischievous</a></h3>
<ul>
<li>We‚Äôll initialise Yuki in the Mischievous state because that‚Äôs how he wakes up.</li>
<li>In this state he‚Äôll make a lot of fun little noises</li>
<li>He‚Äôll also try to get up to various naughtiness</li>
<li>If we forget to feed him he‚Äôll get Hangry</li>
</ul>
<h3 id="hangry-hungry-and-angry"><a class="header" href="#hangry-hungry-and-angry">Hangry (Hungry and Angry)</a></h3>
<ul>
<li>While hangry, he only really makes one noise, a desperate plea to ‚Äúpay attention and do your job‚Äù</li>
<li>He‚Äôll get hyper focused on you getting your attention and may choose violence</li>
<li>Once he‚Äôs eaten, he‚Äôll get Eepy</li>
</ul>
<h3 id="eepy-sleepy"><a class="header" href="#eepy-sleepy">Eepy (Sleepy)</a></h3>
<ul>
<li>Once he‚Äôs eaten, he‚Äôll get sleepy, he won‚Äôt make any noises he‚Äôll just settle down in one of his beds</li>
<li>Once he‚Äôs slept, he‚Äôll get back to his mischeivous state</li>
</ul>
<h2 id="making-a-cat"><a class="header" href="#making-a-cat">Making a Cat</a></h2>
<p>Let‚Äôs create a new project with <code>cargo new yuki-state-machine</code> and open it in our IDE of choice.</p>
<p>For this project we‚Äôre going to need to organise our code a bit. We‚Äôve talked a little bit about modules before, they‚Äôre
Rust‚Äôs way of organising and grouping code. We‚Äôve created modules to contain tests, that we‚Äôve then excluded from our
build. You can create them with the <code>mod</code> keyword, then a name, then either:</p>
<ul>
<li>a block of code surrounded by curly brackets</li>
<li>a file called the same thing as the module (e.g. <code>mod my_module</code> and a file called <code>my_module.rs</code>)</li>
<li>a directory called the same thing as the module and a file called <code>mod.rs</code> (e.g. <code>mod my_module</code> and a file called
<code>my_module/mod.rs</code>)</li>
</ul>
<p>We‚Äôre going to use all of these techniques in this project, though only the latter two today.</p>
<p>To organise our cat code away from the main binary, lets create a cat module inside our main file, so it looks something
like this:</p>
<pre><code class="language-rust ignore">// File: main.rs

mod cat;

fn main() {
    println!("Hello, world!");
}</code></pre>
<p>If you‚Äôre using VSCode, RustRover or similar, you might be able to use the context menu to create <code>cat.rs</code> by
putting the cursor over <code>cat</code> and activating the context actions (in VSCode that‚Äôs <code>Ctrl</code>/<code>‚åò</code> + <code>.</code>, in IntelliJ
products like RustRover it‚Äôs <code>Alt</code>/<code>‚å•</code> + <code>enter</code>). If you aren‚Äôt able to do that, create a file called <code>cat.rs</code> in your
<code>src</code> folder.</p>
<p>Inside our <code>cat.rs</code> file lets create a structure to hold a cat, we‚Äôll make it public by putting the word <code>pub</code> in front
of the struct.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: cat.rs

pub struct Cat {
    name: String,
}
<span class="boring">}</span></code></pre></pre>
<p>We can access the <code>Cat</code> struct back in our <code>main</code> function either by giving a full reference to the <code>Cat</code> struct in its
module, <code>cat::Cat</code> or by using the <code>use</code> keyword. However, you‚Äôll find we can‚Äôt actually <em>create</em> the structure.</p>
<pre><pre class="playground"><code class="language-rust compile_fail no_run"><span class="boring">// This would be in your `cat.rs`, I need to put it here to make the code work in mdbook
</span><span class="boring">mod cat {
</span><span class="boring">  pub struct Cat {
</span><span class="boring">    name: String,
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span>// File: main.rs

mod cat;

use cat::Cat;

fn main() {
    let yuki = Cat { name: "Yuki".to_string() };
}</code></pre></pre>
<pre><code class="language-text">   |
6  |     let yuki = Cat { name: "Yuki".to_string() };
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^ private field
</code></pre>
<p>This is because although <code>Cat</code> is public, it‚Äôs <code>name</code> is not.</p>
<p>We could, of course, simple make <code>name</code> public, but this means anything can access it at any time and, if your <code>cat</code> is
mutable, the name can be changed. We don‚Äôt want anything renaming Yuki, so, we‚Äôll manage the property privately.</p>
<p>To create the object then, we‚Äôll need a ‚Äúconstructor‚Äù, a function that is associated with our <code>Cat</code> type, that returns
an instantiated object. To do this we need to use an <code>impl</code> block.</p>
<h2 id="impl"><a class="header" href="#impl">impl</a></h2>
<p>In Rust, code that is associated with specific types is called ‚Äúimplementation‚Äù code, and lives inside an <code>impl</code> block.</p>
<p><code>impl</code> blocks are incredibly flexible, and we‚Äôll see more of this in the next chapter, for now though, the simplest use
of the block is:</p>
<pre><code class="language-rust ignore">impl TypeName {
    // code goes here
}</code></pre>
<p>Our constructor is simply a function that lives inside the impl block of <code>Cat</code>, takes the cats name, and returns an
instantiated <code>Cat</code> with the given name. One nice thing about <code>impl</code> blocks is that they have a special shortcut when
referring to the type that is being implemented called <code>Self</code>. This means that while we <em>could</em> specifically return
the <code>Cat</code> type, but we could also use <code>Self</code>. There are a lot of benefits to the latter in more advanced code, so we‚Äôll
use that here.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: cat.rs

pub struct Cat {
    name: String,
}

impl Cat {
    pub fn new(name: String) -&gt; Self {
        Self { name }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Above, the <code>new</code> function takes a <code>String</code> and returns a <code>Cat</code>. Here we can instantiate the <code>Cat</code> type with <code>Self</code> too,
and inside the <code>impl</code> block, we have access to the private <code>name</code> field. Finally, because the <code>name</code> variable is called
the same as thing as the <code>name</code> field, writing <code>Self { name: name }</code> is redundant, we can just write <code>Self { name }</code>.</p>
<p>Let‚Äôs make our <code>Cat</code> implementation slightly more useful by adding a function that will get the name of our cat too. In
order to get the name we‚Äôll create a function with a special parameter <code>&amp;self</code>. You might notice a couple of odd things
about this. First, it has no type, and second, the variable self name itself gets the <code>&amp;</code> which would normally be on the
type, to show that it is a reference.</p>
<p><code>self</code> is a keyword, that translates in the parameters of a function header to <code>self: Self</code>, ie, a variable called
<code>self</code> with the type of whatever the implementation is for. When you use <code>&amp;self</code> it instead translates to <code>self: &amp;Self</code>.
Similarly, <code>&amp;mut self</code> translates to <code>self: &amp;mut Self</code>.</p>
<p>We don‚Äôt need to take ownership, or have a mutable reference, so for our function we‚Äôll use <code>&amp;self</code> to get an immutable
reference.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: cat.rs

<span class="boring">pub struct Cat {
</span><span class="boring">    name: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Cat {
    pub fn new(name: String) -&gt; Self { // ...
<span class="boring">        Self { name }
</span><span class="boring">    }
</span>
    pub fn get_name(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Note:</strong> We can safely return a reference to owned data at this point because the function acts like any other, there
is only one reference coming in, <code>&amp;self</code>, and one reference going out <code>&amp;str</code>, they must have the same lifetime. Rust
will not allow you to compile any code where you keep the <code>&amp;str</code> beyond the point where whatever the owner of <code>&amp;self</code>
is goes out of scope.</p>
</blockquote>
<p>Any implementation function where the first parameter is some form of <code>self</code> may be referred to as a ‚Äúmethod‚Äù, and is
available on the instantiated type. Any other function in the implementation is called a ‚Äústatic method‚Äù.</p>
<p>We can finally create a working program, so returning to <code>main</code>, lets use our new implementation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">// This would be in your `cat.rs`, I need to put it here to make the code work in mdbook
</span><span class="boring">mod cat {
</span><span class="boring">    pub struct Cat {
</span><span class="boring">        name: String,
</span><span class="boring">    }
</span><span class="boring">    impl Cat {
</span><span class="boring">        pub fn new(name: String) -&gt; Self {
</span><span class="boring">           Self { name }
</span><span class="boring">        }
</span><span class="boring">        pub fn get_name(&amp;self) -&gt; &amp;str {
</span><span class="boring">            &amp;self.name
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// File: main.rs

// ...
<span class="boring">use cat::Cat;
</span>
fn main() {
    let mut yuki = Cat::new("Yuki".to_string());
    println!("Our cat is called {}", yuki.get_name());
}</code></pre></pre>
<p>Great, lets move on to Yuki‚Äôs state!</p>
<h2 id="state-machines-and-rust"><a class="header" href="#state-machines-and-rust">State Machines and Rust</a></h2>
<p>We want to represent three of Yuki‚Äôs many ‚Äústates‚Äù, but in particular, we want to move between them in a very specific
way.</p>
<p>A naive approach to this could use an <code>enum</code> to represent the states, and then we could have methods that change the
state.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: cat.rs

pub enum CatState {
    Mischievous,
    Hangry,
    Eepy,
}

pub struct Cat {
    name: String,
    state: CatState,
}

impl Cat {
    pub fn new(name: String) -&gt; Self {
       Self { 
          name,
          state: CatState::Mischievous, // Our default state
       }
    }
  
    pub fn get_name(&amp;self) -&gt; &amp;str { // ...
<span class="boring">        &amp;self.name
</span><span class="boring">    }
</span>
    pub fn forget_to_feed(&amp;mut self) {
        self.state = CatState::Hangry
    }

    pub fn feed(&amp;mut self) {
        self.state = CatState::Eepy
    }

    pub fn sleep(&amp;mut self) {
        self.state = CatState::Mischievous
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Here we use methods which take a mutable reference to self (<code>&amp;mut self</code>) so that we can modify the state.</p>
<p>But let‚Äôs look again at the diagram:</p>
<p><img src="./impl/YukiStateMachine.svg" alt="YukiStateMachine.svg" /></p>
<p>A Hangry cat doesn‚Äôt become Mischievous because it slept. What should happen if we try to call <code>sleep</code> on a Hangry cat?
Should it do nothing? Should it throw an error? Does it even make sense for this to be an option?</p>
<p>Furthermore, if we look back at the specification, a Hangry cat may choose violence, but Eepy cats and Mischievous cats
won‚Äôt.</p>
<p>Instead, we could use a pattern called a State Machine. In a State Machine we transition fully between different states,
and those states have different functionality.</p>
<p>Let‚Äôs make our states unit structs instead of an enum</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: cat.rs

pub struct Mischievous;
pub struct Hangry;
pub struct Eepy;
<span class="boring">}</span></code></pre></pre>
<p>We can then apply the functionality to each struct in turn:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: cat.rs

<span class="boring">pub struct Mischievous;
</span><span class="boring">pub struct Hangry;
</span><span class="boring">pub struct Eepy;
</span>impl Mischievous {
    pub fn forget_to_feed(self) -&gt; Hangry {
        Hangry
    }
}

impl Hangry {
    pub fn feed(self) -&gt; Eepy {
        Eepy
    }
}

impl Eepy {
    pub fn sleep(self) -&gt; Mischievous {
        Mischievous
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This is <em>much</em> more ergonomic as <code>Hangry</code> simply does not have the method <code>sleep</code>, meaning you get compile time checking
that your cat states are being used correctly.</p>
<p>At this point, we don‚Äôt have any data about our cat though. There are a few ways we could deal with this. We could
extend our states to be the cat like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: cat.rs

pub struct Mischievous {
    name: String,
}

pub struct Hangry {
    name: String,
}

pub struct Eepy {
    name: String,
}

impl Mischievous {
    pub fn new(name: String) -&gt; Self {
        Self { name }
    }
  
    pub fn forget_to_feed(self) -&gt; Hangry {
        Hangry::new(self.name)
    }
}

impl Hangry {
    pub fn new(name: String) -&gt; Self {
        Self { name }
    }
  
    pub fn feed(self) -&gt; Eepy {
        Eepy::new(self.name)
    }
}

impl Eepy {
    pub fn new(name: String) -&gt; Self {
        Self { name }
    }
  
    pub fn sleep(self) -&gt; Mischievous {
        Mischievous::new(self.name)
    }
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Note:</strong> Each state transition consumes itself, and passes its owned data onto the new state. This saves memory
allocations and makes sure that you don‚Äôt have an ‚Äúold‚Äù state hanging around.</p>
</blockquote>
<p>This is fine‚Ä¶ but it‚Äôs not very flexible. Instead, we‚Äôre going to put the <em>whole</em> cat inside the state.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: cat.rs

// ---------- Cat ----------
pub struct Cat {
    name: String,
}

// ---------- States ----------
pub struct Mischievous {
    cat: Cat,
}

pub struct Hangry {
    cat: Cat,
}

pub struct Eepy {
    cat: Cat,
}
<span class="boring">}</span></code></pre></pre>
<p>You might think this is no better, and you‚Äôd be right! Whether the cat‚Äôs information is stored directly in the state or
not we haven‚Äôt made this more flexible‚Ä¶ but, what if the states were generic?</p>
<h2 id="generics"><a class="header" href="#generics">Generics</a></h2>
<p>Generics are a way that we can create a template where some of the details are filled in later. We‚Äôre going to get
deeper into this in the next chapter, but we can use rudimentary generics to manage our states.</p>
<p>Functions, Structs and Enums can all be made generic by adding triangle brackets after their name, containing a list of
generic parameters. Very over you might see a single letter generic name, particularly you might see something like
<code>&lt;T&gt;</code> as you do with <code>Option&lt;T&gt;</code>, however, you might want to hint about the purposed of the type like the Error <code>E</code> in
<code>Result&lt;T, E&gt;</code>.</p>
<p>You can even use whole words, though this is seen less.</p>
<p>For our purposes, we‚Äôll use the letter <code>A</code> to represent ‚ÄúAnimal‚Äù.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: cat.rs

pub struct Mischievous&lt;A&gt; {
    animal: A,
}

pub struct Hangry&lt;A&gt; {
    animal: A,
}

pub struct Eepy&lt;A&gt; {
    animal: A,
}
<span class="boring">}</span></code></pre></pre>
<p>Later we can fill in the Generic and make it a ‚Äúconcrete‚Äù type, in our case this will eventually look like
<code>Mischievous&lt;Cat&gt;</code>.</p>
<p>Next we‚Äôll need to update our implementations. Implementations that involve Generic parts, need to list those
after the <code>impl</code> to save confusing implementations on generic types and implementations on concrete variants of generic
types (don‚Äôt worry if that doesn‚Äôt quite make sense, just remember to put the generic parameters after the <code>impl</code>).</p>
<p>Once we‚Äôve specified the generic parameters of the impl block, we don‚Äôt need to respecify them for each function so long
as the type is being used consistently. So, our <code>new</code> functions can use <code>A</code> for the animal parameter, and that will be
linked to our state‚Äôs generic <code>A</code>, and our state changes can use <code>A</code> to show that when the state changes, the generic
type will remain the same.</p>
<p>I‚Äôm also going to add a quick extra function, <code>describe</code>, to each implementation for use at the end.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: cat.rs

pub struct Mischievous&lt;A&gt; {
    animal: A,
}

pub struct Hangry&lt;A&gt; {
    animal: A,
}

pub struct Eepy&lt;A&gt; {
    animal: A,
}

impl&lt;A&gt; Mischievous&lt;A&gt; {
    pub fn new(animal: A) -&gt; Self {
        Self { animal }
    }

    pub fn forget_to_feed(self) -&gt; Hangry&lt;A&gt; {
        Hangry::new(self.animal)
    }
    
    pub fn describe(&amp;self) -&gt; String {
        "Trying to break into a wardrobe by pulling on exposed clothing".to_string()
    }
}

impl&lt;A&gt; Hangry&lt;A&gt; {
    pub fn new(animal: A) -&gt; Self {
        Self { animal }
    }

    pub fn feed(self) -&gt; Eepy&lt;A&gt; {
        Eepy::new(self.animal)
    }
    
    pub fn describe(&amp;self) -&gt; String {
        "Being loud doesn't get what they want, they choose violence and attack!".to_string()
    }
}

impl&lt;A&gt; Eepy&lt;A&gt; {
    pub fn new(animal: A) -&gt; Self {
        Self { animal }
    }

    pub fn sleep(self) -&gt; Mischievous&lt;A&gt; {
        Mischievous::new(self.animal)
    }
    
    pub fn describe(&amp;self) -&gt; String {
        "Look at the precious baby sleeping üòç".to_string()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Finally, lets update our cat implementation to return a concrete <code>Mischievous&lt;Cat&gt;</code> type:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: cat.rs

<span class="boring">pub struct Cat {
</span><span class="boring">    name: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Mischievous&lt;A&gt; {
</span><span class="boring">  animal: A,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;A&gt; Mischievous&lt;A&gt; {
</span><span class="boring">    pub fn new(animal: A) -&gt; Self {
</span><span class="boring">        Mischievous { animal }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Cat {
    pub fn new(name: String) -&gt; Mischievous&lt;Cat&gt; {
        Mischievous::new(Self { name })
    }
}
<span class="boring">}</span></code></pre></pre>
<p>We can now play with all of this in our main function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">mod cat { // Everything here should be in `cat.rs`, I can't do that and have runnable code though ;) 
</span><span class="boring">    pub struct Cat {
</span><span class="boring">        name: String,
</span><span class="boring">    }
</span><span class="boring">   
</span><span class="boring">    impl Cat {
</span><span class="boring">      pub fn new(name: String) -&gt; Mischievous&lt;Cat&gt; {
</span><span class="boring">        Mischievous::new(Self { name })
</span><span class="boring">      }
</span><span class="boring">    }
</span><span class="boring">    
</span><span class="boring">    pub struct Mischievous&lt;A&gt; {
</span><span class="boring">        animal: A,
</span><span class="boring">    }
</span><span class="boring">    
</span><span class="boring">    pub struct Hangry&lt;A&gt; {
</span><span class="boring">        animal: A,
</span><span class="boring">    }
</span><span class="boring">    
</span><span class="boring">    pub struct Eepy&lt;A&gt; {
</span><span class="boring">        animal: A,
</span><span class="boring">    }
</span><span class="boring">    
</span><span class="boring">    impl&lt;A&gt; Mischievous&lt;A&gt; {
</span><span class="boring">        pub fn new(animal: A) -&gt; Self {
</span><span class="boring">            Self { animal }
</span><span class="boring">        }
</span><span class="boring">    
</span><span class="boring">        pub fn forget_to_feed(self) -&gt; Hangry&lt;A&gt; {
</span><span class="boring">            Hangry::new(self.animal)
</span><span class="boring">        }
</span><span class="boring">        
</span><span class="boring">        pub fn describe(&amp;self) -&gt; String {
</span><span class="boring">            "Trying to break into a wardrobe by pulling on exposed clothing".to_string()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    
</span><span class="boring">    impl&lt;A&gt; Hangry&lt;A&gt; {
</span><span class="boring">        pub fn new(animal: A) -&gt; Self {
</span><span class="boring">            Self { animal }
</span><span class="boring">        }
</span><span class="boring">    
</span><span class="boring">        pub fn feed(self) -&gt; Eepy&lt;A&gt; {
</span><span class="boring">            Eepy::new(self.animal)
</span><span class="boring">        }
</span><span class="boring">        
</span><span class="boring">        pub fn describe(&amp;self) -&gt; String {
</span><span class="boring">            "Being loud doesn't get what they want, they choose violence and attack!".to_string()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    
</span><span class="boring">    impl&lt;A&gt; Eepy&lt;A&gt; {
</span><span class="boring">        pub fn new(animal: A) -&gt; Self {
</span><span class="boring">            Self { animal }
</span><span class="boring">        }
</span><span class="boring">    
</span><span class="boring">        pub fn sleep(self) -&gt; Mischievous&lt;A&gt; {
</span><span class="boring">            Mischievous::new(self.animal)
</span><span class="boring">        }
</span><span class="boring">        
</span><span class="boring">        pub fn describe(&amp;self) -&gt; String {
</span><span class="boring">            "Look at the precious baby sleeping üòç".to_string()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">use cat::Cat;
</span>// File: main.rs

// ...

fn main() {
  let mischievous_yuki = Cat::new("Yuki".to_string());
  println!("{}", mischievous_yuki.describe());
  println!();
  
  let hangry_yuki = mischievous_yuki.forget_to_feed();
  println!("{}", hangry_yuki.describe());
  println!();
  
  let sleepy_yuki = hangry_yuki.feed();
  println!("{}", sleepy_yuki.describe());
  println!();
  
  let mischievous_yuki = sleepy_yuki.sleep();
  println!("{}", mischievous_yuki.describe());
  println!();
}</code></pre></pre>
<h2 id="tidying-up"><a class="header" href="#tidying-up">Tidying up</a></h2>
<p>Before we finish the chapter, our code has gotten a bit messy, we should clean it up. Now that our states are not
Cat specific, they should be moved out of <code>cat.rs</code>.</p>
<p>I recommend splitting your files like this:</p>
<p><img src="./impl/project-layout.png" alt="project-layout.png" /></p>
<p>You will need to <code>use</code> each state in the appropriate file being used, and you need to make your individual state modules
public in your general state <code>mod.rs</code>.</p>
<p>I‚Äôd like you to try to organise this project yourself, but if you get stuck, you can see it on our
<a href="https://github.com/Fios-Quest/yuki-state-machine-impl-example" title="" target="_blank">GitHub</a>.</p>
<h2 id="next-chapter"><a class="header" href="#next-chapter">Next Chapter</a></h2>
<p>This is cool‚Ä¶ but we‚Äôve got a slight problem. We can‚Äôt get Yuki‚Äôs name, and really his actions should belong to him,
not be part of the state (I try not to choose violence when I‚Äôm hangry for example).</p>
<p>We should move some of this behaviour to the Cat, but type, but how can we access details on our Cat type, when we
don‚Äôt know that our Generic states will contain Cat‚Äôs until runtime?</p>
<p>In the next chapter we‚Äôll discuss Traits which provide a way to resolve this, as well as some other cool things they
can do with Generics!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../language-basics/clippy-and-fmt.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../language-basics/traits.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../language-basics/clippy-and-fmt.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../language-basics/traits.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>

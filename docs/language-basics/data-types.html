<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Data Types - Idiomatic Rust in Simple Steps</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="Learn idiomatic Rust in simple steps even if you have no former knowledge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="../highlight.css">
        <link rel="stylesheet" href="../tomorrow-night.css">
        <link rel="stylesheet" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "../";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="../index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../introduction/why.html"><strong aria-hidden="true">1.1.</strong> Why or Why Not</a></li><li class="chapter-item expanded "><a href="../introduction/resources.html"><strong aria-hidden="true">1.2.</strong> Other Learning Resources</a></li></ol></li><li class="chapter-item expanded "><a href="../getting-started/index.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../getting-started/setup.html"><strong aria-hidden="true">2.1.</strong> Getting Set Up</a></li><li class="chapter-item expanded "><a href="../getting-started/environment.html"><strong aria-hidden="true">2.2.</strong> Environment</a></li><li class="chapter-item expanded "><a href="../getting-started/hello-world.html"><strong aria-hidden="true">2.3.</strong> Hello World</a></li></ol></li><li class="chapter-item expanded "><a href="../language-basics/index.html"><strong aria-hidden="true">3.</strong> Language Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="../language-basics/memory.html"><strong aria-hidden="true">3.1.</strong> Memory</a></li><li class="chapter-item expanded "><a href="../language-basics/data-types.html" class="active"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.3.</strong> Functions</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.4.</strong> Documentation</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.5.</strong> Tests</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.6.</strong> Clippy and Fmt</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.7.</strong> Traits</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.8.</strong> Conversions</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.9.</strong> Pattern Matching</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.10.</strong> Error Handling</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.11.</strong> Ownership</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.12.</strong> Collections</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.13.</strong> Iterators</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.14.</strong> Attributes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.15.</strong> Derive</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.16.</strong> Threads</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.17.</strong> Unsafe</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.18.</strong> Macros</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Patterns</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> Derive</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.</strong> Monads</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.3.</strong> Interior Mutability</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.4.</strong> New Types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.5.</strong> RAII / Drop and Finalise</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.6.</strong> Prefer Borrows</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.7.</strong> Type State</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.8.</strong> Builder</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Rust Ecosystem</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Project Structure</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> rustup</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Error Handling with ThisError and Anyhow</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.4.</strong> log</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.</strong> mdbook</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.</strong> Itertools</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.7.</strong> Rayon</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.8.</strong> Clap</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.9.</strong> Async with Tokio and async_std</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.10.</strong> Serialisation with Serde</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.11.</strong> Parsing with Nom</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.12.</strong> Regex</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.13.</strong> reqwest</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.14.</strong> Crossbeam?</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.15.</strong> bitvec</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.16.</strong> Derive More</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Advanced Rust</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Foreign Function Interfaces</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Proc Macro</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Intro to Web Dev</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.</strong> Intro to Embedded</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.5.</strong> Intro to Game Dev</div></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Idiomatic Rust in Simple Steps</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="data-types"><a class="header" href="#data-types">Data Types</a></h1>
<h2 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h2>
<p>Primitive types are effectively the building blocks of all other types.</p>
<p>I think this is an early point in learning Rust that scares off a lot of potential new Rust engineers. You see, Rust has
a <em>lot</em> of primitive types.</p>
<p>I’m going to show this to you now, but I don’t want you to worry about it. You, whoever you are dear reader, have 
already achieved things more complicated than learning this 🙂</p>
<p>So, are you ready to see something terrifying that long before the end of the chapter you’re going to have a complete
handle on?</p>
<div class="table-wrapper"><table><thead><tr><th>types</th><th>8bit</th><th>16bit</th><th>32bit</th><th>64bit</th><th>128bit</th><th>memory width</th></tr></thead><tbody>
<tr><td>unsigned integers</td><td>u8</td><td>u16</td><td>u32</td><td>u64</td><td>u128</td><td>usize</td></tr>
<tr><td>signed integers</td><td>i8</td><td>i16</td><td>i32</td><td>i64</td><td>i128</td><td>isize</td></tr>
<tr><td>floating points</td><td></td><td></td><td>f32</td><td>f64</td><td></td><td></td></tr>
<tr><td>characters</td><td></td><td></td><td></td><td>char</td><td></td><td></td></tr>
<tr><td>booleans</td><td>bool</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>string slices</td><td></td><td></td><td></td><td></td><td></td><td>&amp;str</td></tr>
</tbody></table>
</div>
<p>This is how many primitive types there are in Rust! And yes, as scary as it is, you will completely understand this in
just a few minutes!</p>
<p>First and most importantly, forget the above, there’s really only five subtypes that we actually care about:</p>
<div class="table-wrapper"><table><thead><tr><th>types</th></tr></thead><tbody>
<tr><td>integers</td></tr>
<tr><td>floating points</td></tr>
<tr><td>characters</td></tr>
<tr><td>booleans</td></tr>
<tr><td>string slices</td></tr>
</tbody></table>
</div>
<p>We’ll go over each of these individually, explain how they work, their variations and what you might use them for.</p>
<p>Before we do, lets very quickly cover binary.</p>
<h3 id="binary-primer"><a class="header" href="#binary-primer">Binary Primer</a></h3>
<p>Don’t panic! No one is expecting you to learn to count in binary. Counting in binary is fun, but pretty useless. 😅</p>
<p>All I want to do is show you how things are represented in memory because it’s going to make all those Rust types make a
lot of sense!</p>
<p>Humans (mostly) count in base 10. That’s numbers going from 0 to 9. You can imagine numbers as a series of columns,
where each column represents how many 1s, 10s, 100s, etc there are in the number.</p>
<p>For example, the number 123 contains one lot of 100, two lots of 10, and three lots of 1</p>
<div class="table-wrapper"><table><thead><tr><th>Columns:</th><th>100</th><th>10</th><th>1</th></tr></thead><tbody>
<tr><td>Count:</td><td>1</td><td>2</td><td>3</td></tr>
</tbody></table>
</div>
<p>When we add numbers to the columns, if the column goes over 9, then we add to the next column along.</p>
<p>So, if we add 1 to 9, it goes to 10, 19 goes to 20, and 99 goes to 100 (because the roll-over from the right most 9 adds
to the next 9 also causing it to roll over).</p>
<p>This counting system is called base 10 by the way as each of those columns is 10 raised to the power of which column it
is, starting at 0:</p>
<ul>
<li>10^0 = 1</li>
<li>10^1 = 10</li>
<li>10^2 = 100</li>
<li>10^3 = 1000</li>
<li>etc</li>
</ul>
<p>Electronics, and by extension computers, can only really cope reliably with things that are <code>on</code> or <code>off</code> though. How do
you count with only on or off? Well, what if instead of having ten possible values in each column (0-9 or base 10), we
only have two (0-1 or base 2). This is binary.</p>
<p>In binary our columns are a bit different:</p>
<ul>
<li>2^0 = 1</li>
<li>2^1 = 2</li>
<li>2^2 = 4</li>
<li>2^3 = 8</li>
<li>etc</li>
</ul>
<p>So if we want to represent the number 11 in base 2, we can see it contains one 8, one 2, and one 1.</p>
<div class="table-wrapper"><table><thead><tr><th>Columns:</th><th>8</th><th>4</th><th>2</th><th>1</th></tr></thead><tbody>
<tr><td>Count:</td><td>1</td><td>0</td><td>1</td><td>1</td></tr>
</tbody></table>
</div>
<p>Sometimes when we want to write something in binary and be explicit that that is the system we’re using we might write:
<code>0b1011</code>. This makes it clear that this number represents “eleven” and not “one thousand and eleven”.</p>
<p>Each column is a <em><strong>b</strong></em>inary dig<em><strong>it</strong></em>, which is where we get the term “bit”.</p>
<p>Eight bits is a byte, and can represent the numbers from <code>0b0000_0000</code> (zero) to <code>0b1111_1111</code> (two hundred and 
fifty-five, again, I’m not expecting anyone to be able to <em>read</em> this). Also note that I’m using an underscore as a 
spacer between numbers to help legibility, this also works in Rust, as does the <code>0b</code> notation!</p>
<p>The reason why a byte is eight bits has a lot of history, but it basically comes down to character encoding: with 7
bits, you can represent 127 characters which covers english lowercase, uppercase, numbers 0-9, various whitespace and
punctuation, and still have 1 bit left over for simple error checking.</p>
<blockquote>
<p>As a total aside, as a software engineer, you’re very likely to also see number written in hexadecimal (base 16).
This is because hexadecimal, is really nice when working with bytes. One byte (8 bits) perfectly maps to two
hexadecimal digits. Hexadecimal digits go from 0 to 15, but are represented as 0-F (ie: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
A, B, C, D, E, F).</p>
<p><code>0xF</code> is 15, and so is <code>0b1111</code>. The number 255 is much easier to write as <code>0xFF</code> than <code>0b1111_1111</code>. This <code>0x</code> 
notation also works in Rust.</p>
</blockquote>
<h3 id="integers"><a class="header" href="#integers">Integers</a></h3>
<p>Now that you’ve had that primer on binary, I bet those 12 different integer types are starting to make a lot more sense!</p>
<p>The most basic number type in Rust is the <code>u8</code>. This is an <em>unsigned</em> integer (represented by the <code>u</code>) that is 8 bits in
length. Unsigned means that the number can only be positive (it does not have a negative sign). You might have already
guessed, but this is one byte, and can hold the numbers 0 to 255. A byte like this can be used for all sorts of things,
though one common example is as part of a color. We often represent colors as 8 bits of red, 8 bits of green,
8 bits of blue and sometimes 8 bits of transparency.</p>
<p><code>i8</code> is an integer that can represent both positive and negative numbers (i.e. it’s signed). It also only uses 8 bits
of data but in order to represent a number, however, instead of going from 0 to 255, it goes from -128 to 127.</p>
<p>You never need to know this, <em>but</em>, if you’re interested in the mathematics of how it does this, it uses a method called
<a href="https://en.wikipedia.org/wiki/Two%27s_complement" title="" target="_blank">two’s complement</a>.</p>
<p>This, however, is complicated, and we don’t think like computers. The easiest way to think about it is the left most
column is the negative version of itself, and all other numbers are the same. So, the number -125 can be represented as
<code>0b1000_0011</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Columns:</th><th>-128</th><th>64</th><th>32</th><th>16</th><th>8</th><th>4</th><th>2</th><th>1</th></tr></thead><tbody>
<tr><td>Count:</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td></tr>
</tbody></table>
</div>
<p>ie, the number contains one -128, one 2 and one 1, adding (-128 + 2 + 1) them is -125.</p>
<p>So that’s <code>u8</code> and <code>i8</code>, and now you’ve probably guessed that for all the other integer types;</p>
<ul>
<li><code>u</code> means it can only be positive</li>
<li><code>i</code> means it can be positive or negative</li>
<li>the number after is how many bits are available to the number</li>
</ul>
<p>Now we can build up a little table to show the minimum and maximum of these types:</p>
<div class="table-wrapper"><table><thead><tr><th>type</th><th style="text-align: right">min</th><th style="text-align: right">max</th></tr></thead><tbody>
<tr><td>u8</td><td style="text-align: right">0</td><td style="text-align: right">255</td></tr>
<tr><td>i8</td><td style="text-align: right">-128</td><td style="text-align: right">127</td></tr>
<tr><td>u16</td><td style="text-align: right">0</td><td style="text-align: right">65,535</td></tr>
<tr><td>i16</td><td style="text-align: right">-32768</td><td style="text-align: right">32,767</td></tr>
<tr><td>u32</td><td style="text-align: right">0</td><td style="text-align: right">4,294,967,295</td></tr>
<tr><td>i32</td><td style="text-align: right">-2147483648</td><td style="text-align: right">2,147,483,647</td></tr>
<tr><td>u64</td><td style="text-align: right">0</td><td style="text-align: right">18,446,744,073,709,551,615</td></tr>
<tr><td>i64</td><td style="text-align: right">-9,223,372,036,854,775,808</td><td style="text-align: right">127</td></tr>
<tr><td>u128</td><td style="text-align: right">0</td><td style="text-align: right">340,282,366,920,938,463,463,374,607,431,768,211,455</td></tr>
<tr><td>i128</td><td style="text-align: right">-170,141,183,460,469,231,731,687,303,715,884,105,728</td><td style="text-align: right">170,141,183,460,469,231,731,687,303,715,884,105,727</td></tr>
</tbody></table>
</div>
<p>Wow, those numbers get big fast!</p>
<p>There’s still two types missing though; <code>usize</code> and <code>isize</code>.</p>
<p>In this case, the <code>size</code> is also acting as the number of bits, however, unlike the other integer types, the size of
<code>size</code> is variable.</p>
<p>Rust is a compiled language, meaning that the code you write in Rust is transformed into instructions that a CPU can
understand. CPUs are all different, but they typically follow some given “architecture”. For example, if you’re
reading this on a Windows or Linux desktop or an Intel Mac, the architecture of your CPU is <em>probably</em> <code>x86_64</code>. If
you’re reading this on an “Apple Silicon” Mac or a mobile phone, then the architecture is <em>probably</em> <code>arm64</code>.</p>
<blockquote>
<p>A quick aside, the world of CPU architecture is a bit of a mess so <code>x86_64</code> may also be referred to as <code>amd64</code> as AMD
were the designers of the architecture, but it was designed to be backwards compatible with Intel’s <code>x86</code>
architecture. Similarly <code>arm64</code> is also sometimes referred to as <code>AArch64</code>.</p>
</blockquote>
<p>When you compile Rust it will compile into an instruction set for the architecture your machine uses, though you can
also tell it what instruction set to compile for if you want to build it on one architecture but run it on another.</p>
<p><code>x86_64</code> and <code>arm64</code> are both 64bit architectures, so when you build for these machines, the <code>size</code> in <code>usize</code> and
<code>isize</code> becomes <code>64</code>. However, if you were to compile for, say, a Cortex-M0 chip, then the instruction set would likely
be <code>Thumb-1</code> which is 16bit so the <code>size</code> in <code>usize</code> and <code>isize</code> becomes <code>16</code>.</p>
<h4 id="which-integer-is-right-for-you"><a class="header" href="#which-integer-is-right-for-you">Which integer is right for you?</a></h4>
<p>You might think the obvious thing to do would be to use the largest possible number, for example, you can fit pretty
much every whole number you could possibly need into <code>i128</code>, so why use anything else?</p>
<p>There’s two things to think about, first, what is the intended use of the number and, second, what is the architecture
of the machine you’re running on?</p>
<p>In software engineering, a number is never just a number, it represents something. As we mentioned earlier,
colors are often (but not always), represented as 0 to 255 for each of red, green and blue. This means that a <code>u8</code> is
the best way to store these. If you combine those three colors with another 8 bits for transparency (alpha), then you
have four lots of <code>u8</code> which can be represented as a <code>u32</code>.</p>
<p><code>u8</code> is also a good size for representing a stream of unicode characters, which is where we get <code>UTF-8</code>, the default
encoding for Rust strings.</p>
<p>For larger numbers though, you still may not want to use the largest. While you can use integers that are wider than the
architecture that you’re running your program on, like using a <code>u128</code> ion a 64 bit machine, mathematics with those 
numbers will be slower. The CPU can only process so many bits at once, so when it has numbers larger than that, it has
to do multiple rounds of processing to achieve the same results as it might have done if those numbers were stored in
smaller integers.</p>
<p>You might then think that the best thing to do is use a <code>usize</code> or <code>isize</code> if you don’t really care about how big a
number can get, and that’s fine, and I often do this, but now you have to bear in mind that the behaviour of your 
program may no longer be consistent on different machines!</p>
<p>By default, when you write an integer and store it in a variable, Rust will play it safe and use an <code>i32</code> as it doesn’t
know what you might want to do with the number, an <code>i32</code> will fit inside most CPU architectures without needing extra
work and allows negative numbers.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 10; // i32
<span class="boring">}</span></code></pre></pre>
<p>However, it is more idiomatic to be intentional about the types you use. My methodology here is roughly:</p>
<ul>
<li>does this number represent something of a specific size like a color or ascii character, in which case, use that size</li>
<li>is this number going to be used to access an array, in which case it really ought to be a <code>usize</code></li>
<li>am I more worried about the number slowing the program down than I am about accidentally trying to store a big number
in a small integer, and do I not care about consistency, in which case <code>usize</code> or <code>isize</code></li>
<li>otherwise, if I’m ok potentially sacrificing speed, then an <code>i32</code> or <code>i64</code> is fine</li>
</ul>
<p>You can specify what type a number is either by annotating the variable you are putting it inside:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: u64 = 10; // u64
<span class="boring">}</span></code></pre></pre>
<p>Or, if that’s not possible because you are, for example, passing the number to a function that could take many number
types, you can write the type at the end of a number:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::fmt::Display;
</span><span class="boring">
</span><span class="boring">fn print_value_and_type&lt;T: Display&gt;(v: T) {
</span><span class="boring">   let type_name = std::any::type_name::&lt;T&gt;();
</span><span class="boring">   println!(&quot;Type of '{v}' is {type_name}&quot;);
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>print_value_and_type(10u8); // u8
<span class="boring">}</span></code></pre></pre>
<h4 id="a-brief-note-on-type-conversion"><a class="header" href="#a-brief-note-on-type-conversion">A brief note on Type Conversion</a></h4>
<p>Finally, you can convert between types in several ways, which we’ll talk about more later, but I wanted to quickly go
over some code from the last chapter.</p>
<p>In the bonus section of the last chapter, we got the number of milliseconds that had passed since midnight on the 1st
of January 1970, and then immediately used <code>as usize</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let time = std::time::UNIX_EPOCH
    .elapsed()
    .expect(&quot;Call the doctor, time went backwards&quot;)
    .as_millis() as usize; // We only need the least significant bits so this is safe
<span class="boring">}</span></code></pre></pre>
<p>The reason for this is the number of milliseconds since that date is approximately 1,710,000,000,000 and is
returned as a <code>u128</code>. We wanted to use this as part of a calculation to work out an index into an array. Indexes in
arrays are always <code>usize</code>. If you were to compile this program on a 32bit architecture, then the number of milliseconds
is greater than what would fit into a <code>usize</code> which would be a mere 4,294,967,295. When we use <code>as</code> it simply takes the
number, whatever it is and tries to cram it into the size <code>as &lt;type&gt;</code>.</p>
<p>When going from a larger size to a smaller size (in this case, from <code>u128</code> to the equivalent of <code>u32</code>) it simply cuts
off the front of the data, leaving the least significant bits. You can see this in the following program (don’t forget
you can run this in place with the play button):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let time = std::time::UNIX_EPOCH
    .elapsed()
    .expect(&quot;Call the doctor, time went backwards&quot;)
    .as_millis();

let time_u32 = time as u32;

println!(&quot;Before conversion: {time}&quot;);
println!(&quot;After conversion: {time_u32}&quot;);
<span class="boring">}</span></code></pre></pre>
<h3 id="floating-points"><a class="header" href="#floating-points">Floating Points</a></h3>
<p>We’ve covered twelve different ways of storing whole numbers in Rust, but there are only two ways of storing numbers
with decimal points: <code>f32</code> and <code>f64</code>.</p>
<p>Floating point numbers are things like <code>0.123</code> or <code>1.23</code> or even <code>123.0</code>. They’re called floating point because the
decimal point can move around (as opposed to fixed point, where there is always the same number of fractional digits).</p>
<p>You’re immediate thought here might be that you should use <code>f32</code> on 32bit systems, and <code>f64</code> on 64bit systems, but
actually this isn’t the way to think about these numbers.</p>
<p>You see, floating points are not perfectly accurate. The bits of a floating point number are broken into parts:</p>
<ul>
<li>a sign (+/-)</li>
<li>an exponent</li>
<li>a fraction</li>
</ul>
<p>Without going into too much detail on floating points this gives us a way of expressing very large numbers and very
small numbers but not every number in between (after all, there are infinite numbers between 0.0 and 1.0).</p>
<p>Imagine using a floating point number to represent money. Someone comes into a store to buy a $520.04 item, and they
have a coupon for $520.02. The remainder that they need to pay is 2 cents, right? Try running the next bit of code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>println!(&quot;520.04 - 520.02 should be 0.02&quot;);

// Single Precision Floating Point
let float_32 = 520.04_f32 - 520.02_f32;
println!(&quot;f32, {float_32}&quot;);

// Double Precision Floating Point
let float_64 = 520.04_f64 - 520.02_f64;
println!(&quot;f64, {float_64}&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Instead, if the currency you’re representing uses “hundredths” for its minor currency like USD or GBP, then you can
represent the total number that instead, eg of cents for dollars or pennies for pounds.</p>
<p>When should you use floats?</p>
<p>Floating point numbers are great for more abstract mathematics where perfect precisions isn’t strictly necessary, for
example, vectors, matrices and quaternions which are often used in applications like video games and scientific models.</p>
<p>As to which you should use, you might think that it comes down to architecture again, for example, a program targeting
a 32bit architecture should use an <code>f32</code> and a 64bit architecture should prefer an <code>f64</code>… but if that’s the case,
where is the <code>fsize</code>?</p>
<p>Actually, 32bit architectures are usually designed to support 64bit floating point numbers just fine, the difference
between <code>f32</code> and <code>f64</code> is that regardless of architecture, <code>f32</code> is faster, and <code>f64</code> is more “fine grain”.</p>
<h3 id="characters"><a class="header" href="#characters">Characters</a></h3>
<p>In Rust, we have a special type the represents a single character called <code>char</code>. It is always 4 bytes (32bits) in size
and can be any valid “unicode scalar value” (which is to say, any character in unicode that’s not a control character).
In Rust a character is always written between single quotes, whereas string literals are always written between double
quotes.</p>
<p>You can use any valid unicode character whether that’s the upper or lowercase english letters A-Z, numbers 0-9, white
space characters, word characters from languages like Chinese and Japanese, emoji, or anything else that’s a “unicode
scalar value”.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let i = 'I';
let love = '💖';
let yuki = '雪';
println!(&quot;{i} {love} {yuki}&quot;); 
<span class="boring">}</span></code></pre></pre>
<p>We usually use characters in relation to finding things inside strings. You can also turn strings into a collection of
characters and vice versa, however its important to note that a character inside a string may not take up 4 bytes (for
example, english letters and numbers only take 1 byte), however, once turned into a character, it will take up four
bytes.</p>
<h3 id="boolean"><a class="header" href="#boolean">Boolean</a></h3>
<p>There is only one boolean type in Rust: <code>bool</code>. It represents <code>true</code> or <code>false</code>.</p>
<blockquote>
<p>Useless (but interesting!) information: In terms of how much space it uses, Rust considers it to be a single bit (an
i1) <em>however</em> LLVM, which is a tool Rust uses as an intermediate compilation step, will use a full byte, though the
value inside the byte will still be 0 for false and 1 for true.</p>
<p>Weirdly, if Rust got its way, the decimal value for a boolean as its stored in memory would be 0 for false and -1 for
true (remember in <code>i</code> numbers, the left most bit is its negative self). None of that matters, its just interesting 😅</p>
</blockquote>
<p>Boolean values are usually reserved for <code>if</code> statements, and this is a good thing to look out for as finding it else
where <em>might</em> be a sign that the code isn’t written in the best way.</p>
<h3 id="string-slices"><a class="header" href="#string-slices">String slices</a></h3>
<p>Our old friend the string slice!</p>
<p>The type for a string slice is <code>str</code>, but you’ll never see anything with the <code>str</code> type, you will usually see this
as a reference to a string slice <code>&amp;str</code>, which makes it unique amongst the primitive types. </p>
<p><code>str</code> should always be a UTF-8 string (see ⚠️ below), which means that the length of a string in bytes may not
necessarily be the same as its length in characters.</p>
<p>For example (don’t worry about the code yet):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let yuki = &quot;雪&quot;;

let byte_length = yuki.len();
println!(&quot;{yuki} length in bytes: {byte_length}&quot;);

let char_length = yuki.chars().count();
println!(&quot;{yuki} length in characters: {char_length}&quot;);
<span class="boring">}</span></code></pre></pre>
<p>Its also worth remembering that when you turn a string into characters, each of those characters will take up 4 bytes
of memory, even though inside the string they might have only taken up one byte (again, don’t worry about the code in
the next example we’ll talk about it soon):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::mem::size_of_val;
</span><span class="boring">
</span><span class="boring">fn main() {
</span>let hello = &quot;hello&quot;;

let string_size = size_of_val(hello);
println!(&quot;Size as string slice: {string_size} bytes&quot;);

// Convert the string slice to chars, get the size of each char, and sum them
let  char_size: usize = hello.chars().map(|c| size_of_val(&amp;c)).sum();
println!(&quot;Size as characters: {char_size} bytes&quot;);
<span class="boring">}</span></code></pre></pre>
<p>The size of a string slice depends on what’s in it, which is why you won’t see it on the stack (string slices live in
either the compiled output as string literals, or on the Heap inside a String). A string slice reference is made up of
two pieces of data, a pointer to where the string slice starts, and a length, both of which are of known size but depend
on the system architecture.</p>
<p>Fun fact about that reference though: you might wonder if it’s just a pointer and a length, does that mean you can
have a reference to a string slice that exists inside a string slice, and the answer is: yes! Just be careful when
taking a slice inside a slice to make sure that the sub slice is a valid UTF-8 string.</p>
<blockquote>
<p>⚠️ It is <em>possible</em> to create a string slice that is not a valid UTF-8 string so you should be mindful that this isn’t
a guarantee, but you also shouldn’t make the effort to check the validity everywhere its used. It <em>should</em> be a UTF-8
string, but if you are constructing your own from raw data, or if there are security implications to the use of a
string slice, you should be careful.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let hello = &quot;hello&quot;;
// hell is a reference to a substring, range 0..4 is exclusive so 0, 1, 2, 3 but not 4
let hell = &amp;hello[0..4]; 
println!(&quot;{hell}&quot;);
<span class="boring">}</span></code></pre></pre>
<h2 id="compound-types"><a class="header" href="#compound-types">Compound Types</a></h2>
<h3 id="arrays"><a class="header" href="#arrays">Arrays</a></h3>
<p>Arrays are a collection of a single type. You might see arrays in two forms, either as a sized array on the stack, or
as a reference to another collection (also called an array slice).</p>
<p>When sized, arrays are annotated with the type <code>[T; N]</code> where <code>T</code> is the type of every item in the array and <code>N</code> is its
size. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello: [char; 5] = ['H', 'e', 'l', 'l', 'o'];
<span class="boring">}</span></code></pre></pre>
<p>When referenced as an array slice, you do not need to specify the size because, just like with references to string
slices, the reference not only contains a pointer to the underlying data, but also contains the size. We write this in
the form <code>&amp;[T]</code> where <code>T</code> is the type of every item in the array.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">let hello: [char; 5] = ['H', 'e', 'l', 'l', 'o'];
</span>// hell is a reference to a sub-array, range 0..=3 is inclusive so 0, 1, 2, and 3
let hell: &amp;[char] = &amp;hello[0..=3];

// This is another way of printing variables with debug that we haven't covered yet 
print!(&quot;{:?}&quot;, hell);
<span class="boring">}</span></code></pre></pre>
<p>You can access elements inside the array directly by using an index value between square brackets. In Rust, indexing
starts at 0. So:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello: [char; 5] = ['H', 'e', 'l', 'l', 'o'];
let h = hello[0]; // H
let e = hello[1]; // e 
let l = hello[2]; // l 
<span class="boring">}</span></code></pre></pre>
<h3 id="tuples"><a class="header" href="#tuples">Tuples</a></h3>
<p>Tuples are similar to arrays in that they are a collection of items, however each item in the collection can be a
different type. This adds some flexibility but also some restrictions. For example, you can iterate over each item in
an array, but not a tuple.</p>
<p>Tuples are written between brackets, and are only considered the same type if the types inside the tuple match.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let char_int_1: (char, i32) = ('a', 1);
let char_int_2: (char, i32) = ('b', 2); // This type is the same as the previous one.
let int_char_1: (i32, char) = (3, 'c'); // This type is different 
<span class="boring">}</span></code></pre></pre>
<p>Another difference from arrays is how you access a single item in the tuple, which you do with a dot <code>.</code>, followed by
the number element you want. Again, this starts from 0.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let char_int: (char, i32) = ('a', 1);
let a = char_int.0;
let one = char_int.1;
<span class="boring">}</span></code></pre></pre>
<h4 id="the-unit-type"><a class="header" href="#the-unit-type">The Unit Type</a></h4>
<p>The Unit Type is a zero length tuple <code>()</code> that is Rust’s way to represent nothing. It is zero bytes, does not exist on
the stack at runtime, and unlike other languages with types like <code>null</code> or <code>void</code>, can not be used interchangeably with
other types.</p>
<h3 id="structs"><a class="header" href="#structs">Structs</a></h3>
<p>Structs are similar to tuples in that they are a type made up of other types. Unlike tuples they are named though. There
are three types of structs, structs with named fields, tuple structs and unit structs.</p>
<blockquote>
<p><strong>Note:</strong> types like structs and enums must be declared outside of functions.</p>
</blockquote>
<h4 id="tuple-struct"><a class="header" href="#tuple-struct">Tuple Struct</a></h4>
<p>As we just covered tuples, lets quickly talk about tuple structs. They look a bit like they’re simply “named” tuples,
and indeed they can be accessed the same way:</p>
<pre><pre class="playground"><code class="language-rust">struct Vector3(f64, f64, f64);

fn main() {
    let vec = Vector3(10.0, 2.0, 3.33);
    let ten = vec.0;
    let two = vec.1;
}</code></pre></pre>
<p>Similar to tuples, this kind of struct can be accessed with a <code>.</code> and a numbered value, <em>however</em> unlike structs,
structs have a concept of “visibility”. Unless explicitly marked as public the fields of a struct are only accessible
in the module in which it is defined, or its descendents. We’ll talk more about modules later, however, to make the
fields of a struct public, you can simply mark them as <code>pub</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Vector3(pub f64, pub f64, pub f64);
<span class="boring">}</span></code></pre></pre>
<p>You don’t have to make every field public though, if you’d some parts of the struct to be public and others to be
private.</p>
<h4 id="named-fields"><a class="header" href="#named-fields">Named Fields</a></h4>
<p>Named fields work pretty much the same as tuple structs except instead of having a numbered field, its named. You
can access the named field with a <code>.</code> and the name.</p>
<pre><pre class="playground"><code class="language-rust">struct Cell {
    x: u64,
    y: u64,
    alive: bool,
}

fn main() {
    let cell = Cell {
        x: 10,
        y: 123,
        alive: true,
    };

    let is_alive = cell.alive;
}</code></pre></pre>
<h4 id="unit-structs"><a class="header" href="#unit-structs">Unit Structs</a></h4>
<p>Unit structs are an interesting case that you probably won’t find much use for until we get into more advanced Rust and
some of the cooler patterns and idioms that we use. A Unit struct has no value, it only represents a type.</p>
<pre><pre class="playground"><code class="language-rust">struct ExampleUnitStruct;

fn main() {
    let unit_struct = ExampleUnitStruct;
}</code></pre></pre>
<p>Unit Structs have zero size and don’t exist on the stack at runtime, but they can have functionality added to them
through Traits, or be used as markers.</p>
<h3 id="enums"><a class="header" href="#enums">Enums</a></h3>
<p>Enums are for when you want to represent one of a finite number of possible values. For example</p>
<pre><pre class="playground"><code class="language-rust">enum TrafficLightState {
    Red,
    Amber,
    Green,
}

fn main() {
    let green = TrafficLightState::Green;
    // let purple = TrafficLightState::Purple; // Won't compile
}</code></pre></pre>
<p>Many programing languages have this concept of enums, but what makes Rust enums especially awesome is that the variants
can additionally contain values. We’ve already talked about two such enums <code>Option</code> and <code>Result</code> which are two of the
most important and widely used types in the entire ecosystem, and we’ll talk more about them in the Generic Types
section below. As an example though, enums variants can be structured in either a tuple stype or a struct style:</p>
<pre><pre class="playground"><code class="language-rust">enum ContrivedEnum {
    SimpleVariantNoData,
    TupleStyleData(u64, i32),
    NamedFields {
        time: i128,
        place: String,
    }
}

fn main() {
    let simple_variant = ContrivedEnum::SimpleVariantNoData;
    let tuple_style = ContrivedEnum::TupleStyleData(10, -20);
    let named_fields = ContrivedEnum::NamedFields {
        time: 1_710_000_000_000,
        place: &quot;Here&quot;.to_string(),
    };
}</code></pre></pre>
<p>In terms of memory usage, on the stack an enum will take up as much space as its largest variant, regardless of which
variant it actually is.</p>
<h2 id="generic-types"><a class="header" href="#generic-types">Generic Types</a></h2>
<p>Generics in Rust allow the creation of entirely new types at compile time by combining types together. We’ve talked
a bit about Option and how Rust uses it to represent Some value or None. Option is an enum with two variants, it is
literally just this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    None,
    Some(T),
}
<span class="boring">}</span></code></pre></pre>
<p>Note that after the name of the enum we have <code>&lt;T&gt;</code>. The triangle brackets express that this enum has a type (or types)
that can be decided later, the <code>T</code> is a marker for that type. For example, say we want to create a type that represents
either a single character, or nothing.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The type of possible_character is inferred to be Option&lt;char&gt;
let possible_character = Some('r');

// The type of no_character can not be inferred, but you can annotate it yourself
let no_character: Option&lt;char&gt; = None;
<span class="boring">}</span></code></pre></pre>
<p>Normally when accessing the variants of an enum, you must use the name followed by the variant (eg <code>Option::Some('r')</code>),
however Option and Result are so ubiquitous that their variants are globally accessible in any rust code.</p>
<p>Another generic we’ve covered before is Result which usually represents either the success or failure of a function. It
has two types that can be decided later <code>T</code>, which should represent what type of data you expected to get back, and <code>E</code>,
which will be the type of the Error.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p>We’ll talk more about functions in the next chapter, but in order to explain Result in context, the following example
shows the fully described Result type as the return type of the function, which is how we’d typically use this enum,
though, you wouldn’t typically use a String as an Error type, and we’ll talk more about that when we get to Error
handling later.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn function_that_fails_half_the_time() -&gt; Result&lt;u128, String&gt; { // Note the return type for a function comes after -&gt;
    let time = std::time::UNIX_EPOCH
        .elapsed()
        .expect(&quot;Call the doctor, time went backwards&quot;) // We can do something cooler here but that's for another time
        .as_millis();

    if time % 2 == 0 {
        Ok(time) // implicit return
    } else {
        Err(&quot;The function failed&quot;.to_string()) // implicit return
    }
} 
<span class="boring">}</span></code></pre></pre>
<p>When we start talking about adding functionality to traits in the next chapter, we’ll also talk about how you can
restrict what types are allowed to be used in generics through the use of trait bounds.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>That is (almost) everything you need to know about types! The main thing we’re still missing in ownership, but we’ll
come to that later. The main things to remember are:</p>
<ul>
<li>We have our primitive types that represent binary data. There’s a lot of choice here, but that’s a good thing!</li>
<li>We can represent more complex types with compound types, each with its own use</li>
<li>We can “fill in the blank” with compound types later using generics</li>
<li>We talked a bit about two of the most common generics, Option (representing something or nothing) and Result
(representing a successful value or an error)</li>
</ul>
<p>In the next chapter we’re going to talk about controlling the flow of our program with branches and loops as well as
introducing functions.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../language-basics/memory.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../language-basics/memory.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>

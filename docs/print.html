<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Idiomatic Rust in Simple Steps</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="Learn idiomatic Rust in simple steps even if you have no former knowledge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="index.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="introduction/why.html"><strong aria-hidden="true">1.1.</strong> Why or Why Not</a></li><li class="chapter-item expanded "><a href="introduction/resources.html"><strong aria-hidden="true">1.2.</strong> Other Learning Resources</a></li></ol></li><li class="chapter-item expanded "><a href="getting-started/index.html"><strong aria-hidden="true">2.</strong> Getting Started</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="getting-started/setup.html"><strong aria-hidden="true">2.1.</strong> Getting Set Up</a></li><li class="chapter-item expanded "><a href="getting-started/environment.html"><strong aria-hidden="true">2.2.</strong> Environment</a></li><li class="chapter-item expanded "><a href="getting-started/hello-world.html"><strong aria-hidden="true">2.3.</strong> Hello World</a></li></ol></li><li class="chapter-item expanded "><a href="language-basics/index.html"><strong aria-hidden="true">3.</strong> Language Basics</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="language-basics/memory.html"><strong aria-hidden="true">3.1.</strong> Memory</a></li><li class="chapter-item expanded "><a href="language-basics/data-types.html"><strong aria-hidden="true">3.2.</strong> Data Types</a></li><li class="chapter-item expanded "><a href="language-basics/control-flow.html"><strong aria-hidden="true">3.3.</strong> Control Flow</a></li><li class="chapter-item expanded "><a href="language-basics/functions.html"><strong aria-hidden="true">3.4.</strong> Functions</a></li><li class="chapter-item expanded "><a href="language-basics/tests.html"><strong aria-hidden="true">3.5.</strong> Tests</a></li><li class="chapter-item expanded "><a href="language-basics/documentation.html"><strong aria-hidden="true">3.6.</strong> Documentation</a></li><li class="chapter-item expanded "><a href="language-basics/clippy-and-fmt.html"><strong aria-hidden="true">3.7.</strong> Clippy and Fmt</a></li><li class="chapter-item expanded "><a href="language-basics/impl.html"><strong aria-hidden="true">3.8.</strong> Giving types functionality</a></li><li class="chapter-item expanded "><a href="language-basics/traits.html"><strong aria-hidden="true">3.9.</strong> Traits</a></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.10.</strong> Conversions</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.11.</strong> Error Handling</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.12.</strong> Collections</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.13.</strong> Iterators</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.14.</strong> Attributes</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.15.</strong> Derive</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.16.</strong> Threads</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.17.</strong> Unsafe</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">3.18.</strong> Macros</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.</strong> Common Patterns</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">4.1.</strong> Derive</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.2.</strong> Monads</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.3.</strong> Interior Mutability</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.4.</strong> New Types</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.5.</strong> RAII / Drop and Finalise</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.6.</strong> Prefer Borrows</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.7.</strong> Type State</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">4.8.</strong> Builder</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.</strong> Rust Ecosystem</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">5.1.</strong> Project Structure</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.2.</strong> rustup</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.3.</strong> Error Handling with ThisError and Anyhow</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.4.</strong> log</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.5.</strong> mdbook</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.6.</strong> Itertools</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.7.</strong> Rayon</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.8.</strong> Clap</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.9.</strong> Async with Tokio and async_std</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.10.</strong> Serialisation with Serde</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.11.</strong> Parsing with Nom</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.12.</strong> Regex</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.13.</strong> reqwest</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.14.</strong> Crossbeam?</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.15.</strong> bitvec</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">5.16.</strong> Derive More</div></li></ol></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.</strong> Advanced Rust</div></li><li><ol class="section"><li class="chapter-item expanded "><div><strong aria-hidden="true">6.1.</strong> Foreign Function Interfaces</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.2.</strong> Proc Macro</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.3.</strong> Intro to Web Dev</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.4.</strong> Intro to Embedded</div></li><li class="chapter-item expanded "><div><strong aria-hidden="true">6.5.</strong> Intro to Game Dev</div></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Idiomatic Rust in Simple Steps</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="idiomatic-rust-in-simple-steps"><a class="header" href="#idiomatic-rust-in-simple-steps">Idiomatic Rust in Simple Steps</a></h1>
<p>Welcome to IRISS 👁️🦀</p>
<p>Rust has a reputation of being difficult to learn, certainly it was when I learned back in 2017. While its true that
there remain some rough edges, the language is now easier to pick up than ever, and in many ways is much easier than
a lot of more established languages.</p>
<p>The goal of this series is to help you go from no knowledge of Rust to understanding how Rust is written as quickly as
possible.</p>
<p>This book is the written version of a companion
<a href="https://www.youtube.com/playlist?list=PLW2L8KbM0O7aRi_Bt4YE1JuW9EdMs0ztR" title="" target="_blank">YouTube series</a></p>
<p>If you spot a problem with this guide (I’m only human 😅), please file an Issue or even a PR on the
<a href="https://github.com/Gisleburt/idiomatic-rust-in-simple-steps" title="" target="_blank">project repository</a> and I will be incredibly grateful.
I certainly don’t know <em>everything</em> about Rust and look forward to learning new things throughout this project.</p>
<p>In the meantime, you should start by <a href="./introduction/why.html">deciding if Rust is definitely the language for you</a>, and
what <a href="./introduction/resources.html">other learning resources</a> are available.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-or-why-not"><a class="header" href="#why-or-why-not">Why or Why Not</a></h1>
<ol>
<li><a href="introduction/why.html#why-rust">Why Rust</a></li>
<li><a href="introduction/why.html#why-not-rust">Why not Rust</a></li>
</ol>
<h2 id="why-rust"><a class="header" href="#why-rust">Why Rust</a></h2>
<p>I could tell you that it’s a “blazingly fast” language, that holds your hand and helps reduce bugs, that its first party
tooling is second to none, that it has a mature ecosystem and an amazing community. These are all good reasons to
consider using Rust for any personal or professional project. There is, however, in my mind, a singular reason everyone
should consider learning Rust:</p>
<p><strong>Because its fun</strong></p>
<p>Seriously, Rust is my happy place. Sure it has its frustrations like any language, but when I work with Rust I <em>feel</em>
smart, I have less horrible surprises, and I have a lot of confidence that my code will “just work”, that I won’t need
to come back to fix bugs and if I do, I will be able to quickly understand old code, write new tests and fix any
problems.</p>
<p>And, I’m not alone, since its 1.0 release Rust has been Stack Overflows “most loved” (now “most admired”) language eight
years in a row. This isn’t derived from fanatics like me just saying “its great” but is the percentage of people who
used the language this year, that still want to use it next year.</p>
<h2 id="why-not-rust"><a class="header" href="#why-not-rust">Why not Rust</a></h2>
<p>As much as I love Rust, there is a reason it may not be the language for you… and it’s a <em>big</em> one.</p>
<p>If you are specifically looking to learn a language to get a job (and you’re not interested in Blockchain) Rust is not
going to be a good language… for now. The irony of “professional Rust” is that Rust engineers think there are no Rust
employers, and Rust employers think there are no Rust engineers <em>because</em> very few of us are interested in Blockchain
technologies.</p>
<p>That said, things have been slowly changing. More businesses are picking it up due to its low cost to write, run and
maintain. The main cost to adopting Rust remains the cost of training people, but there are more and more of us out
there and perhaps 2024 will finally be the tipping point.</p>
<p>Nonetheless, right now, if you’re looking for a job,
<a href="https://survey.stackoverflow.co/2023/#most-popular-technologies-language-prof" title="" target="_blank">better languages to learn</a> would be
<a href="https://www.typescriptlang.org" title="" target="_blank">TypeScript</a> or <a href="https://www.python.org" title="" target="_blank">Python</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="other-learning-resources"><a class="header" href="#other-learning-resources">Other Learning Resources</a></h1>
<p>Its worth mentioning that there are many other Rust learning resources out there, so if this guide ends up not working
out for you, or you’re looking to supplement it with other sources, these are in my mind, the (other) best ways to learn
the Rust.</p>
<ol>
<li><a href="introduction/resources.html#the-official-book">The official book</a></li>
<li><a href="introduction/resources.html#rustlings">Rustlings</a></li>
<li><a href="introduction/resources.html#rust-by-example">Rust by Example</a></li>
<li><a href="introduction/resources.html#idiomatic-rust-in-simple-steps">Idiomatic Rust in Simple Steps</a></li>
</ol>
<h2 id="the-official-book"><a class="header" href="#the-official-book">The official book</a></h2>
<p><a href="https://doc.rust-lang.org/book/" title="" target="_blank">The Rust Programming Language</a> book is the official way to learn, and will be the
most complete guide. This is how I learned the language way back in 2017 and its gotten significantly better since then.
The main difference between the official book and this guide is that the official book focuses on teaching you how the
language works, while this guide is focused on how the language is written, only looping back to how the language works
to explain why we write it that way. This guide tries to follow a similar path to the official book and to Rustlings,
see below, so it should be easy to jump between them.</p>
<h2 id="rustlings"><a class="header" href="#rustlings">Rustlings</a></h2>
<p><a href="https://github.com/rust-lang/rustlings/" title="" target="_blank">Rustlings</a> is a “learn by doing” guide to Rust. It works by giving you
specific exercises to help you understand the language a bit at a time.</p>
<p>The gamification of the course makes it really fun, so I still use Rustlings to help keep myself sharp.</p>
<h2 id="rust-by-example"><a class="header" href="#rust-by-example">Rust by Example</a></h2>
<p><a href="https://doc.rust-lang.org/stable/rust-by-example/" title="" target="_blank">Rust by Example</a> does exactly what it says on the tin. It focuses on
the implementation of the Rust language.</p>
<p>This is great to quickly look things up if you know what you want to know, however, there’s some minor
pseudo-anti-patterns here that if you don’t already know are anti-patterns, you might be tempted to copy-paste. Don’t
worry though, we’ll cover these here but also tools like Clippy (which we’ll also cover) will be quick to point them
out.</p>
<h2 id="idiomatic-rust-in-simple-steps-1"><a class="header" href="#idiomatic-rust-in-simple-steps-1">Idiomatic Rust in Simple Steps</a></h2>
<p>So, why use IRISS if there are these other great resources?</p>
<p>Idiomatic Rust in Simple Steps lines up nicely with these other resources and can supplement them or vice versa. While
the other resources focus on simply learning the language, IRISS focuses on how and why we write the language the way
we do. This might seem like the same thing, but here we’ll ramp up on idioms quickly so that you can understand other
peoples code as well as write code that other people can understand.</p>
<p>This matters!</p>
<p>My biggest hot take of the software industry is that: Software engineers are not paid to write code, they’re paid to
solve problems.</p>
<p>The best engineers I’ve worked with have solved problems without writing a single line of code, and the cheapest code to
maintain is the code you didn’t write. Beyond this though, solving problems, even with code, takes understanding and
collaboration. If when you join a team you already understand why they write code the way they do, you’re going to
become productive much faster.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>In this section we’ll go through:</p>
<ul>
<li><a href="getting-started/./setup.html">How to install the language tools</a></li>
<li><a href="getting-started/./environment.html">How to set up your development environment</a></li>
<li><a href="getting-started/./hello-world.html">And how to create your very first program</a></li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-set-up"><a class="header" href="#getting-set-up">Getting Set Up</a></h1>
<ol>
<li><a href="getting-started/setup.html#mac-and-linux">Mac and Linux</a></li>
<li><a href="getting-started/setup.html#windows">Windows</a>
<ol>
<li><a href="getting-started/setup.html#windows-build-tools">Windows Build Tools</a></li>
<li><a href="getting-started/setup.html#rustup">Rustup</a></li>
<li><a href="getting-started/setup.html#gcc-optional-but-recommended">GCC (optional, but recommended)</a></li>
</ol>
</li>
</ol>
<h2 id="mac-and-linux"><a class="header" href="#mac-and-linux">Mac and Linux</a></h2>
<p>Before you begin, you need to make sure you have the appropriate build tools.</p>
<p>For Mac, make sure to run <code>xcode-select install</code></p>
<p>For Linux, you need to install gcc via your package manage, for example, on a Raspberry Pi, you might do
<code>sudo apt install gcc</code></p>
<p>Go to <a href="https://rustup.rs" title="" target="_blank">https://rustup.rs</a>, copy the command displayed there into your terminal.</p>
<p><img src="getting-started/images/rustup-mac.png" alt="Rustup Mac / Linux" /></p>
<p>You will be given the option for customizing the installation, but we don’t need to do that for now</p>
<pre><code class="language-sh">$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh

# [other information about the install appears here]

Current installation options:


   default host triple: x86_64-apple-darwin
     default toolchain: stable (default)
               profile: default
  modify PATH variable: yes

1) Proceed with installation (default)
2) Customize installation
3) Cancel installation
&gt;
</code></pre>
<p>Choose 1 and wait for installation to complete. To immediately use Rust’s tools now, you will need to run the command it
tells you to run at the end of the installer, however, you should only need to do this once as the installer makes the
changes necessary for new terminal sessions to pick up on the changes.</p>
<pre><code class="language-shell">$ source "$HOME/.cargo/env"
</code></pre>
<p>Now you can check whether everything has installed properly by running <code>cargo version</code> and you should see something
like this:</p>
<pre><code class="language-shell">$ cargo version
cargo 1.75.0 (1d8b05cdd 2023-11-20)
</code></pre>
<p>Cargo is the main tool we’ll use to build and work with Rust, you will need at least version <code>1.75</code> for this tutorial.</p>
<h2 id="windows"><a class="header" href="#windows">Windows</a></h2>
<p>Installing Rust on Windows is a bit more challenging, but you’ve got this, I believe in you.</p>
<p>All the important differences for Windows are explained on <a href="https://rustup.rs" title="" target="_blank">rustup.rs</a>, however, I personally
struggled a bit with this, so I’m laying it out here in my own words.</p>
<h3 id="windows-build-tools"><a class="header" href="#windows-build-tools">Windows Build Tools</a></h3>
<p>The first thing we’re going to need are some Microsoft build tools.</p>
<p>Head to <a href="https://visualstudio.microsoft.com/downloads/" title="" target="_blank">https://visualstudio.microsoft.com/downloads/</a> and download the
community edition.</p>
<p><img src="getting-started/./images/windows-visual-studio-community.png" alt="windows-visual-studio-community.png" /></p>
<p>The installer is the gateway to a huge number of tools and software, but we only need two things.</p>
<p>Click through to the Individual Components tab, and search for the following: <code>C++ x64/x86 build tools</code></p>
<p>Select the latest version.</p>
<p>Next search for: <code>Windows SDK</code></p>
<p>Select the latest version of the SDK for your version of Windows.</p>
<p>Finally, click install. You may get a prompt asking if you’d like to continue without workloads, which you do,
so continue.</p>
<p>The installation itself can take a while so grab a tea or something ☕</p>
<h3 id="rustup"><a class="header" href="#rustup">Rustup</a></h3>
<p>Once the Windows build tools are installed, head back to <a href="https://rustup.rs" title="" target="_blank">rustup.rs</a> and download <code>rustup-init.exe</code>.
Running this will install the tools we need.</p>
<p>Choose the default install options.</p>
<p>Once complete, we can check that things have been installed correctly by opening either <code>cmd</code> or <code>powershell</code> or your
terminal of choice, and run:</p>
<pre><code class="language-shell">cargo version
</code></pre>
<h3 id="gcc-optional-but-recommended"><a class="header" href="#gcc-optional-but-recommended">GCC (optional, but recommended)</a></h3>
<p>Wait, the rustup website doesn’t mention this!</p>
<p>I know, and you don’t <em>necessarily</em> need to do this. However, Rust is a language that can interop with other languages.
In particular, Rust works really well with existing C and C++ libraries, however, Windows and Linux us different C++
libraries. This can be fixed by installing <code>gcc</code>.</p>
<p>Like Microsoft’s build tools, gcc isn’t packaged by itself, but unlike Microsoft’s build tools there are many, many ways
to install it.</p>
<p>The easiest way I’ve found is to install the <a href="https://scoop.sh" title="" target="_blank">Scoop</a> package manager by following the instructions on
their website.</p>
<p>Once installed, all you need to do is run:</p>
<pre><code class="language-shell">scoop install main/gcc
</code></pre>
<p>You can check this worked by running <code>gcc --version</code></p>
<p>Phew! That’s it, congratulations! It took me over an hour to do this on my first attempt.</p>
<p>If you haven’t done already, its a good idea to restart your computer before moving on.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-development-environment"><a class="header" href="#the-development-environment">The Development Environment</a></h1>
<ol>
<li><a href="getting-started/environment.html#visual-studio-code">Visual Studio Code</a></li>
<li><a href="getting-started/environment.html#extensions">Extensions</a></li>
<li><a href="getting-started/environment.html#rust-analyzer">rust-analyzer</a></li>
<li><a href="getting-started/environment.html#codelldb">CodeLLDB</a></li>
<li><a href="getting-started/environment.html#even-better-toml">Even Better TOML</a></li>
<li><a href="getting-started/environment.html#crates">crates</a></li>
</ol>
<h2 id="visual-studio-code"><a class="header" href="#visual-studio-code">Visual Studio Code</a></h2>
<p>A software developers environment is something very specific to them. Some people love vim and neovim, others like Nova,
I’m personally a big fan of IntelliJ. If you’ve already found the tools for you, there’s no wrong answer here, use
whatever makes you happy.</p>
<p>If you’re new to software engineering though, and not looking to fork out potentially hundreds of dollars on tooling,
I recommend Visual Studio Code. It’s free, is perhaps the most widely used and supported editor today, and can be
greatly extended through plugins.</p>
<p>It’s the editor I’ll be using throughout this series as I believe it will be the most familiar to people.</p>
<p>To get started head over to <a href="https://code.visualstudio.com/" title="" target="_blank">https://code.visualstudio.com/</a> and download the right
version for your device.</p>
<p>After installing it, we will need some plugins to work with Rust. To get to extensions, open VSCode and press the
extensions button in the sidebar (by default the sidebar is on the left).</p>
<p><img src="getting-started/images/vscode-extensions.png" alt="VSCode Extensions" /></p>
<h2 id="extensions"><a class="header" href="#extensions">Extensions</a></h2>
<h3 id="rust-analyzer"><a class="header" href="#rust-analyzer">rust-analyzer</a></h3>
<p>Rust Analyzer will provide the bulk of language support that we’ll need. It’ll give us auto complete, syntax
highlighting and symbol editing that will just make our lives a lot easier. Search for <code>rust-analyzer</code> in the search
bar at the top of the extensions tab and click install.</p>
<p><img src="getting-started/images/vscode-extension-rust-analyzer.png" alt="vscode-extension-rust-analyzer.png" /></p>
<h3 id="codelldb"><a class="header" href="#codelldb">CodeLLDB</a></h3>
<p>As we learn any new language, one of the most important things for us to be able to do is see what’s actually happening.
CodeLLDB allows us to pause a program while its running and see what its doing. This lets us check that a program is
doing what we think its doing.</p>
<p><img src="getting-started/images/vscode-extension-codelldb.png" alt="vscode-extension-codelldb.png" /></p>
<h3 id="even-better-toml"><a class="header" href="#even-better-toml">Even Better TOML</a></h3>
<p>The Rust ecosystem makes heavy use of the TOML file format. We’ll talk about this more much later on but now is a good
time to pick up this extension.</p>
<p><img src="getting-started/images/vscode-extension-toml.png" alt="vscode-extension-toml.png" /></p>
<h3 id="crates"><a class="header" href="#crates">crates</a></h3>
<p>Rust developers share code through a mechanism called Crates. This extension will help us keep any crates we depend on
up to date. We won’t be using crates for a while, but it’s good to grab now.</p>
<p><img src="getting-started/images/vscode-extension-crates.png" alt="vscode-extension-crates.png" /></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hello-world"><a class="header" href="#hello-world">Hello World</a></h1>
<p>Now that we’re finally set up, lets create our first program. As is tradition, our first program is simply going to
print the words <code>Hello, world!</code>.</p>
<ol>
<li><a href="getting-started/hello-world.html#creating-a-new-rust-project">Creating a new Rust project</a></li>
<li><a href="getting-started/hello-world.html#anatomy-of-hello-world">Anatomy of Hello World</a></li>
<li><a href="getting-started/hello-world.html#running-and-debugging-rust">Running and Debugging Rust</a></li>
</ol>
<h2 id="creating-a-new-rust-project"><a class="header" href="#creating-a-new-rust-project">Creating a new Rust project</a></h2>
<p>Open Visual Studio Code and open the terminal.</p>
<p><strong>Pro Tip:</strong> If you’re new to Visual Studio Code and you want the editor to do something (say, for example, open a
terminal), hold <code>Ctrl</code> + <code>Shift</code> and press <code>P</code> (or <code>Cmd</code> + <code>Shift</code> and press <code>P</code> on Mac). You can then type the thing
you want to do, and it should show up in the list. Sometimes, like with Terminal, you might get a lot of results and
the one you want might need a little scroll. Normally for a Terminal you want to use it internally, so you’d scroll to
<code>Terminal: Create New Terminal</code></p>
<p><img src="getting-started/./images/vscode-any-command-terminal.png" alt="Open the terminal" /></p>
<p>Navigate to an appropriate location for your projects such as your home directory or my documents, depending on your
system.</p>
<p>The easiest way to do this on Mac and Linux is to do <code>cd ~</code></p>
<p>There isn’t really an equivalent on Windows, so if you aren’t sure you can instead use Explorer to open My Documents,
right-click an empty space in the window, click “More Options” then “Open in Terminal”</p>
<p>Run <code>cargo new hello-world</code>, and cargo will report that it has created the project</p>
<p>Cargo is the program we’ll use to run our rust programs as well as many of the rust tools that will help us along the
way.</p>
<p>Now in Visual Studio Code, go to File -&gt; Open Folder and navigate to the hello-world folder we just created.</p>
<p>You can see that cargo has created some files for us. We’re going to talk about the cargo files later but for now,
head into the <code>src</code> directory and open main.rs</p>
<p>You can see the file has already been created with the following code:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Hello, world!");
}</code></pre></pre>
<p>Before we dive into this further, lets run the program.</p>
<p>Open the terminal again, as we did before. This time use <code>cargo run</code> to run our program, you should see something like
the following:</p>
<pre><code class="language-sh">$ cargo run
   Compiling hello-world v0.1.0 (D:\Documents\hello-world)
    Finished dev [unoptimized + debuginfo] target(s) in 0.33s
     Running `target\debug\hello-world.exe`
Hello, world!
</code></pre>
<p>Well, that was easy 😅</p>
<p>You’ll find the Rust community has put a lot of effort into making Rust as easy as possible to learn and use.</p>
<h2 id="anatomy-of-hello-world"><a class="header" href="#anatomy-of-hello-world">Anatomy of Hello World</a></h2>
<p>Let’s talk about hello world.</p>
<p>The first line <code>fn main()</code> describes a function (fn) called main. Functions are a useful way to group up a bit of code
to be called elsewhere. We’ll talk more about the power of functions and when to use them in a future chapter. For now
all we need to know is that the main function is called when the program starts, so any code we put in here will run.</p>
<p>At the moment, the only line of code is <code>println!("Hello, world!");</code>. A lot of engineers might assume this is how we
call functions in Rust, and that <code>println</code> is the function name. However, the exclamation mark actually tells us this
is a macro. Macros are very powerful and can do much more than functions, however they are an advanced topic, and we
won’t be creating our own until much later. We will be using pre-written macros a fair bit though.</p>
<p><code>println!</code> will write what it’s given to the console.</p>
<h2 id="running-and-debugging-rust"><a class="header" href="#running-and-debugging-rust">Running and Debugging Rust</a></h2>
<p>Before we end this section, I want to quickly set up one of the most powerful tools we have thats going to help us
learn incredibly quickly.</p>
<p>First let’s make a quick change to our program, by adding a variable with our name, and then saying hello to ourselves
instead of the whole world</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    let name = "Daniel";
    println!("Hello, {name}!");
}</code></pre></pre>
<blockquote>
<p>Fun fact, Rust uses utf-8 strings when written like this, so don’t worry if your name can not be properly represented in
American English characters. For example, I might naively write my cats name like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let name = "ユキ";
<span class="boring">}</span></code></pre></pre>
<p>However, this won’t actually output correctly unless your system is set up to display it (thanks Windows).</p>
</blockquote>
<p>Hover the mouse over the <code>3</code> denoting line 3 (where the <code>println!</code> should be) you should see a little red dot  appear.
Click this dot to set a break point. When debugging code, the debugger will pause at break points allowing us to see
what’s actually happening.</p>
<p><img src="getting-started/./images/vscode-breakpoint.png" alt="Breakpoints" /></p>
<p>To debug our code press F5… and it will immediately show you an error. Don’t panic! This is where CodeLLDB is going
to do some magic for us. The error is because we didn’t set a default run configuration, click OK and Visual Studio Code
will ask if you want to generate one.</p>
<blockquote>
<p><strong>Important:</strong> Depending on your personal configuration, it may ask you want to create the configuration from. If you
are asked this, click <code>LLDB</code>.</p>
</blockquote>
<p>Click “yes”, then press F5 again, and the program will start and then pause when it hits line 3.</p>
<p>If you mouse over <code>name</code> on either line 2 or line 3, you’ll see its value. Being able to see what’s happening in a
running program is a programming superpower.</p>
<p><img src="getting-started/./images/vscode-debug.png" alt="Breakpoints" /></p>
<p>To let the program continue, hit F5 one more time.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="language-basics"><a class="header" href="#language-basics">Language Basics</a></h1>
<p>In this section we’re going to step through the language basics, attempting to cover enough to quickly move on to
language idioms. By doing this, we hope that people won’t end up with a lot of bad habits (like some of us did) as the
“easy” bits that help you get started end up overly ingrained in your memory.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="memory"><a class="header" href="#memory">Memory</a></h1>
<p>When you create a program, how does it remember things? In the last chapter, we created a variable and put our name
inside it. Where was our name stored?</p>
<p>Jumping into memory already might seem unusual. A lot of programming tutorials in any language would like to get you
writing code before you have to worry about such things. However, I think right off the bat we have a wonderful
opportunity to talk about how memory works in Rust and, because memory is so important to how Rust works, I think this
will simplify everything you learn going forward.</p>
<p>We’re going to make an extremely simple program and use that as the basis to explain how Rust remembers.</p>
<h2 id="the-guessing-game"><a class="header" href="#the-guessing-game">The Guessing Game</a></h2>
<p>To learn about memory, we’ll make a simplified version of the
<a href="https://doc.rust-lang.org/book/ch02-00-guessing-game-tutorial.html" title="" target="_blank">guessing game</a>
from the official Rust book. Start by opening your terminal and navigating to where-ever your creating you projects like
in the last chapter, then we’ll create a new project with:</p>
<pre><code class="language-shell">cargo new guessing-game
</code></pre>
<p>Open the project in you editor and open the file <code>src/main.rs</code>. As before we’ll see the same “hello, world” program:</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Hello, world!");
}</code></pre></pre>
<p>As we step through this tutorial, if you mouse over the code examples, you can see some buttons that will let you</p>
<ol>
<li>⎘ Copy the example to your clipboard</li>
<li>⏵ Run the example via <a href="https://play.rust-lang.org" title="" target="_blank">rust playground</a> (where possible)</li>
<li>👁 Show any code I’ve opted to hide for clarity, try this on the next block</li>
</ol>
<p>Let’s quickly change our hello world message to something that welcomes us to the game.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    println!("Welcome to the guessing game!");
<span class="boring">}</span></code></pre></pre>
<p>And ask the user to do something:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    println!("Welcome to the guessing game!");
</span>    println!("I have chosen a color red, green or blue, can you guess which?");
<span class="boring">}</span></code></pre></pre>
<p>Because we’ve used a second <code>println!</code> this will appear on a new line. The new line actually comes at the end of the
<code>println!</code> so if you want to make both sentences appear on the same line, you can change the first one with <code>print!</code>
(no “ln”). Try it out and see what else you might need to change!</p>
<p>Let’s pick a color that the user has to guess. To begin with we’ll just hard code one value, later we’ll make it choose
randomly. I’m going to choose blue, but you can choose whatever you like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>    let actual = "blue";
<span class="boring">    println!("Welcome to the guessing game!");
</span><span class="boring">    println!("I have chosen a color red, green or blue, can you guess which?");
</span><span class="boring">}</span></code></pre></pre>
<p>Before we move on, I want to call out the “type” of the data we’ve just created.</p>
<p>We’re going to talk about types in the next chapter, but I want to quickly point some things out. The type of data
describes a number of things but mainly, how that data is represented in memory and how it can be used. For example, is
the data a string (like “blue”), or a number, or a boolean that represent true or false.</p>
<p>If you’re using an editor that shows type information you might see that next to <code>actual</code> its written something like
<code>: &amp;str</code>, eg:</p>
<p><img src="language-basics/memory/type-annotation.png" alt="type-annotation.png" /></p>
<p>This means that the variable <code>actual</code> contains a “reference” (represented by the <code>&amp;</code>) to a “string slice” (represented
by <code>str</code>). We’ll talk about why the variable only contains a reference and not the data itself later. You could, if you
like, manually write this <code>let actual: &amp;str = "blue"</code> yourself, however, it’s generally better to let Rust infer the
type, and only write it yourself if either Rust is unable to decide (because it could be multiple things) or if you want
to use something different.</p>
<p>This is why it’s a good idea to make sure whatever you’re writing Rust in shows you what
Rust has decided a type is. For example, the default integer type in Rust is <code>i32</code> (don’t worry, we’ll explain this
later), however your program might have specific requirements that make it sensible to annotate the type so that Rust
uses a <code>u64</code> instead. (Yes, Rust has many different types for representing numbers, we’ll worry about that next time 😊)</p>
<p><img src="language-basics/memory/inferred-vs-annotated.png" alt="inferred-vs-annotated.png" /></p>
<p>Anyway, back to the program: let’s output the color. This will end up being the last thing in the program, but we can
use this to check everything is working ok:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">    let actual = "blue";
</span><span class="boring">    println!("Welcome to the guessing game!");
</span><span class="boring">    println!("I have chosen a color red, green or blue?");
</span>    println!("The color I chose was {actual}");
<span class="boring">}</span></code></pre></pre>
<p>We can run this now and see that the color to be guessed was entered.</p>
<p>Great… but not much of a game is it.</p>
<p>In order to get some user input, we need to read from the terminal. Before we tell the user what the actual color was
lets ask them to guess</p>
<pre><code class="language-rust noplayground"><span class="boring">fn main() {
</span><span class="boring">    let actual = "blue";
</span><span class="boring">    println!("Welcome to the guessing game!");
</span><span class="boring">    println!("I have chosen a color red, green or blue");
</span><span class="boring">   
</span>    println!("Enter your guess: red, green or blue");
<span class="boring">   
</span><span class="boring">    println!("The color I chose was {actual}");
</span><span class="boring">}</span></code></pre>
<p>We’re then going to read a line of input from the user. When the program runs in the terminal, we can ask the user to
type things, regardless of whether you are on Windows, Mac or Linux, this input is passed into the program through a
stream of data called <code>stdin</code> (standard in).</p>
<p>Rust comes with a “standard library” (the name is unrelated to the stream) that we can access as a module called <code>std</code>.
I pronounce this S T D, but you may also here people call it “stud”. Modules in Rust are a way of grouping up other bits
of code such as functions, data types and even other modules. We’ll talk about them more in a future lesson. Inside of
this is another module called <code>io</code> that deals with input and output. If we weren’t using the <code>println!</code> macro, this is
where we’d have to come to write things out to the terminal too, via a stream called <code>stdout</code> (standard out).</p>
<blockquote>
<p>For completion’s sake I should mention there is one more stream called <code>stderr</code> (standard error). This is also an
output stream that we can use to separate “good” output that is relevant to the normal use of the program to really
any other kind of output, whether that be errors or just information not directly relevant to the main output.</p>
<p>For example, on Mac and Linux, if you use <code>cargo run 2&gt; /dev/null</code> to run your program, you’ll see that you lose the
messages about your program being compiled because we redirected stderr (stream 2) to the void of <code>/dev/null</code>, and
Cargo sensibly decided that <em>it’s</em> output is not relevant to your programs normal output</p>
<p>On Windows the same can be achieved in cmd using <code>cargo run 2&gt; nul</code> (note, only one l in nul), or in powershell with
<code>cargo run 2&gt; $null</code> (two l’s this time and a dollar, no idea why it’s different)</p>
<p><code>stderr</code> is really useful for things like logging, and we’ll talk more about streams in the future, but if you want
to quickly write something to this stream you can use <code>eprintln!</code> and <code>eprint!</code> the same way we use <code>println!</code> and
<code>print!</code></p>
</blockquote>
<p>So, we get stdin using <code>std::io::stdin()</code>, this is a function call (we’ll talk about functions in a couple of chapters),
that returns something called a “handle” that we can use for temporary access to the input stream.</p>
<p>The double colons just tell Rust that you’re looking for something inside a module. We’ll cover modules in detail later,
including how, why and when to make your own, as well as better ways to access them, but since we only need to write
this line once, this is the easiest way to do it.</p>
<p>We could store the result of <code>stdin()</code> in a variable, however, we only use this once, and then we’re done with it, so,
off the back of the function call, we can call immediately call <code>.lines()</code>. This is a method (a special type of function
that belongs specifically to some other thing, in this case it belongs to the handle for stdin). In the example below
I’ve put this on a new line for legibility, but you don’t <em>need</em> to do this.</p>
<p><code>.lines()</code> returns an iterator, allowing us to iterate (step through) each line one at a time. We get the next line by
calling <code>.next()</code> on the iterator.</p>
<p>If we add this all in our code looks like this</p>
<pre><code class="language-rust noplayground no_run"><span class="boring">fn main() {
</span><span class="boring">   let actual = "blue";
</span><span class="boring">   
</span><span class="boring">   println!("Welcome to the guessing game!");
</span><span class="boring">   println!("I have chosen a color red, green or blue");
</span><span class="boring">   
</span><span class="boring">   println!("Enter your guess: red, green or blue");
</span>    let input = std::io::stdin()
        .lines()
        .next()
        .expect("No input was read")
        .expect("There was an error when reading the input");
            
    println!("Your guess was {input}");
<span class="boring">
</span><span class="boring">   println!("The color I chose was {actual}");
</span><span class="boring">}</span></code></pre>
<p>Wait wait wait, what are those <code>expect</code>s about?!</p>
<p><code>expect()</code> is, I would say, the second-worst way you could handle something going wrong in your program. This is not
“idiomatic” and you absolutely should not use this in anything except the most throw away software as it will
immediately cause the program to stop and spew a lot of information at the user. In the future we’ll talk about things
going wrong and how to better handle them, however, as this program is just for you, I think you’ll cope for now. 😊</p>
<p>That doesn’t explain what these lines are doing, or why there are two of them though. The reason for this is that there
are two possible ways <code>.lines()</code> might not work.</p>
<p>The first expect then:</p>
<pre><code class="language-rust ignore">.expect("No input was read")</code></pre>
<p>When we call <code>.next()</code> on any iterator, there either is something next or there isn’t.  In some languages this
might return either the data you expect, or a <code>null</code> value. For example, it might return <code>"red"</code> or <code>null</code>. “red” is a
string but null is not, what happens if you pass this to a function that expects a string? This means you must either
manually check the thing returned was null, or don’t check, and risk your program breaking at some other point.
Obviously many people think this ambiguity is bad, including Tony Hoare, arguably the “inventor” of this  behavior, who
has called it his “billion-dollar mistake”.</p>
<p>Rust does not allow you to use types like this interchangeably, i.e. data can not be a string or null as these types are
not compatible. In Rust, we use a kind of container type to get around this called <code>Option</code>. Importantly, when a
function returns an <code>Option</code> type you, the programmer, must check to see if it contains something, and then extract the
thing if it’s there. There are a number of ways to do this and <code>.expect</code> is one of the worst ways to do this (we’ll talk
about better ways in the future), as it will attempt to extract the data if its there, or stop the program abruptly with
the provided error message if it’s not.</p>
<p>For the time being we’re going to just say we can’t deal with it not being there, we don’t want to continue running the
program, and we want the program to stop. We use <code>.expect("message")</code> to say, if this is nothing, we are giving up,
stop the program and print our message (plus a few other useful bits) to the <code>stderr</code> (see above). You can see why this
behaviour is typically undesirable but that we can allow it for this example, at least until we learn how to deal with
<code>Option</code> properly.</p>
<p>The second expect is a bit different:</p>
<pre><code class="language-rust ignore">.expect("There was an error when reading the input");</code></pre>
<p>If the Option we got from <code>.next()</code> contains something instead of nothing, it <em>still</em> doesn’t necessarily mean we read
the users input correctly, reading data from <code>stdin</code> is itself fallible.</p>
<p>Fallibility, the nature that something may go wrong, in programming is another thing we’ve traditionally handled very
badly. A common way to deal with this in other languages is to stop executing and “throw” an error. The problem with
throwing errors is that it breaks the flow of execution, the next thing to get executed is not obvious, it’s going to
be wherever the error is “caught”… if it’s “caught”. Sometimes you may not even realise that some code you’ve written
could throw an error because you’ve called someone else’s code, and they didn’t make it obvious that their code could
fail.</p>
<p>Rust does away with this with another type called <code>Result</code>. If your function can fail, it must return a Result type.
Like with <code>Option</code>, <code>Result</code> is its own type that contains either the data we wanted, or an error.</p>
<p>Again, the idiomatic way to handle this depends on what you’re trying to do; is the error recoverable (could the program
continue despite the error), and how do we want to report the error back to the user. Using <code>expect</code> will, again, cause
the program to immediately stop with the error message and other bits sent to <code>stderr</code>, and again, you can see why this
is typically extremely undesirable.</p>
<p>But anyway, we now have a working program, there is an actual color, the user guesses a color, and we print both to the
screen.</p>
<h2 id="memory-1"><a class="header" href="#memory-1">Memory</a></h2>
<p>You might have spotted that <code>actual</code> and <code>input</code> have different types (don’t worry if you didn’t, when you added all the
code associated with getting the input, it added a lot of types, so you could easily miss it).</p>
<p>Importantly though, <code>actual</code> is a <code>&amp;str</code>, which is a reference to a string slice. However, <code>input</code> is a <code>String</code>.</p>
<p>What’s the difference?</p>
<h3 id="the-stack"><a class="header" href="#the-stack">The Stack</a></h3>
<p>To understand this, we have to talk a little bit about how our program runs.</p>
<p>In Rust (and many languages in fact), programs are made up of functions; small, independent bits of code. In our
program we only have one function for now, which is <code>main</code>, but this still applies. When we run our program, the
operating system assigns some memory for the program to run in, called “the stack”.</p>
<blockquote>
<p>Aside: Some people like to think about the stack going from top to bottom because the memory address go down like
lines on a page (or lines of code), but most people talk about it going from bottom to top because we talk about
putting things on the stack which is easier to visualise. It’s an abstraction, so it doesn’t really matter. I’m going
to explain it from bottom to top as I think this makes visualising the manipulation of the stack easier.</p>
</blockquote>
<p>Each time we run a function we create a new block of memory on the stack that’s the exact size of everything that
function needs to remember. So, for example, if our function has three numbers in it, then our new block on the stack
will be exactly the size of required to store those three numbers.</p>
<p><img src="language-basics/memory/stack.gif" alt="How the Stack works" /></p>
<p>In the example above we’re representing the memory of the stack. When the program is initialized the operating system
assigns some memory for the stack, then, all the memory required to store all the variables in <code>main</code> (which it in this
example is 4 addresses) is blocked off. Then, as <code>main</code> runs, it calls another function, <code>f1</code> which requires two
more addresses. <code>f1</code> then calls another function which requires 3 addresses worth of memory, <code>f2</code>. Once <code>f2</code> has
finished, it is removed from the stack, then <code>f1</code> finishes, and it too is removed from the stack. Finally <code>main</code> comes
to an end and our program closes and all memory is freed.</p>
<p>You can see that the amount of memory a function needs is very important, but… how long is a <del>piece of</del> string?</p>
<p>Our three colors, “red”, “blue” and “green” are 3 characters, 4 characters and 5 characters respectively. How much
memory should we assign on the stack? What about the users input? Is that 3 characters, 4 characters or the complete
works of Shakespeare? How much memory each function will require is decided at build time, and we don’t know what the
user is going to write until later.</p>
<p>Anything that lives inside a variable goes on the stack, and anything on the stack must be of known size when the
program is compiled. In Rust, we have a specific name for this “Sized”. Things like numbers, characters, booleans
and even tuples are Sized, but a string of characters is not, it is “Unsized”.</p>
<p>So where does our data live if not inside the variables?</p>
<p>Returning to the top, you’ll remember that our <code>actual</code> variable has the type <code>&amp;str</code> which is a reference (<code>&amp;</code>) to a
string slice <code>str</code>. A reference is something that points to where some actual data is, this is very handy when you want
to tell something about some data without having to give it the specific data. When you manually write a string between
double quotes <code>"like this"</code>, it’s called a “string literal”. This applies to our variable as well as every time we’ve
used in a <code>println!</code>. A “string slice” can be any part of a string stored somewhere else, so it can be characters 0 to 3
(b, l, u, e) of our string literal that’s stored in the executable.</p>
<h3 id="the-heap"><a class="header" href="#the-heap">The Heap</a></h3>
<p>Our <code>input</code>, however, is very different, we don’t know what’s going to be in here at all at compile time. In order to
store the data that the user gives us, we still need to put it in memory somewhere, but it can’t live on the stack.</p>
<p>Instead, we use another kind of memory called “the Heap”. At any point while the program is running, we can ask the
operating system to allow us to access some amount of memory. We still need to know how much memory we need, but now we
only need to know how much memory at runtime. This memory comes from the Heap. In the heap, we can store “Unsized” data
(as well as Sized which can be useful under certain circumstances) and, then because everything about the location of
that data is Sized, we can store it in a variable on the stack. <code>String</code> does not contain the data, but does know where
the data is.</p>
<p>Some other important differences between the Stack and the Heap. The Stack is more limited in size, you should try to
avoid storing large amounts of data here (even if the size is known). Creating memory on the Heap takes longer than
creating it on the Stack, this is because you have to communicate your requirements to the operating system and
wait for it to get back to you with that allocation. This doesn’t take too long, but one thing to watch out for is
repeatedly increasing the amount you need. If you create a string of a certain size, then ask for more memory (eg, by
appending more data to it), then in the background Rust will ask the operating system for a new, larger block of memory,
then it has to copy the old data to it, before adding anything else on to the end.</p>
<p>This is all great, but why is one of them <code>&amp;str</code> and one of them <code>String</code> if both of them are just references to data
stored elsewhere? This actually comes down to “ownership”. We’ll go into ownership in more detail later in a later
chapter but at a very high level a reference to a string slice does not own the string data. Ownership allows full
control over the data, and most importantly, it tells the program when to clean up the data. When an <code>&amp;str</code> is no longer
needed, the reference is cleaned up, but the data still exists. When a <code>String</code> is no longer needed, not only is the
reference cleaned up, but memory is returned to the operating systems control, freeing it up for something else to use.</p>
<p>It’s important to note though that <code>&amp;str</code> and <code>String</code> are different types. The data they reference is formatted the
same way in memory, but they are not interchangeable. Later, when we discuss functions, you’ll see that if a function
requires a <code>String</code> you can not pass it a <code>&amp;str</code> and vice versa. You can, however, trivially go from one to another.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let name = "Daniel";                   // This is a &amp;str pointing at a sequence of bytes in the executable
let name_on_heap = String::from(name); // This requests memory from the operating system then copies "Daniel" into it
let name_ref = name_on_heap.as_str();  // This is a &amp;str pointing to a sequence of bytes on the heap
<span class="boring">}</span></code></pre></pre>
<p>That said, they can be compared to each other (this actually goes for any data type in Rust so long as someone has told
Rust how to do the comparison, which for <code>&amp;str</code> and <code>String</code>, someone has).</p>
<p>Let’s return to our program one last time. Below I’ve written out the full program and added an <code>if</code>/<code>else</code> statement.</p>
<p><code>if</code>/<code>else</code> is a form of control flow. We put an expression inside the “if” that evaluates to either true or false, in
this  case we’re asking if <code>input</code> is equal to <code>actual</code>. If it is, then the execution continues inside the if block
(the bit between the curly brackets), if it’s not true, then instead execution continues inside the else block.</p>
<pre><code class="language-rust noplayground no_run">fn main() {
    let actual = "blue";
    
    println!("Welcome to the guessing game!");
    println!("I have chosen a color red, green or blue");
    
    println!("Enter your guess: red, green or blue");
    let input = std::io::stdin()
            .lines()
            .next()
            .expect("No input was read")
            .expect("There was an error when reading the input");
            
    println!("Your guess was {input}");
    println!("The color I chose was {actual}");
    
    if input == actual {
        println!("you win!");
    } else {
        println!("you lose!");
    }
}</code></pre>
<h2 id="to-review"><a class="header" href="#to-review">To Review:</a></h2>
<p>Today we learned specifically about the Stack and Heap:</p>
<ul>
<li>
<p>The Stack is where variables live, data must be of known size at compile time (Sized), but access is very fast.</p>
</li>
<li>
<p>The Heap is where we can store things regardless of whether we know their size at compile time (Sized and Unsized).
We can store large amounts of data here but getting access to this memory initially is a tiny be slower.</p>
</li>
<li>
<p>You can reference data with <code>&amp;</code> if you don’t want ownership of the data, but you do want to access it.</p>
</li>
</ul>
<p>We also learned a bit about <code>Option</code> and <code>Result</code> which we will go into more in the next chapter, and future chapters
too.</p>
<p>Finally, we learned that we can control the flow of execution with <code>if</code>, however, this isn’t the only way we can effect
the flow, and we’ll talk more about this in a couple of chapters.</p>
<p>Next time we’re going to look more at data types; what the basic types are, how we create new types, and how we can
merge types together.</p>
<h2 id="bonus"><a class="header" href="#bonus">Bonus</a></h2>
<p>You don’t need to do this but if you want to make your <code>actual</code> value random(ish) and turn this into a proper game,
then you could do it like this:</p>
<pre><code class="language-rust noplayground no_run"><span class="boring">fn main() {
</span>    let colors = ["red", "green", "blue"];
    let time = std::time::UNIX_EPOCH
        .elapsed()
        .expect("Call the Doctor, time went backwards")
        .as_millis() as usize; // We only need the least significant bits so this is safe
    let actual = colors[time % colors.len()];
<span class="boring">   
</span><span class="boring">   println!("Welcome to the guessing game!");
</span><span class="boring">   println!("I have chosen a color red, green or blue");
</span><span class="boring">   
</span><span class="boring">   println!("Enter your guess: red, green or blue");
</span><span class="boring">   let input = std::io::stdin()
</span><span class="boring">           .lines()
</span><span class="boring">           .next()
</span><span class="boring">           .expect("No input was read")
</span><span class="boring">           .expect("There was an error when reading the input");
</span><span class="boring">           
</span><span class="boring">   println!("Your guess was {input}");
</span><span class="boring">   println!("The color I chose was {actual}");
</span><span class="boring">   
</span><span class="boring">   if input == actual {
</span><span class="boring">       println!("you win!");
</span><span class="boring">   } else {
</span><span class="boring">       println!("you lose!");
</span><span class="boring">   }
</span><span class="boring">}</span></code></pre>
<p>First we create an array of string slices for each possible value. Arrays are of known size at build time, for example,
this one contains three string slice references, therefore its size is 3x whatever the size of a reference is. This
means it’s Sized, therefore does exist on the stack. We’ll talk more about dynamic (therefore Unsized) collections in
the next chapter.</p>
<p>To fake randomness we’re going to take the time at the Unix Epoch (the 1st of January 1970) and find the <code>Duration</code> of
time that has elapsed since then. Asking how much time has passed <em>since</em> another point in time is fallible because you
might be asking about a time in the future, this means we have to deal with a <code>Result</code>. This <em>shouldn’t</em> ever actually
return an error, but even when you’re absolutely sure, there’s no harm leaving a little message in the <code>.expect()</code> for
anyone else who happens to be looking at the code.</p>
<p><code>.as_millis</code> turns the duration into a 128bit integer (<code>u128</code>), but collections (like our array) are index with a
<code>usize</code>. The exact length in bits of a <code>usize</code> depends on the target system you’re building for (usually 64bits but not
always). Because 128bits is longer than 64bits we need to shrink it down. <code>as usize</code> will truncate the most significant
bits. This <em>can</em> mean your number changes, but we don’t actually care for our purposes, we just want a nice big number
that is different each time we run the program. I left myself a comment (using <code>//</code> you can write things that aren’t
code), so that if I wonder why I did this in the future, I’ll know.</p>
<p>Finally, we pick a random color from our colors array by dividing the time in milliseconds since the 1st of January 1970
by the length of the array (3) and getting the remainder. You can do all of this with the remainder <code>%</code> operator. This
gives us a number between 0 and 2 inclusive, so we use that number as the index in our array using the square brackets.</p>
<p>This leaves us with one of the string slice references from the array, which one will depend on the exact time when you
run the game.</p>
<blockquote>
<p>⚠️ <strong>Important:</strong> In some languages <code>%</code> is the <a href="https://en.wikipedia.org/wiki/Modulo" title="" target="_blank">modulo operator</a>, in Rust it is the
remainder operator.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-types"><a class="header" href="#data-types">Data Types</a></h1>
<p>In programming a Type describes what kind of data or values can be used in a particular circumstance.</p>
<p>In Rust, we use Types to describe variables, parameters, properties or anywhere else you can have a value, so that the
compiler knows what the data at that point will look like inside the running program, and how it will behave. This can
include how the where in memory the data lives, how it’s represented in memory, and what functionality can be assigned
to the data (though we’ll cover that last part in the upcoming Functions chapter).</p>
<h2 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h2>
<p>Primitive types are effectively the building blocks of all other types.</p>
<p>I think this is an early point in learning Rust that scares off a lot of potential new Rust engineers. You see, Rust has
a <em>lot</em> of primitive types.</p>
<p>I’m going to show this to you now, but I don’t want you to worry about it. You, whoever you are dear reader, have
already achieved things more complicated than learning this 🙂</p>
<p>So, are you ready to see something terrifying that long before the end of the chapter you’re going to have a complete
handle on?</p>
<div class="table-wrapper"><table><thead><tr><th>types</th><th>8bit</th><th>16bit</th><th>32bit</th><th>64bit</th><th>128bit</th><th>memory width</th></tr></thead><tbody>
<tr><td>unsigned integers</td><td>u8</td><td>u16</td><td>u32</td><td>u64</td><td>u128</td><td>usize</td></tr>
<tr><td>signed integers</td><td>i8</td><td>i16</td><td>i32</td><td>i64</td><td>i128</td><td>isize</td></tr>
<tr><td>floating points</td><td></td><td></td><td>f32</td><td>f64</td><td></td><td></td></tr>
<tr><td>characters</td><td></td><td></td><td></td><td>char</td><td></td><td></td></tr>
<tr><td>booleans</td><td>bool</td><td></td><td></td><td></td><td></td><td></td></tr>
<tr><td>string slices</td><td></td><td></td><td></td><td></td><td></td><td>&amp;str</td></tr>
</tbody></table>
</div>
<p>This is how many primitive types there are in Rust! And yes, as scary as it is, you will completely understand this in
just a few minutes!</p>
<p>First and most importantly, forget the above, there’s really only five type categories that we actually care about:</p>
<div class="table-wrapper"><table><thead><tr><th>types</th></tr></thead><tbody>
<tr><td>integers</td></tr>
<tr><td>floating points</td></tr>
<tr><td>characters</td></tr>
<tr><td>booleans</td></tr>
<tr><td>string slices</td></tr>
</tbody></table>
</div>
<p>We’ll go over each of these individually, explain how they work, their variations and what you might use them for.</p>
<p>Before we do, lets very quickly cover binary.</p>
<h3 id="binary-primer"><a class="header" href="#binary-primer">Binary Primer</a></h3>
<p>Don’t panic! No one is expecting you to learn to count in binary. Counting in binary is fun, but pretty useless. 😅</p>
<p>All I want to do is show you how things are represented in memory because it’s going to make all those Rust types make a
lot of sense!</p>
<p>Humans (mostly) count in base 10. That’s numbers going from 0 to 9. You can imagine numbers as a series of columns,
where each column represents how many 1s, 10s, 100s, etc there are in the number.</p>
<p>For example, the number 123 contains one lot of 100, two lots of 10, and three lots of 1</p>
<div class="table-wrapper"><table><thead><tr><th>Columns:</th><th>100</th><th>10</th><th>1</th></tr></thead><tbody>
<tr><td>Count:</td><td>1</td><td>2</td><td>3</td></tr>
</tbody></table>
</div>
<p>When we add numbers to the columns, if the column goes over 9, then we change it back to 0 and add 1 to the next
column along.</p>
<p>So, if we add 1 to 9, it goes to 10,</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right">Columns:</th><th>10</th><th>1</th></tr></thead><tbody>
<tr><td style="text-align: right">1 +</td><td>0</td><td>9</td></tr>
<tr><td style="text-align: right">=</td><td>1</td><td>0</td></tr>
</tbody></table>
</div>
<p>19 goes to 20</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right">Columns:</th><th>10</th><th>1</th></tr></thead><tbody>
<tr><td style="text-align: right">1 +</td><td>1</td><td>9</td></tr>
<tr><td style="text-align: right">=</td><td>2</td><td>0</td></tr>
</tbody></table>
</div>
<p>and 99 goes to 100 because the roll-over from the right most 9 adds to the next 9 also causing it to roll over.</p>
<div class="table-wrapper"><table><thead><tr><th style="text-align: right">Columns:</th><th>100</th><th>10</th><th>1</th></tr></thead><tbody>
<tr><td style="text-align: right">1 +</td><td>0</td><td>9</td><td>9</td></tr>
<tr><td style="text-align: right">=</td><td>1</td><td>0</td><td>0</td></tr>
</tbody></table>
</div>
<p>This counting system is called base 10 as each of those columns is 10 raised to the power of which column it is,
starting at 0:</p>
<ul>
<li>10^0 = 1</li>
<li>10^1 = 10</li>
<li>10^2 = 100</li>
<li>10^3 = 1000</li>
<li>etc</li>
</ul>
<p>Eg:</p>
<div class="table-wrapper"><table><thead><tr><th>Column number:</th><th>3</th><th>2</th><th>1</th><th>0</th></tr></thead><tbody>
<tr><td>As power:</td><td>10^3</td><td>10^2</td><td>10^1</td><td>10^0</td></tr>
<tr><td>Column value:</td><td>1000</td><td>100</td><td>10</td><td>1</td></tr>
</tbody></table>
</div>
<p>Electronics, and by extension computers, can only really cope reliably with things that are <code>on</code> or <code>off</code> though. How do
you count with only on or off? Well, what if instead of having ten possible values in each column (0-9 or base 10), we
only have two (0-1 or base 2). This is binary.</p>
<p>In binary our columns are a bit different:</p>
<ul>
<li>2^0 = 1</li>
<li>2^1 = 2</li>
<li>2^2 = 4</li>
<li>2^3 = 8</li>
<li>etc</li>
</ul>
<p>So if we want to represent the number 13 in base 2, we can see it contains one 8, one 4, and one 1 (8+4+1 = 13). If we
mark those columns as one’s and the others as zeros we get:</p>
<div class="table-wrapper"><table><thead><tr><th>Columns:</th><th>8</th><th>4</th><th>2</th><th>1</th></tr></thead><tbody>
<tr><td>Count:</td><td>1</td><td>1</td><td>0</td><td>1</td></tr>
</tbody></table>
</div>
<p>Sometimes when we want to write something in binary and be explicit that that is the system we’re using we might write:
<code>0b1101</code>. The <code>0b</code> at the start makes it clear that a number like <code>0b1101</code> represents “thirteen” and not “one thousand
one hundred and one.</p>
<p>Each 1 or 0 is a <em><strong>b</strong></em>inary dig<em><strong>it</strong></em>, which is where we get the term “bit”.</p>
<p>Eight bits is a byte, and can represent the numbers from <code>0b0000_0000</code> (zero) to <code>0b1111_1111</code> (two hundred and
fifty-five, again, I’m not expecting anyone to be able to <em>read</em> this). Btw, I’m using an underscore as a
spacer between numbers to help legibility, this also works in Rust, as does the <code>0b</code> notation!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let min_byte: u8 = 0b0000_0000;
let max_byte: u8 = 0b1111_1111;
println!("min_byte: {min_byte}"); // 0
println!("max_byte: {max_byte}"); // 255
<span class="boring">}</span></code></pre></pre>
<p>The reason why a byte is eight bits has a lot of history, but it basically comes down to character encoding: with 7
bits, you can represent 127 characters which covers english lowercase, uppercase, numbers 0-9, various whitespace and
punctuation, and still have 1 bit left over for simple error checking.</p>
<blockquote>
<p>As a total aside, as a software engineer, you’re very likely to also see number written in hexadecimal (base 16).
This is because hexadecimal, is really nice when working with bytes. One byte (8 bits) perfectly maps to two
hexadecimal digits. Hexadecimal digits go from 0 to 15, but are represented as 0-F (ie: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,
A, B, C, D, E, F).</p>
<p><code>0xF</code> is 15, and so is <code>0b1111</code>. The number 255 is much easier to write as <code>0xFF</code> than <code>0b1111_1111</code>. This <code>0x</code>
notation also works in Rust.</p>
</blockquote>
<h3 id="integers"><a class="header" href="#integers">Integers</a></h3>
<p>Now that you’ve had that primer on binary, I bet those 12 different integer types are starting to make a lot more sense!</p>
<p>The most basic number type in Rust is the <code>u8</code>. This is an <em>unsigned</em> integer (represented by the <code>u</code>) that is 8 bits in
length. Unsigned means that the number can only be positive (it does not have a negative sign). You might have already
guessed, but this is one byte, and can hold the numbers 0 to 255. A byte like this can be used for all sorts of things,
though one common example is as part of a color. We often represent colors as 8 bits of red, 8 bits of green,
8 bits of blue and sometimes 8 bits of transparency.</p>
<p><code>i8</code> is an integer that can represent both positive and negative numbers (i.e. it’s signed). It also only uses 8 bits
of data but in order to represent a number, however, instead of going from 0 to 255, it goes from -128 to 127.</p>
<p>You never need to know this, <em>but</em>, if you’re interested in the mathematics of how it does this, it uses a method called
<a href="https://en.wikipedia.org/wiki/Two%27s_complement" title="" target="_blank">two’s complement</a>.</p>
<p>This, however, is complicated, and we don’t think like computers. The easiest way to think about it is the left most
column is the negative version of itself, and all other numbers are the same. So, the number -125 can be represented as
<code>0b1000_0011</code>.</p>
<div class="table-wrapper"><table><thead><tr><th>Columns:</th><th>-128</th><th>64</th><th>32</th><th>16</th><th>8</th><th>4</th><th>2</th><th>1</th></tr></thead><tbody>
<tr><td>Count:</td><td>1</td><td>0</td><td>0</td><td>0</td><td>0</td><td>0</td><td>1</td><td>1</td></tr>
</tbody></table>
</div>
<p>ie, the number contains one -128, one 2 and one 1, adding (-128 + 2 + 1) them is -125.</p>
<p>So that’s <code>u8</code> and <code>i8</code>, and now you’ve probably guessed that for all the other integer types;</p>
<ul>
<li><code>u</code> means it can only be positive</li>
<li><code>i</code> means it can be positive or negative</li>
<li>the number after is how many bits are available to the number</li>
</ul>
<p>Now we can build up a little table to show the minimum and maximum of these types:</p>
<div class="table-wrapper"><table><thead><tr><th>type</th><th style="text-align: right">min</th><th style="text-align: right">max</th></tr></thead><tbody>
<tr><td>u8</td><td style="text-align: right">0</td><td style="text-align: right">255</td></tr>
<tr><td>i8</td><td style="text-align: right">-128</td><td style="text-align: right">127</td></tr>
<tr><td>u16</td><td style="text-align: right">0</td><td style="text-align: right">65,535</td></tr>
<tr><td>i16</td><td style="text-align: right">-32768</td><td style="text-align: right">32,767</td></tr>
<tr><td>u32</td><td style="text-align: right">0</td><td style="text-align: right">4,294,967,295</td></tr>
<tr><td>i32</td><td style="text-align: right">-2147483648</td><td style="text-align: right">2,147,483,647</td></tr>
<tr><td>u64</td><td style="text-align: right">0</td><td style="text-align: right">18,446,744,073,709,551,615</td></tr>
<tr><td>i64</td><td style="text-align: right">-9,223,372,036,854,775,808</td><td style="text-align: right">9,223,372,036,854,775,807</td></tr>
<tr><td>u128</td><td style="text-align: right">0</td><td style="text-align: right">340,282,366,920,938,463,463,374,607,431,768,211,455</td></tr>
<tr><td>i128</td><td style="text-align: right">-170,141,183,460,469,231,731,687,303,715,884,105,728</td><td style="text-align: right">170,141,183,460,469,231,731,687,303,715,884,105,727</td></tr>
</tbody></table>
</div>
<p>Wow, those numbers get big fast!</p>
<p>There’s still two types missing though; <code>usize</code> and <code>isize</code>.</p>
<p>In this case, the <code>size</code> is also acting as the number of bits, however, unlike the other integer types, the size of
<code>size</code> is variable.</p>
<p>Rust is a compiled language, meaning that the code you write in Rust is transformed into instructions that a CPU can
understand. CPUs are all different, but they typically follow some given “architecture”. For example, if you’re
reading this on a Windows or Linux desktop or an Intel Mac, the architecture of your CPU is <em>probably</em> <code>x86_64</code>. If
you’re reading this on an “Apple Silicon” Mac or a mobile phone, then the architecture is <em>probably</em> <code>arm64</code>.</p>
<blockquote>
<p>A quick aside, the world of CPU architecture is a bit of a mess so <code>x86_64</code> may also be referred to as <code>amd64</code> as AMD
were the designers of the architecture, but it was designed to be backwards compatible with Intel’s <code>x86</code>
architecture. Similarly <code>arm64</code> is also sometimes referred to as <code>AArch64</code>.</p>
</blockquote>
<p>When you compile Rust it will compile into an instruction set for the architecture your machine uses, though you can
also tell it what instruction set to compile for if you want to build it on one architecture but run it on another.</p>
<p><code>x86_64</code> and <code>arm64</code> are both 64bit architectures, so when you build for these machines, the <code>size</code> in <code>usize</code> and
<code>isize</code> becomes <code>64</code>. However, if you were to compile for, say, a Cortex-M0 chip, then the instruction set would likely
be <code>Thumb-1</code> which is 16bit so the <code>size</code> in <code>usize</code> and <code>isize</code> becomes <code>16</code>.</p>
<h4 id="which-integer-is-right-for-you"><a class="header" href="#which-integer-is-right-for-you">Which integer is right for you?</a></h4>
<p>You might think the obvious thing to do would be to use the largest possible number, for example, you can fit pretty
much every whole number you could possibly need into <code>i128</code>, so why use anything else?</p>
<p>There’s two things to think about, first, what is the intended use of the number and, second, what is the architecture
of the machine you’re running on?</p>
<p>In software engineering, a number is never just a number, it represents something. As we mentioned earlier,
colors are often (but not always), represented as 0 to 255 for each of red, green and blue. This means that a <code>u8</code> is
the best way to store these. If you combine those three colors with another 8 bits for transparency (alpha), then you
have four lots of <code>u8</code> which can be represented as a <code>u32</code>.</p>
<p><code>u8</code> is also a good size for representing a stream of unicode characters, which is where we get <code>UTF-8</code>, the default
encoding for Rust strings.</p>
<p>For larger numbers though, you still may not want to use the largest. While you can use integers that are wider than the
architecture that you’re running your program on, like using a <code>u128</code> ion a 64 bit machine, mathematics with those
numbers will be slower. The CPU can only process so many bits at once, so when it has numbers larger than that, it has
to do multiple rounds of processing to achieve the same results as it might have done if those numbers were stored in
smaller integers.</p>
<p>You might then think that the best thing to do is use a <code>usize</code> or <code>isize</code> if you don’t really care about how big a
number can get, and that’s fine, and I often do this, but now you have to bear in mind that the behaviour of your
program may no longer be consistent on different machines!</p>
<p>By default, when you write an integer and store it in a variable, Rust will play it safe and use an <code>i32</code> as it doesn’t
know what you might want to do with the number, an <code>i32</code> will fit inside most CPU architectures without needing extra
work and allows negative numbers.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 10; // i32
<span class="boring">}</span></code></pre></pre>
<p>However, it is more idiomatic to be intentional about the types you use. My methodology here is roughly:</p>
<ul>
<li>does this number represent something of a specific size like a color or ascii character, in which case, use that size</li>
<li>is this number going to be used to access an array, in which case it really ought to be a <code>usize</code></li>
<li>am I more worried about the number slowing the program down than I am about accidentally trying to store a big number
in a small integer, and do I not care about consistency, in which case <code>usize</code> or <code>isize</code></li>
<li>otherwise, if I’m ok potentially sacrificing speed, then an <code>i32</code> or <code>i64</code> is fine</li>
</ul>
<p>You can specify what type a number is either by annotating the variable you are putting it inside:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a: u64 = 10; // u64
<span class="boring">}</span></code></pre></pre>
<p>Or, if that’s not possible because you are, for example, passing the number to a function that could take many number
types, you can write the type at the end of a number:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::fmt::Display;
</span><span class="boring">
</span><span class="boring">fn print_value_and_type&lt;T: Display&gt;(v: T) {
</span><span class="boring">    let type_name = std::any::type_name::&lt;T&gt;();
</span><span class="boring">    println!("Type of '{v}' is {type_name}");
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>print_value_and_type(10u8); // u8
<span class="boring">}</span></code></pre></pre>
<h4 id="a-brief-note-on-type-conversion"><a class="header" href="#a-brief-note-on-type-conversion">A brief note on Type Conversion</a></h4>
<p>Finally, you can convert between types in several ways, which we’ll talk about more later, but I wanted to quickly go
over some code from the last chapter.</p>
<p>In the bonus section of the last chapter, we got the number of milliseconds that had passed since midnight on the 1st
of January 1970, and then immediately used <code>as usize</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let time = std::time::UNIX_EPOCH
    .elapsed()
    .expect("Call the Doctor, time went backwards")
    .as_millis() as usize; // We only need the least significant bits so this is safe
<span class="boring">}</span></code></pre></pre>
<p>The reason for this is the number of milliseconds since that date is approximately 1,710,000,000,000 and is
returned as a <code>u128</code>. We wanted to use this as part of a calculation to work out an index into an array. Indexes in
arrays are always <code>usize</code>. If you were to compile this program on a 32bit architecture, then the number of milliseconds
is greater than what would fit into a <code>usize</code> which would be a mere 4,294,967,295. When we use <code>as</code> it simply takes the
number, whatever it is and tries to cram it into the size <code>as &lt;type&gt;</code>.</p>
<p>When going from a larger size to a smaller size (in this case, from <code>u128</code> to the equivalent of <code>u32</code>) it simply cuts
off the front of the data, leaving the least significant bits. You can see this in the following program (don’t forget
you can run this in place with the play button):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let time = std::time::UNIX_EPOCH
    .elapsed()
    .expect("Call the Doctor, time went backwards")
    .as_millis();

let time_u32 = time as u32;

println!("Before conversion: {time}"); // approx: 1710771427971
println!("After conversion: {time_u32}"); // approx: 1374444163
<span class="boring">}</span></code></pre></pre>
<h3 id="floating-points"><a class="header" href="#floating-points">Floating Points</a></h3>
<p>We’ve covered twelve different ways of storing whole numbers in Rust, but there are only two ways of storing numbers
with decimal points: <code>f32</code> and <code>f64</code>.</p>
<p>Floating point numbers are things like <code>0.123</code> or <code>1.23</code> or even <code>123.0</code>. They’re called floating point because the
decimal point can move around (as opposed to fixed point, where there is always the same number of fractional digits).</p>
<p>Your immediate thought here might be that you should use <code>f32</code> on 32bit systems, and <code>f64</code> on 64bit systems, but
actually this isn’t the way to think about these numbers.</p>
<p>You see, floating points are not perfectly accurate. The bits of a floating point number are broken into parts:</p>
<ul>
<li>a sign (+/-)</li>
<li>an exponent</li>
<li>a fraction</li>
</ul>
<p>Without going into too much detail on floating points this gives us a way of expressing very large numbers and very
small numbers but not every number in between (after all, there are infinite numbers between 0.0 and 1.0).</p>
<p>Imagine using a floating point number to represent money. Someone comes into a store to buy a $520.04 item, and they
have a coupon for $520.02. The remainder that they need to pay is 2 cents, right? Try running the next bit of code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>println!("520.04 - 520.02 should be 0.02");

// Single Precision Floating Point
let float_32 = 520.04_f32 - 520.02_f32;
println!("But, using f32 it's: {float_32}");  // 0.019958496

// Double Precision Floating Point
let float_64 = 520.04_f64 - 520.02_f64;
println!("And, using f64 it's: {float_64}"); // 0.01999999999998181
<span class="boring">}</span></code></pre></pre>
<p>Instead, if the currency you’re representing uses “hundredths” for its minor currency like USD or GBP, then you can (and
maybe should) represent the total number of that, eg of cents for dollars or pennies for pounds, using integers instead.</p>
<p>When should you use floats?</p>
<p>Floating point numbers are great for more abstract mathematics where perfect precisions isn’t strictly necessary, for
example, vectors, matrices and quaternions which are often used in applications like video games and scientific models.</p>
<p>As to which you should use, you might think that it comes down to architecture again, for example, a program targeting
a 32bit architecture should use an <code>f32</code> and a 64bit architecture should prefer an <code>f64</code>… but if that’s the case,
where is the <code>fsize</code>?</p>
<p>Actually, 32bit architectures are usually designed to support 64bit floating point numbers just fine, the difference
between <code>f32</code> and <code>f64</code> is that regardless of architecture, <code>f32</code> is faster, and <code>f64</code> is more “fine grain”.</p>
<h3 id="characters"><a class="header" href="#characters">Characters</a></h3>
<p>In Rust, we have a special type that represents a single character called <code>char</code>. It is always 4 bytes (32bits) in size
and can be any valid “unicode scalar value” (which is to say, any character in unicode that’s not a control character).
In Rust a character is always written between single quotes, whereas string literals are always written between double
quotes.</p>
<p>You can use any valid unicode character whether that’s the upper or lowercase english letters A-Z, numbers 0-9, white
space characters, word characters from languages like Chinese and Japanese, emoji, or anything else that’s a “unicode
scalar value”.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let i = 'I';
let love = '💖';
let yuki = '雪';
println!("{i} {love} {yuki}"); // I 💖 雪
<span class="boring">}</span></code></pre></pre>
<p>We usually use characters in relation to finding things inside strings. You can also turn strings into a collection of
characters and vice versa, however its important to note that a character inside a string may not take up 4 bytes (for
example, english letters and numbers only take 1 byte), however, once turned into a character, it will take up four
bytes.</p>
<h3 id="boolean"><a class="header" href="#boolean">Boolean</a></h3>
<p>There is only one boolean type in Rust: <code>bool</code>. It represents <code>true</code> or <code>false</code>.</p>
<blockquote>
<p>Useless (but interesting!) information: In terms of how much space it uses, Rust considers it to be a single bit (an
i1) <em>however</em> LLVM, which is a tool Rust uses as an intermediate compilation step, will use a full byte, though the
value inside the byte will still be 0 for false and 1 for true.</p>
<p>Weirdly, if Rust got its way, the decimal value for a boolean as its stored in memory would be 0 for false and -1 for
true (remember in <code>i</code> numbers, the left most bit is its negative self). None of that matters, its just interesting 😅</p>
</blockquote>
<p>Boolean values are usually reserved for <code>if</code> statements, and this is a good thing to look out for as finding it else
where <em>might</em> be a sign that the code isn’t written in the best way.</p>
<h3 id="string-slices"><a class="header" href="#string-slices">String slices</a></h3>
<p>Our old friend the string slice!</p>
<p>The type for a string slice is <code>str</code>, but you’ll never see anything with the <code>str</code> type, you will usually see this
as a reference to a string slice <code>&amp;str</code>, which makes it unique amongst the primitive types.</p>
<p><code>str</code> should always be a UTF-8 string (see ⚠️ below), which means that the length of a string in bytes may not
necessarily be the same as its length in characters.</p>
<p>For example (don’t worry about the code yet):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let yuki = "雪";

let byte_length = yuki.len();
println!("{yuki} length in bytes: {byte_length}"); // 3

let char_length = yuki.chars().count();
println!("{yuki} length in characters: {char_length}"); // 1
<span class="boring">}</span></code></pre></pre>
<p>Its also worth remembering that when you turn a string into characters, each of those characters will take up 4 bytes
of memory, even though inside the string they might have only taken up one byte (again, don’t worry about the code in
the next example we’ll talk about it soon):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::mem::size_of_val;
</span><span class="boring">
</span>let hello = "hello";

let string_size = size_of_val(hello);
println!("Size as string slice: {string_size} bytes"); // 5

// Convert the string slice to chars, get the size of each char, and sum them
let  char_size: usize = hello.chars().map(|c| size_of_val(&amp;c)).sum();
println!("Size as characters: {char_size} bytes"); // 20
<span class="boring">}</span></code></pre></pre>
<p>The size of a string slice depends on what’s in it, which is why you won’t see it on the stack (string slices live in
either the compiled output as string literals, or on the Heap inside a String). A string slice reference is made up of
two pieces of data, a pointer to where the string slice starts, and a length, both of which are of known size but depend
on the system architecture.</p>
<p>Fun fact about that reference though: you might wonder if it’s just a pointer and a length, does that mean you can
have a reference to a string slice that exists inside a string slice, and the answer is: yes! Just be careful when
taking a slice inside a slice to make sure that the sub slice is a valid UTF-8 string.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello = "hello";
// hell is a reference to a substring, range 0..4 is exclusive so 0, 1, 2, 3 but not 4
let hell = &amp;hello[0..4]; 
println!("{hell}"); // hell
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>⚠️ It is <em>possible</em> to create a string slice that is not a valid UTF-8 string so you should be mindful that this isn’t
a guarantee, but you also shouldn’t make the effort to check the validity everywhere its used. It <em>should</em> be a UTF-8
string, but if you are constructing your own from raw data, or if there are security implications to the use of a
string slice, you should be careful.</p>
</blockquote>
<h2 id="compound-types"><a class="header" href="#compound-types">Compound Types</a></h2>
<h3 id="arrays"><a class="header" href="#arrays">Arrays</a></h3>
<p>Arrays are a collection of a single type. You might see arrays in two forms, either as a sized array on the stack, or
as a reference to another collection (also called an array slice).</p>
<p>When sized, arrays are annotated with the type <code>[T; N]</code> where <code>T</code> is the type of every item in the array and <code>N</code> is its
size. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello: [char; 5] = ['H', 'e', 'l', 'l', 'o'];
<span class="boring">}</span></code></pre></pre>
<p>When referenced as an array slice, you do not need to specify the size because, just like with references to string
slices, the reference not only contains a pointer to the underlying data, but also contains the size. We write this in
the form <code>&amp;[T]</code> where <code>T</code> is the type of every item in the array.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let hello: [char; 5] = ['H', 'e', 'l', 'l', 'o'];
</span>// hell is a reference to a sub-array, range 0..=3 is inclusive so 0, 1, 2, and 3
let hell: &amp;[char] = &amp;hello[0..=3];

// This is another way of printing variables with debug that we haven't covered yet 
print!("{:?}", hell); // ['H', 'e', 'l', 'l']
<span class="boring">}</span></code></pre></pre>
<p>You can access elements inside the array directly by using an index value between square brackets. In Rust, indexing
starts at 0. So:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let hello: [char; 5] = ['H', 'e', 'l', 'l', 'o'];
let h = hello[0]; // H
let e = hello[1]; // e 
let l = hello[2]; // l 
<span class="boring">}</span></code></pre></pre>
<h3 id="tuples"><a class="header" href="#tuples">Tuples</a></h3>
<p>Tuples are similar to arrays in that they are a collection of items, however each item in the collection can be a
different type. This adds some flexibility but also some restrictions. For example, you can iterate over each item in
an array, but not a tuple.</p>
<p>Tuples are written between brackets, and are only considered the same type if the types inside the tuple match.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let char_int_1: (char, i32) = ('a', 1);
let char_int_2: (char, i32) = ('b', 2); // This type is the same as the previous one.
let int_char_1: (i32, char) = (3, 'c'); // This type is different 
<span class="boring">}</span></code></pre></pre>
<p>Another difference from arrays is how you access a single item in the tuple, which you do with a dot <code>.</code>, followed by
the number element you want. Again, this starts from 0.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let char_int: (char, i32) = ('a', 1);
let a = char_int.0; // 'a'
let one = char_int.1; // 1
<span class="boring">}</span></code></pre></pre>
<h4 id="the-unit-type"><a class="header" href="#the-unit-type">The Unit Type</a></h4>
<p>The Unit Type is a zero length tuple <code>()</code> that is Rust’s way to represent nothing. It is zero bytes, does not exist on
the stack at runtime, and unlike other languages with types like <code>null</code> or <code>void</code>, can not be used interchangeably with
other types.</p>
<p>You might use this type in conjunction with generics which we’ll come to in a bit.</p>
<h3 id="structs"><a class="header" href="#structs">Structs</a></h3>
<p>Structs are similar to tuples in that they are a type made up of other types. Unlike tuples they are named though. There
are three types of structs, structs with named fields, tuple structs and unit structs.</p>
<blockquote>
<p><strong>Note:</strong> types like structs and enums must be declared outside of functions.</p>
</blockquote>
<h4 id="tuple-struct"><a class="header" href="#tuple-struct">Tuple Struct</a></h4>
<p>As we just covered tuples, lets quickly talk about tuple structs. They look a bit like they’re simply “named” tuples,
and indeed they can be accessed the same way:</p>
<pre><pre class="playground"><code class="language-rust">struct Vector3(f64, f64, f64);

fn main() {
    let vec = Vector3(10.0, 2.0, 3.33);
    let ten = vec.0; // 10.0
    let two = vec.1; // 2.0
}</code></pre></pre>
<p>Similar to tuples, this kind of struct can be accessed with a <code>.</code> and a numbered value, <em>however</em> unlike tuples,
structs have a concept of “visibility”. Unless explicitly marked as public the fields of a struct are only accessible
in the module in which it is defined, or its descendents. We’ll talk more about modules later, however, to make the
fields of a struct public, you can simply mark them as <code>pub</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Vector3(pub f64, pub f64, pub f64);
<span class="boring">}</span></code></pre></pre>
<p>You don’t have to make every field public though, if you’d some parts of the struct to be public and others to be
private.</p>
<h4 id="named-fields"><a class="header" href="#named-fields">Named Fields</a></h4>
<p>Named fields work pretty much the same as tuple structs except instead of having a numbered field, its named. You
can access the named field with a <code>.</code> and the name.</p>
<pre><pre class="playground"><code class="language-rust">struct Cell {
    x: u64,
    y: u64,
    alive: bool,
}

fn main() {
    let cell = Cell {
        x: 10,
        y: 123,
        alive: true,
    };

    let is_alive = cell.alive; // true
}</code></pre></pre>
<h4 id="unit-structs"><a class="header" href="#unit-structs">Unit Structs</a></h4>
<p>Unit structs are an interesting case that you probably won’t find much use for until we get into more advanced Rust and
some of the cooler patterns and idioms that we use. A Unit struct has no value, it only represents a type.</p>
<pre><pre class="playground"><code class="language-rust">struct ExampleUnitStruct;

fn main() {
    let unit_struct = ExampleUnitStruct;
}</code></pre></pre>
<p>Unit Structs have zero size and don’t exist on the stack at runtime, but they can have functionality added to them
through Traits, or be used as markers.</p>
<h3 id="enums"><a class="header" href="#enums">Enums</a></h3>
<p>Enums are for when you want to represent one of a finite number of possible values. For example</p>
<pre><pre class="playground"><code class="language-rust">enum TrafficLightState {
    Red,
    Amber,
    Green,
}

fn main() {
    let green = TrafficLightState::Green;
    // let purple = TrafficLightState::Purple; // Won't compile
}</code></pre></pre>
<p>Many programing languages have this concept of enums, but what makes Rust enums especially awesome is that the variants
can additionally contain values. We’ve already talked about two such enums <code>Option</code> and <code>Result</code> which are two of the
most important and widely used types in the entire ecosystem, and we’ll talk more about them in the Generic Types
section below. As an example though, enums variants can be structured in either a tuple stype or a struct style:</p>
<pre><pre class="playground"><code class="language-rust">enum ContrivedEnum {
    SimpleVariantNoData,
    TupleStyleData(u64, i32),
    NamedFields {
        time: i128,
        place: String,
    }
}

fn main() {
    let simple_variant = ContrivedEnum::SimpleVariantNoData;
    let tuple_style = ContrivedEnum::TupleStyleData(10, -20);
    let named_fields = ContrivedEnum::NamedFields {
        time: 1_710_000_000_000,
        place: "Here".to_string(),
    };
}</code></pre></pre>
<p>In terms of memory usage, on the stack an enum will take up as much space as its largest variant, regardless of which
variant it actually is.</p>
<h2 id="generic-types"><a class="header" href="#generic-types">Generic Types</a></h2>
<p>Generics in Rust allow the creation of entirely new types at compile time by combining types together. We’ve talked
a bit about Option and how Rust uses it to represent Some value or None. Option is an enum with two variants, it is
literally just this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Option&lt;T&gt; {
    None,
    Some(T),
}
<span class="boring">}</span></code></pre></pre>
<p>Note that after the name of the enum we have <code>&lt;T&gt;</code>. The triangle brackets express that this enum has a type (or types)
that can be decided later, the <code>T</code> is a marker for that type. For example, say we want to create a type that represents
either a single character, or nothing.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// The type of possible_character is inferred to be Option&lt;char&gt;
let possible_character = Some('r');

// The type of no_character can not be inferred, but you can annotate it yourself
let no_character: Option&lt;char&gt; = None;
<span class="boring">}</span></code></pre></pre>
<p>Normally when accessing the variants of an enum, you must use the name followed by the variant (eg <code>Option::Some('r')</code>),
however Option and Result are so ubiquitous that their variants are globally accessible in any rust code.</p>
<p>Another generic we’ve covered before is Result which usually represents either the success or failure of a function. It
has two types that can be decided later <code>T</code>, which should represent what type of data you expected to get back, and <code>E</code>,
which will be the type of the Error.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>enum Result&lt;T, E&gt; {
    Ok(T),
    Err(E),
}
<span class="boring">}</span></code></pre></pre>
<p>We’ll talk more about functions in the next chapter, but in order to explain Result in context, the following example
shows the fully described Result type as the return type of the function, which is how we’d typically use this enum,
though, you wouldn’t typically use a String as an Error type, and we’ll talk more about that when we get to Error
handling later.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn function_that_fails_half_the_time() -&gt; Result&lt;u128, String&gt; { // Note the return type for a function comes after -&gt;
    let time = std::time::UNIX_EPOCH
        .elapsed()
        .expect("Call the Doctor, time went backwards") // We can do something cooler here but that's for another time
        .as_millis();

    if time % 2 == 0 {
        Ok(time) // implicit return
    } else {
        Err("The function failed".to_string()) // implicit return
    }
} 
<span class="boring">}</span></code></pre></pre>
<p>When we start talking about adding functionality to types in the functions chapter, we’ll also talk about how you can
restrict what types are allowed to be used in generics through the use of trait bounds.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>That is (almost) everything you need to know about types! The main thing we’re still missing is ownership, but we’ll
come to that later. The main things to remember are:</p>
<ul>
<li>We have our primitive types that represent binary data. There’s a lot of choice here, but that’s a good thing!</li>
<li>We can represent more complex types with compound types, each with its own use</li>
<li>We can “fill in the blank” with compound types later using generics</li>
<li>We talked a bit about two of the most common generics, Option (representing something or nothing) and Result
(representing a successful value or an error)</li>
</ul>
<p>In the next chapter we’re going to talk about controlling the flow of our program with branches and loops as well as
pattern matching which and expressions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h1>
<p>Programs are typically executed one line at a time (this is called flow), but we can alter what the next line is with
control flow.</p>
<p>There are two main ways of doing this <a href="language-basics/control-flow.html#branching">branching</a> and <a href="language-basics/control-flow.html#looping">looping</a>.</p>
<p>Before we do that though, lets talk about two of Rusts coolest features, which will come up a lot later,
<a href="language-basics/control-flow.html#patterns">patterns</a> and how <a href="language-basics/control-flow.html#blocks-are-expressions">blocks are also expressions</a>.</p>
<h2 id="patterns"><a class="header" href="#patterns">Patterns</a></h2>
<p>In the last chapter we talked about compound types. Tuples, Structs, and Enums allow the construction of more complex
data from less complex data. However, if we want to extract any of the component parts of that data we can do that!</p>
<p>Patterns can be used to “destructure” compound data types like tuples fairly trivially:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let point = (123, 456);
let (x, y) = point;
println!("The point was at x: {x} and y: {y}");
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>It’s important to note though, that the original data will no longer be accessible if it doesn’t implement <code>Copy</code>:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// This code won't compile!
let point = (123.to_string(), 456.to_string());
let (x, y) = point;
let this_wont_work = point.0;
<span class="boring">println!("using these variable to remove irrelevant warnings {x}, {y}, {this_wont_work}");
</span><span class="boring">}</span></code></pre></pre>
<p>We’ll talk more about copy, ownership and move semantics later in the book.</p>
</blockquote>
<p>Destructuring with patterns also works for Tuple Structs, however, you need to specify the name of the struct like
you’re doing a weird backwards struct instantiation.</p>
<pre><pre class="playground"><code class="language-rust">struct Point (u64, u64);

fn main() {
    let point = Point(123, 456);
    
    let Point(x, y) = point;
    
    println!("The point was at x: {x} and y: {y}");
}</code></pre></pre>
<p>The same thing also works for Structs with Named Fields:</p>
<pre><pre class="playground"><code class="language-rust">struct Point {
    x: u64,
    y: u64,
}

fn main() {
    let point = Point { x: 123, y: 456 };
    
    let Point { x, y } = point;
    
    println!("The point was at x: {x} and y: {y}");
}</code></pre></pre>
<p>In the above example we extract the structs named fields straight into variables of the same name as its easy and the
names were appropriate. However, it might be better in the context of your program to name them something else. Below
we’ve renamed <code>x</code> to <code>width</code> and <code>y</code> to <code>height</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">struct Point {
</span><span class="boring">   x: u64,
</span><span class="boring">   y: u64,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">   let rect = Point { x: 123, y: 456 };
</span><span class="boring">
</span>let Point { x: width, y: height } = rect;

println!("The rect was {width} wide and {height} high");
<span class="boring">}</span></code></pre></pre>
<p>Unfortunately, you can not extract data from Enums this way as the value of an Enum is one of a set of, not only values,
but potentially subtypes or shapes or however you’d like to describe them. Take for example the humble Options:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let maybe_yuki: Option&lt;char&gt; = Some('雪');
let maybe_not: Option&lt;char&gt; = None;
<span class="boring">}</span></code></pre></pre>
<p>How can we extract a <code>char</code> from <code>Option&lt;char&gt;</code> if we don’t know whether the variable is <code>Some</code> or <code>None</code>… well,
actually, we’ll come to that soon. 🙂</p>
<h2 id="blocks-are-expressions"><a class="header" href="#blocks-are-expressions">Blocks are Expressions</a></h2>
<p>Before we get too deep into Rusts control flow I want to show you one of Rusts coolest features, expressions.</p>
<p>An expression in Rust is anything that could have a value. So, for example, <code>a + b</code> is an expression where we’re adding
<code>a</code> to <code>b</code> which results in a value. You will also use expressions like <code>a == b</code> to compare whether the values of <code>a</code>
and <code>b</code> are the same, this results in a value of <code>true</code> or <code>false</code>.</p>
<p>Usually you might use an expression as part of an assignment or an evaluation, for example <code>let c = a + b</code> or
<code>if a == b { ... }</code>, however, Rust also allows you to use a block (code between <code>{</code> and <code>}</code>) as an expression <em>and</em> the
final value of that block can itself be an expression.</p>
<p>Here’s a very contrived example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let c = {
    let a = 3;
    let b = 5;
    a + b
};
println!("{c}");
<span class="boring">}</span></code></pre></pre>
<p>Some cool things to note:</p>
<ul>
<li><code>a</code> and <code>b</code> only exist within the code block</li>
<li>the lines with <code>let</code> have semicolons</li>
<li>the line with the expression <code>a + b</code> does not</li>
<li><code>c</code> will be equal to the evaluation of the code block, which itself is equal to the result of <code>a + b</code></li>
<li>the code block which <code>c</code> is equal to is also terminated with an exclamation</li>
</ul>
<p>Why is this so cool? Because branches, loops and even functions all use code blocks!</p>
<h2 id="branching"><a class="header" href="#branching">Branching</a></h2>
<h3 id="if"><a class="header" href="#if">If</a></h3>
<p>The most basic form of branching is the <code>if</code> statement.</p>
<p>In its most simple form it’s an <code>if</code> followed by an expression (unlike many languages this does not need to be in
brackets) followed by a code block. The expression must evaluate to a boolean, either <code>true</code> or <code>false</code>. If the
expression evaluates to <code>true</code>, then the code in the block will be run, otherwise it won’t be:</p>
<pre><code class="language-text">if &lt;expression&gt; {
    &lt;code to run if expression is true&gt;
}
</code></pre>
<p>For example, we could create an expression that evaluates to a boolean by comparing if two numbers are the same, using
double equals:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 1;
let b = 1;
    
if a == b {
    println!("if expression is true print this");
}
println!("regardless of whether expression was true print this");
<span class="boring">}</span></code></pre></pre>
<p>If you want to run some code if the expression is <code>true</code>, but some different code if its <code>false</code>, then you can extend
<code>if</code> with <code>else</code>. Here we compare if the first number is greater than the second number.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 1;
let b = 1;
    
if a &gt; b {
    println!("if expression is true print this");
} else {
    println!("if expression is false print this instead");
}
<span class="boring">}</span></code></pre></pre>
<p>You can chain <code>if</code>/<code>else</code> statements to create more complex branches.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 1;
let b = 1;
    
if a &gt; b {
    println!("a is greater than b");
} else if a == b {
    println!("a is equal to b");
} else {
    println!("a must be less than b");
}
<span class="boring">}</span></code></pre></pre>
<p>Remember though, code blocks, including those in <code>if</code> and <code>else</code> are themselves expressions. This means they can
effectively return their own values</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let a = 1;
let b = 1;
    
let message = if a &gt; b {
    "a is greater than b".to_string() 
} else if a == b {
    "a is equal to b".to_string()
} else {
    "a must be less than b".to_string()
};
    
println!("{message}");
<span class="boring">}</span></code></pre></pre>
<p>Some important things to note:</p>
<ol>
<li>The last line of each code block has no semicolon</li>
<li>When we create expressions like this, we must terminate them with a semicolon (see after the final <code>}</code>)</li>
<li>All branches must evaluate to the same <em>Type</em>, even if they don’t evaluate to the same <em>value</em></li>
<li>Doing big blocks of <code>if</code>/<code>else if</code>/<code>else</code> is a mess, there’s a <a href="language-basics/control-flow.html#match">better way</a>!</li>
</ol>
<h4 id="pattern-matching-inside-if-and-else"><a class="header" href="#pattern-matching-inside-if-and-else">Pattern Matching inside <code>if</code> and <code>else</code></a></h4>
<p>There is another way you can branch with <code>if</code> that doesn’t require a boolean expression, pattern matching.</p>
<p>There are two ways to do this <code>if let ...</code> and <code>let ... else</code>.</p>
<p>Let’s go back to that Option from earlier:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let maybe_yuki: Option&lt;char&gt; = Some('雪');
let maybe_not: Option&lt;char&gt; = None;
    
if let Some(c) = maybe_yuki {
    // This line will be printed
    println!("The character was '{}'", c);
}
    
if let Some(c) = maybe_not {
    // This line will not
    println!("The character was '{}'", c);
}
<span class="boring">}</span></code></pre></pre>
<p>In the line <code>if let Some(c) = maybe_yuki</code> we are pattern matching on the Option, if it matches the pattern of
<code>Some(&lt;variable&gt;)</code>, then we extract the contents of the <code>Some</code> into the <code>&lt;variable&gt;</code>. Within the block (and only within
the block), the variable <code>c</code> has the value from inside the <code>Some</code> variant of the <code>Option</code>.</p>
<p>This may be easier to observe with our own enum type. Imagine the following:</p>
<pre><pre class="playground"><code class="language-rust">enum Vector {
    Two(f32, f32),
    Three(f32, f32, f32),
}

fn main() {
    let v = Vector::Three(3.0, 4.0, 5.0);
    
    if let Vector::Two(x, y) = v {
        // This line will not be printed
        println!("The 2D vector has the magnitude '{}'", (x*x + y*y).sqrt());
    }
    
    if let Vector::Three(x, y, z) = v {
        // This line will
        println!("The 3D vector has the magnitude '{}'", (x*x + y*y + z*z).sqrt());
    }
}</code></pre></pre>
<p>This example is a little contrived, there are better ways to do this.</p>
<p>You can also do the opposite, branch if the pattern does not match, using <code>let ... else</code>. The important thing to note
here is that execution can not continue after the code block, you must exit the current flow, whether thats returning
from a function or breaking from a loop</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn some_function() {
    let maybe_yuki: Option&lt;char&gt; = Some('雪');
        
    let Some(c) = maybe_yuki else {
        // This code is executed if the maybe_yuki was None
        // We must exit from the code here, as we can not go back to the normal execution
        return;
    };
    // From this point forward, the contents of the Option has been extracted into the variable `c`
    println!("The character was '{}'", c);
}
<span class="boring">some_function();
</span><span class="boring">}</span></code></pre></pre>
<h3 id="match"><a class="header" href="#match">Match</a></h3>
<p>This pattern matching stuff is really handy, right?!</p>
<p>Well the creators of Rust thought so too, in fact, they made a whole control flow mechanism around it!</p>
<p><code>match</code> is a bit like <code>if</code> in that it can branch, and act as an expression. However, <code>match</code> can do a lot more than
<code>if</code>, it will match against multiple possibilities, allows match guards for fine grain control of pattern matching, and
its exhaustive, meaning that a match <em>must</em> deal with every possibility.</p>
<p>Lets look at our Vector example again:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">enum Vector {
</span><span class="boring">    Two(f32, f32),
</span><span class="boring">    Three(f32, f32, f32),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>let v = Vector::Three(3.0, 4.0, 5.0);

match v {
    Vector::Two(x, y) =&gt; println!("The 2D vector has magnitude '{}'", (x*x + y*y).sqrt()),
    Vector::Three(x, y, z) =&gt; println!("The 3D vector has magnitude '{}'", (x*x + y*y + z*z).sqrt()),
}
<span class="boring">}</span></code></pre></pre>
<p>First of all, you can see that this pattern is <em>much</em> cleaner than having a lot of <code>if let</code>s. We’re matching against
the variants of an enum, and can immediately extract the contents from each variant. We could also use match as an
expression:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">enum Vector {
</span><span class="boring">    Two(f32, f32),
</span><span class="boring">    Three(f32, f32, f32),
</span><span class="boring">}
</span><span class="boring">
</span>let v = Vector::Three(3.0, 4.0, 5.0);
    
let magnitude = match v {
    Vector::Two(x, y) =&gt; (x*x + y*y).sqrt(),
    Vector::Three(x, y, z) =&gt; (x*x + y*y + z*z).sqrt(),
};

println!("The vector has the magnitude '{}'", magnitude);
<span class="boring">}</span></code></pre></pre>
<p>(This gets even more exciting when we get into functions)</p>
<p>What happens if we add another variant to the enum though? Well, that <code>match</code> statement will see that not every case is
handled, and cause an error.</p>
<pre><pre class="playground"><code class="language-rust compile_fail">enum Vector {
    Two(f32, f32),
    Three(f32, f32, f32),
    Four(f32, f32, f32, f32),
}

fn main() {
    let v = Vector::Three(3.0, 4.0, 5.0);
    
    // This match will no longer compile
    let magnitude = match v {
        Vector::Two(x, y) =&gt; (x*x + y*y).sqrt(),
        Vector::Three(x, y, z) =&gt; (x*x + y*y + z*z).sqrt(),
    };

    println!("The vector has the magnitude '{}'", magnitude);
}</code></pre></pre>
<p>We can deal with this by either adding the missing case, or using <code>_</code>, which is a special variable that immediately
discards whatever is put into it and will match anything.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">enum Vector {
</span><span class="boring">   Two(f32, f32),
</span><span class="boring">   Three(f32, f32, f32),
</span><span class="boring">   Four(f32, f32, f32, f32),
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">let v = Vector::Three(3.0, 4.0, 5.0);
</span><span class="boring">
</span>let magnitude = match v {
    Vector::Two(x, y) =&gt; (x*x + y*y).sqrt(),
    Vector::Three(x, y, z) =&gt; (x*x + y*y + z*z).sqrt(),
    // This specific example isn't great, now any variant that doesn't match will return zero, an error might be better
    _ =&gt; 0.0,
};
<span class="boring">println!("The vector has the magnitude '{}'", magnitude);
</span><span class="boring">}</span></code></pre></pre>
<p>Patterns on match arms are tested from top to bottom, and you can also match on more specific patterns, like values:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">enum Vector {
</span><span class="boring">    Two(f32, f32),
</span><span class="boring">    Three(f32, f32, f32),
</span><span class="boring">}
</span><span class="boring">
</span>let v = Vector::Two(0.0, 0.0);

let magnitude = match v {
    // This arm will match, print the statement and return 0
    Vector::Two(0.0, y) =&gt;  {
        println!("Hey, did you know that x was zero?");
        y
    },
    // Although `v` does match this arm, because we already matched on the previous arm, this block won't be run
    Vector::Two(x, 0.0) =&gt; {
        println!("Hey, did you know that y was zero?");
        x
    }
    // Nor will this one
    Vector::Two(x, y) =&gt; (x*x + y*y).sqrt(),
    Vector::Three(x, y, z) =&gt; (x*x + y*y + z*z).sqrt(),
};
<span class="boring">   println!("The vector has the magnitude '{}'", magnitude);
</span><span class="boring">}</span></code></pre></pre>
<p>There’s one more trick up <code>match</code>’s sleeve which is match guards. Say we want to do something similar to the above, but
instead of matching on exactly zero, we want to match on values less than 10. We could make an arm for every variant, or
we could use a match guard which is like a mini if statement:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">enum Vector {
</span><span class="boring">   Two(f32, f32),
</span><span class="boring">   Three(f32, f32, f32),
</span><span class="boring">}
</span><span class="boring">
</span>let v = Vector::Two(0.0, 0.0);

let magnitude = match v {
    // This arm will match, print the statement and return 0
    Vector::Two(x, y) if x &lt; 10.0 =&gt;  {
        println!("Hey, did you know that x was small?");
        (x*x + y*y).sqrt()
    },
    // Although `v` does match this arm, because we already matched on the previous arm, this block won't be run
    Vector::Two(x, y)  if y &lt; 10.0  =&gt; {
        println!("Hey, did you know that y was small?");
        (x*x + y*y).sqrt()
    }
    // Nor will this one
    Vector::Two(x, y) =&gt; (x*x + y*y).sqrt(),
    Vector::Three(x, y, z) =&gt; (x*x + y*y + z*z).sqrt(),
};
<span class="boring">   println!("The vector has the magnitude '{}'", magnitude);
</span><span class="boring">}</span></code></pre></pre>
<h2 id="looping"><a class="header" href="#looping">Looping</a></h2>
<h3 id="loop"><a class="header" href="#loop">Loop</a></h3>
<p>The most basic loop is, well, <code>loop</code>.</p>
<p>When you enter a loop, the code inside it will run until its explicitly told to stop. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">let mut protect_the_loop: u8 = 0;
</span>loop {
    println!("These lines will print out forever");
    println!("Unless the program is interrupted, eg, with Ctrl + C");
<span class="boring">    protect_the_loop = protect_the_loop + 1;
</span><span class="boring">    if protect_the_loop &gt;= 10 {
</span><span class="boring">        println!("I hid a break in this code as you can't Ctrl + C if you run this on Rust Playground / via the book");
</span><span class="boring">        break;
</span><span class="boring">    } 
</span>}
<span class="boring">}</span></code></pre></pre>
<p>This might seem a little bit unhelpful, surely you never want to get trapped inside a loop forever, but actually, we
often want to keep a program running inside a loop.</p>
<p>You can manually exit the loop using the <code>break</code> keyword. Like other languages, you can simply break from a loop, but
remember that blocks can be expressions, and this applies to loops too! That means we can have a loop that does some
work, and once the work is done, break with the value we want to take from the loop.</p>
<p>In the example below, we run a loop until we find some cool number (note the use of <code>if let</code>), then break with that
value. The Type of found is an <code>u64</code> (don’t forget you can expand the code in the example if you’re curious), and by
breaking with that value, the Type of the whole loop becomes <code>u64</code> too!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::time::*;
</span><span class="boring">use std::thread::*;
</span><span class="boring">fn prep() {
</span><span class="boring">    loop {    
</span><span class="boring">        let secs = UNIX_EPOCH
</span><span class="boring">            .elapsed()
</span><span class="boring">            .expect("Call the Doctor, time went backwards")
</span><span class="boring">            .as_secs();
</span><span class="boring">        if secs % 2 == 1 {
</span><span class="boring">            break;
</span><span class="boring">        } 
</span><span class="boring">        sleep(Duration::from_millis(100));
</span><span class="boring">    }   
</span><span class="boring">}
</span><span class="boring">fn find_a_cool_number() -&gt; Option&lt;u64&gt; {
</span><span class="boring">    let secs = UNIX_EPOCH
</span><span class="boring">        .elapsed()
</span><span class="boring">        .expect("Call the Doctor, time went backwards")
</span><span class="boring">        .as_secs();
</span><span class="boring">    (secs % 2 == 0).then_some(secs / 2)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>let some_cool_number = loop {
    println!("Looking for a cool number...");

    if let Some(found) = find_a_cool_number() {
        break found;
    }
<span class="boring">   sleep(Duration::from_millis(100));
</span>};

println!("The number we found was {some_cool_number}");
<span class="boring">}</span></code></pre></pre>
<p>Another useful keyword when looping is <code>continue</code>. Imagine you have a series of things that need to be processed but
you can skip over <em>some</em> of those things.</p>
<p>The following example will continuously get images, and run a time-consuming <code>process_image</code> function, unless the image
is an SVG, in which can it will skip it.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">use std::{
</span><span class="boring">    io::{stdout, Write},
</span><span class="boring">    thread::sleep,
</span><span class="boring">    time::{Duration, UNIX_EPOCH}
</span><span class="boring">};
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mut protect_the_loop: u8 = 0;
</span>loop {
    let image = get_image();
    if image.is_svg {
        println!("Skipping SVG");
        continue;
    }
    process_image(image);
<span class="boring">
</span><span class="boring">        protect_the_loop = protect_the_loop + 1;
</span><span class="boring">        if protect_the_loop &gt;= 10 {
</span><span class="boring">            println!("Protecting the loop again, this is only for demo purposes");
</span><span class="boring">            break;
</span><span class="boring">        }
</span>}
<span class="boring">}
</span><span class="boring">
</span><span class="boring">
</span><span class="boring">struct Image {
</span><span class="boring">    is_svg: bool,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn get_image() -&gt; Image {
</span><span class="boring">    let micros = UNIX_EPOCH
</span><span class="boring">        .elapsed()
</span><span class="boring">        .expect("Call the Doctor, time went backwards")
</span><span class="boring">        .as_micros();
</span><span class="boring">    Image {
</span><span class="boring">        is_svg: micros % 3 == 0,
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn process_image(_image: Image) {
</span><span class="boring">    println!("Processing Image, please wait... done");
</span><span class="boring">}</span></code></pre></pre>
<p>There’s one more neat trick up Rust’s sleeve. As with most languages, Rust of course supports nested loops, but to aid
with things like <code>break</code> and <code>continue</code> it also supports labels.</p>
<p>Labels start with a single quote <code>'</code> and mark the loop they are for with a colon.</p>
<p>This very contrived example steps through a set of instructions. See if you can guess what will happen (see below
for the answer).</p>
<pre><pre class="playground"><code class="language-rust">enum LoopInstructions {
    DoNothing,
    ContinueInner,
    ContinueOuter,
    BreakInner,
    BreakOuter,
}

fn main() {
    let sequence = [
        LoopInstructions::DoNothing,
        LoopInstructions::ContinueInner,
        LoopInstructions::ContinueOuter,
        LoopInstructions::BreakInner,
        LoopInstructions::BreakOuter
    ];

    // This lets us get one bit of the sequence at a time
    // Don't worry too much about it for now!
    let mut iter = sequence.iter();

    'outer: loop {
        println!("Start outer");
        'inner: loop {
            println!("Start inner");

            match iter.next() {
                Some(LoopInstructions::ContinueInner) =&gt; continue 'inner,
                Some(LoopInstructions::ContinueOuter) =&gt; continue 'outer,
                Some(LoopInstructions::BreakInner) =&gt; break 'inner,
                Some(LoopInstructions::BreakOuter) =&gt; break 'outer,
                _ =&gt; {}
            }

            println!("End inner");
        }
        println!("End outer");
    }
}</code></pre></pre>
<ol>
<li>The outer loop starts so we get <strong>“Start outer”</strong></li>
<li>We enter the inner loop so we see <strong>“Start inner”</strong></li>
<li>The <strong>first</strong> instruction <code>DoNothing</code> is read, it matches the last arm which does nothing so we continue</li>
<li>After the match we hit <strong>“End inner”</strong></li>
<li>The inner loop starts again so we get <strong>“Start inner”</strong></li>
<li>The <strong>second</strong> instruction <code>ContinueInner</code> matches, we execute <code>contine 'inner</code> so we start the inner loop again</li>
<li>We’ve started the inner loop again due to the previous instruction and get <strong>“Start inner”</strong></li>
<li>The third instruction <code>ContinueOuter</code> matches, we execute <code>continue 'outer</code> so go to the beginning of that loop</li>
<li>We’re back at the start so we see <strong>“Start outer”</strong></li>
<li>And re-enter the inner loop <strong>“Start inner”</strong></li>
<li>The <strong>fourth</strong> instruction is <code>BreakInner</code> so we execute <code>break 'inner</code>, when exits the inner loop</li>
<li>We exit the inner loop and continue from that point so we finally see <strong>“End outer”</strong></li>
<li>The outer loop starts over so we see <strong>“Start outer”</strong></li>
<li>We enter the inner loop and see <strong>“Start inner”</strong></li>
<li>The <strong>final</strong> instruction <code>BreakOuter</code> matches so we execute <code>break 'outer</code>, which exits the outer loop and ends
the program</li>
</ol>
<h3 id="while"><a class="header" href="#while">While</a></h3>
<p>While <code>loop</code> is great for programs that actually do want to try to keep running forever (or perhaps has many exit
conditions), we often only want to loop over something <code>while</code> something is true. The <code>while</code> loop takes an expression
that evaluates to true or false. The expression is checked at the start of each iteration through the loop, if its
true, the loop will execute.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let mut counter = 0;
while counter &lt; 10 {
    println!("The counter is at {counter}");
    counter += 1;
}
println!("The loop has finished");
<span class="boring">}</span></code></pre></pre>
<p>The above is actually not a great way to loop over numbers, imagine if we forgot to add to counter!</p>
<p>Here’s a different example where we call a function until we’re happy with the result.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn get_seconds() -&gt; u64 {
</span><span class="boring">    std::time::UNIX_EPOCH
</span><span class="boring">        .elapsed()
</span><span class="boring">        .expect("Call the Doctor, time went backwards")
</span><span class="boring">        .as_secs()
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>while get_seconds() % 3 != 0 {
    println!("The time in seconds is not divisible by 3");
}
println!("The time was successfully divided by 3!");
<span class="boring">}</span></code></pre></pre>
<p>What’s really cool though is that you can do all the tricks we’ve learned above, including pattern matching with
<code>while let</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span><span class="boring">let mut messages = "The quick brown fox jumped over the lazy dog".split(" ");
</span><span class="boring">let mut get_message = move || messages.next();
</span>while let Some(message) = get_message() {
    println!("Message received: {message}")
}
println!("All messages processed");
<span class="boring">}</span></code></pre></pre>
<p><code>while let</code> is extremely useful, and we’ll see it more in the future, particularly when we deal with async await later.</p>
<h3 id="for-in"><a class="header" href="#for-in">For In</a></h3>
<p>A very common reason for looping in software is because we want to loop over every item in a collection and perform the
same set of instructions for each. This is where <code>for ... in ...</code> comes in.</p>
<p>For In allows you to step through an <code>Iterator</code>, or anything that implements <code>IntoIterator</code>, both of which we’ll talk
more about in a later chapter. Simply put though, this lets us step over each item in a collection, stream or series of
data, even series’ that might be infinite!</p>
<p>Often times you might want to do this with a collection such as an <a href="language-basics/data-types.html#arrays">Array</a>. For example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let messages: [&amp;str;2] = ["Hello", "world"];
for message in messages {
    println!("Message received: {message}")
}
println!("All messages processed");
<span class="boring">}</span></code></pre></pre>
<h4 id="range"><a class="header" href="#range">Range</a></h4>
<p>Another neat Rust type that works really well here is the Range. We haven’t covered Range yet but if you’ve been peaking
at the code samples throughout the last few chapters, you might have spotted a few!</p>
<p>Range’s allow you to specify a “closed” or “half open” range of numbers… kinda, see below.</p>
<blockquote>
<p>Actually, Range’s allow you to specify a range of anything so long as it implements the traits <code>PartialEq</code> and
<code>PartialOrd</code>. I’ve personally never seen this done for anything except numbers and characters, but its worth pointing
out. We’ll talk more about PartialEq and PartialOrd in a later chapter.</p>
</blockquote>
<p>We write Ranges in the form <code>start..end</code> where <code>start</code> is inclusive and <code>end</code> is <code>exclusive</code>. This means that <code>2..5</code>
includes 2 but not 5. If you want to create a range that includes the final number, prefix that number with <code>=</code>, eg
<code>2..=5</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let exclusive = 0..5;
let inclusive = 0..=5;
    
// This is another way of using variables in println!
// We use empty curly brackets as a positional marker
// and then fill those markers in with values after string slice
println!("Does exclusive range contain end: {}", exclusive.contains(&amp;5)); 
println!("Does inclusive range contain end: {}", inclusive.contains(&amp;5));
<span class="boring">}</span></code></pre></pre>
<p>As mentioned, Range’s can be “half open” which means you can get away with specifying only the start or the end. This is
where the Type of the start and end really start to matter though.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let u8_range = 0u8..; // this Range is explicitly defined with a u8
let i8_range = ..0i8; // this Range is defined with an i8
<span class="boring">}</span></code></pre></pre>
<p>A big warning here though: half open Ranges are dangerous when it comes to <code>for ... in ... </code> loops. Ranges with no start
can’t be used at all, and Ranges with no end will continue to try to produce numbers beyond the upper limits of the
type being used at which point your program will crash.</p>
<p>They’re great though, if we just want to do something 10 times.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>for i in 0..10 {
    println!("Loop: {i}");
}
<span class="boring">}</span></code></pre></pre>
<h2 id="homework"><a class="header" href="#homework">Homework</a></h2>
<p>The best way to learn anything is to practice it. For this section, I’d like you create a program call Fizz Buzz.</p>
<p>In Fizz Buzz we want to run through a series of numbers (say 1 to 100 inclusive). For each number:</p>
<ul>
<li>if the number is divisible by 3, print the word Fizz</li>
<li>if the number is divisible by 5, print the word Buzz</li>
<li>if the number is divisible by both 3 and 5, print FizzBuzz</li>
<li>otherwise, just print the number</li>
</ul>
<p>You can do this a few ways, but you’ll need to loop over each number and then choose what to do with it with those
numbers. As a starting point, you could use a range to generate the numbers, then use a <code>for ... in ...</code> loop to get
each number one at a time, then some <code>if</code>/<code>else</code> statements to get the output.</p>
<p>Can you work out any other ways to do it?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Functions are reusable blocks of code. They have inputs, usually perform some sort of process, then have an output.</p>
<p>We’ve been using a function called <code>main</code> to run all of our programs and examples so far. This is a special function
that is called as the program starts. We’ve also used a few other kinds of functions and methods (special functions
attached to data types) that are built into Rust. We can make and use our own functions too though.</p>
<p>Functions can be pure, or impure. A pure function takes an input, does some processing and returns an output. This makes
the function extremely predictable. Given the same input they will always produce the same output, and nothing else
within the system will change.</p>
<style>
  img {
    display: block;
    margin: 0 auto;
  }
</style>
<p><img src="language-basics/./functions/PureFunctions.svg" alt="Pure Functions" /></p>
<p>An impure function, might not always produce the same output given the same input, or may have side effects within the
system, either changing something else in the system or having some other part of the system change what the function
does.</p>
<p><img src="language-basics/./functions/ImpureFunctions.svg" alt="Impure Functions" /></p>
<h2 id="a-quick-note-on-mutability"><a class="header" href="#a-quick-note-on-mutability">A Quick Note on Mutability</a></h2>
<p>Up to now, we haven’t needed to change any data once it’s been created. By default, all variables in Rust are implicitly
“immutable”, meaning that the values inside of them can not be changed.</p>
<p>This, for example, won’t compile (try to run it to see the compiler output)</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">fn main() {
</span>let one = 1;
one = one + 1;
<span class="boring">println!("one = {one}");
</span><span class="boring">}</span></code></pre></pre>
<p>Immutability is good because it prevents data from being changed by mistake which, going on the name of the variable in
the above example, is obviously what’s happened here (ie, it seems like <code>one</code> should probably not contain <code>2</code>).</p>
<p>It’s good to use immutable variables as much as possible, but software needs to be able to process data. If we could
never mutate values, we’d always have to depend on creating copies like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let one = 1;
let two = one + 1;
<span class="boring">println!("two = {two}");
</span><span class="boring">}</span></code></pre></pre>
<p>That’s fine for small data but imagine we’re processing large data like an image. Do we want to copy it every time we
make a single pixel change?</p>
<p>You can explicitly opt in to mutability by adding the word <code>mut</code> (pronounced “mute”) in front of the variable name.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut message = "Hello".to_string();
message.push_str(", world!"); // Modify message by adding this data to the end
<span class="boring">println!("{message}");
</span><span class="boring">}</span></code></pre></pre>
<h2 id="creating-and-calling-functions"><a class="header" href="#creating-and-calling-functions">Creating and calling functions</a></h2>
<p>Functions are defined with the <code>fn</code> keyword (short for FuNction), followed by a name, followed by brackets <code>()</code> which
may or may not contain parameters, possibly followed by an arrow <code>-&gt;</code> and a return type (if no return type is specified
the return type is the Unit Type <code>()</code>, see the <a href="language-basics/./data-types.html#the-unit-type">data types chapter</a>). This part of the
function is called the “function header”. The function is completed by a code block, code between curly brackets, which
is also called the function body.</p>
<p>So lets create the simplest possible function:</p>
<pre><pre class="playground"><code class="language-rust">fn say_hello() {
    println!("Hello, world");
}

<span class="boring">fn main() {
</span><span class="boring">    say_hello();
</span><span class="boring">}</span></code></pre></pre>
<p>This function is called <code>say_hello</code>, it has no parameters and does not return anything. Because it writes to the
terminal, this function is considered to be impure.</p>
<p>We can call the function using its name and empty brackets.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn say_hello() {
</span><span class="boring">    println!("Hello, world");
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    say_hello();
}</code></pre></pre>
<p>You’ll notice this function doesn’t actually have any inputs or outputs. Let’s start by providing an input.</p>
<h2 id="passing-parameters"><a class="header" href="#passing-parameters">Passing Parameters</a></h2>
<pre><pre class="playground"><code class="language-rust">fn say_hello(name: &amp;str) {
    println!("Hello, {name}");
}

<span class="boring">fn main() {
</span><span class="boring">    say_hello("Yuki");
</span><span class="boring">}</span></code></pre></pre>
<p>Now the function has one input (we call it a parameter) called <code>name</code>. You can see that we also provide type information
for the parameter, in this case it’s a string slice (<code>&amp;str</code>). The parameter can be used as a variable within the
function, so we use it in our <code>println!</code>.</p>
<p>To pass the data into the function we place it between the brackets:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn say_hello(name: &amp;str) {
</span><span class="boring">    println!("Hello, {name}");
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    say_hello("Yuki");
}</code></pre></pre>
<p>We can have multiple parameters too. Parameters are ordered so when you call the function, you need to match the order
they’re specified. For example:</p>
<pre><pre class="playground"><code class="language-rust">fn say_hello_two(first_person: &amp;str, second_person: &amp;str) {
    println!("Hello, {first_person} and {second_person}");
}

fn main() {
    say_hello_two("Indra", "Yuki");
}</code></pre></pre>
<h2 id="returning-from-functions"><a class="header" href="#returning-from-functions">Returning from Functions</a></h2>
<p>Let’s fix our function to remove the side effect. Instead of directly printing to the terminal from the function, we’ll
return the string we want to display and move the side effect to main.</p>
<p>We’ll make the following changes:</p>
<ul>
<li>We’ll rename the function to reflect the change in behaviour (see <a href="language-basics/functions.html#best-practices">Best Practices</a> below)</li>
<li>We’ll add the return type (in this case <code>String</code>) to the function header, after <code>-&gt;</code></li>
<li>We’ll create the String using the <code>format!</code> macro and store it in a variable <code>message</code> (note: the variable isn’t
necessary, it’s just for clarity)</li>
<li>We’ll return the <code>message</code> from the function, remember the code blocks can be expressions, we don’t need to explicitly
write <code>return</code> (though we can), we just need to make the thing we want to return the last bit of the block and forgo
the semicolon</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn create_greeting(name: &amp;str) -&gt; String {
    let message = format!("Hello, {name}");
    message
}

fn main() {
    let greeting = create_greeting("Yuki");
    println!("{greeting}");
}</code></pre></pre>
<h2 id="recursion"><a class="header" href="#recursion">Recursion</a></h2>
<p>See also: <a href="language-basics/functions.html#recursion">recursion</a></p>
<p>In Rust, functions can call other functions, like how our <code>main()</code> function calls our <code>create_greeting(...)</code> function in
the previous example. A function that calls itself is described as recursive. Take for example this method for finding
the nth number in the fibonacci sequence</p>
<pre><pre class="playground"><code class="language-rust">fn find_fibonacci(n: u128) -&gt; u128 {
    if n == 0 || n == 1 { // if n equals 0 or n equals 1
        n
    } else {
        find_fibonacci(n - 1) + find_fibonacci(n - 2)
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let n = 11;
</span><span class="boring">    let fibonacci = find_fibonacci(n);
</span><span class="boring">    println!("The {n} value of fibonacci is {fibonacci}");
</span><span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Note in this function that we use a boolean OR (<code>||</code>) in the <code>if</code> so the larger expression evaluates to true if either
the left or right parts of the expression evaluate to true. I.e. the expression is true if n is equal to 0 OR if n is
equal to 1.</p>
<p>We also use the <code>if</code>/<code>else</code> as an expression so the return of the function is equal to the values in the <code>if</code>/<code>else</code>
blocks. If the expression in the <code>if</code> is true, then we return <code>n</code>, otherwise we return the result of calling the same
function with new parameters.</p>
</blockquote>
<p>Because we call <code>find_fibonacci</code> inside of <code>find_fibonacci</code>, this is a recursion. Each time we call the function in this
way, we add another layer on <a href="language-basics/./memory.html">the stack</a>. The stack is finite, so if we give the function a
large enough number, it will eventually run out of space in the stack, causing a stack overflow, and you’ll see
something like:</p>
<pre><code class="language-text">thread 'main' has overflowed its stack
</code></pre>
<blockquote>
<p>Its worth noting I had to manually set the stack size to something unreasonably small</p>
</blockquote>
<p>Rust does support “tail recursion” which is technique for turning a recursive function into a loop at compile time. This
not only minimises stack usage to effectively a single function call but is also much faster. However, I think this is
an overrated feature. In any language that supports tail recursion, it’s hard to guarantee the compiler will optimise
this way, and it’s easy to break. My recommendation is if you need to recurse a <em>lot</em>, then consider whether you can
manually rewrite your function as a loop instead of depending on a compiler optimization.</p>
<h2 id="ownership"><a class="header" href="#ownership">Ownership</a></h2>
<h3 id="memory-management-primer"><a class="header" href="#memory-management-primer">Memory Management Primer</a></h3>
<p>Variables in Rust have to live somewhere in physical memory. This primarily comes down to the Stack, the Heap and the
binary (for a deeper explanation, see the <a href="language-basics/memory.html">chapter on memory</a>). The Heap can be thought of as managed. You
ask the operating system (or other memory manager) to “allocate” you a block of memory to use for writing to and reading
from, before finally “freeing” that block and returning the memory to the operating system.</p>
<p>In some programming languages, this memory is managed manually by you. You have to ask for the memory and free it
yourself. This leads to some problems:</p>
<ul>
<li>What happens if you try to use memory that wasn’t allocated?</li>
<li>What happens if you try to use memory that you already freed?</li>
<li>What happens if you try to store more data than fits?</li>
</ul>
<p>Not only is it surprisingly easy to make mistakes here, the consequences can be severe: around 70% of all security
vulnerabilities are caused by accidental misuse of memory.</p>
<p>In order to get around these problems, some programming languages use an automated method of memory management called
garbage collection. In this method, you, the software engineer, don’t have to think about the actions required to get
or return memory to/from the operating system. Instead, as memory is allocated, the garbage collector built into the
language, will monitor to see which parts of your program are actively looking at that bit of memory, through a process
called reference counting. Once the number of places using that data has dropped to zero, the garbage collector can
safely free the memory.</p>
<p>This is much safer than manually managing the memory yourself, but comes with some of its own problems:</p>
<ul>
<li>The garbage collector requires additional resources to manage memory
<ul>
<li>This includes CPU time to do the work but in some cases can also require significantly more memory</li>
</ul>
</li>
<li>Managing memory by proxy is less efficient than managing it directly, meaning its slower</li>
<li>You have limited to no control over what the garbage collector does or when it does it, this can have big negative
impacts to performance at uncontrollable times</li>
</ul>
<p>Rust’s method of memory management is a little different. It’s low level, giving you the speed of manual memory
management, but its mechanisms are hidden behind abstractions that mitigate its risks. It’s certainly not as easy to
learn, but once you get your head around it, it makes a lot of sense.</p>
<h3 id="introducing-ownership"><a class="header" href="#introducing-ownership">Introducing Ownership</a></h3>
<p>In Rust, all data is “owned”. When the variable that “owns” the data goes out of scope, the data is dropped. This means
that if the data was stored on the Heap, then that bit of memory is immediately freed.</p>
<p>Let’s have a play with this, first, lets look at the scope aspect of ownership:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">fn main() {
  let a = 'a'; // We create `a` in the outer scope of "main"

  { // Start of a new block, starting a nested scope

    println!("{a}"); // This works as `a` is in scope

    let b = 'b'; // We create `b` in the inner scope of this code block
    println!("{b}"); // This works as `b` is in scope

  } // End of the block, b goes out of scope

  println!("{a}"); // This still works as `a` is still in scope
  println!("{b}"); // This does not work as `b` went out of scope
}</code></pre></pre>
<p>We can see that once a variable is out of scope, it can’t be used. If you run the above example (remember, you can do
that in this book by mousing over the example and hitting the play button), you’ll see it won’t compile and (amongst
a few other bits) gives you this message:</p>
<pre><code class="language-text">error[E0425]: cannot find value `b` in this scope
  --&gt; src/main.rs:14:14
</code></pre>
<p>Which tells us <em>exactly</em> what’s wrong! Rust’s compiler messages generally amazing, especially when it comes to working
with ownership, so it’s worth getting used to how Rust presents its errors.</p>
<p>Next, lets look at how data can only be “owned” by one thing at a time:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">fn main() {
</span>let a = "hello".to_string(); // We create some data and give it to `a`
let b = a;                   // We give the data in `a` to `b`, transfering ownership
println!("{b}");             // This would be fine as b owns "hello"
println!("{a}");             // This won't compile, the data "moved" from `a` to `b`
<span class="boring">}</span></code></pre></pre>
<p>The statement <code>let b = a;</code> “moves” ownership of the string from <code>a</code> to <code>b</code>. Normally we wouldn’t “move” data in this way
(spoilers: this is, after all, a chapter on functions), but it neatly shows that the data can’t be owned by multiple
variables at once.</p>
<h3 id="move-semantics"><a class="header" href="#move-semantics">Move Semantics</a></h3>
<p>You might have noticed that we swapped from <code>char</code>s in the first ownership example to a <code>String</code> in the second. This is
because there are two mechanisms at play: “Move” and “Copy”.</p>
<p>Let’s try the same code with chars:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let a = '雪';    // We create some data and give it to `a`
let b = a;       // We set b to be equal to a
println!("{b}"); // Prints 雪 
println!("{a}"); // Also prints 雪
<span class="boring">}</span></code></pre></pre>
<p>This works! But String didn’t… 🤔</p>
<p>The reason for this is that <code>char</code> is Copy, that is to say that it has the <code>Copy</code> trait. We’ll talk more about Traits
in a future chapter, but essentially Traits provide behaviour to Data. Things can have the <code>Copy</code> trait applied to them
if they can be trivially copied and this usually (always?) means the data exists on the stack. The reason for this is
all that “allocating” and “freeing” memory on the stack we talked about earlier requires a non-trivial amount of time
and resources.</p>
<p>When data has the Copy trait, instead of being moved from one variable to another, it’s copied. This mechanism on data
that is Copy is implicit. Data that does not or can not implement Copy may still be duplicated if it implements the
trait <code>Clone</code>, which provides the <code>.clone()</code> method. We’ll talk more about implementing traits in the traits section,
but <code>String</code> already implements this so here’s how to use it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let a = "hello".to_string(); // We create some data and give it to `a`
let b = a.clone();           // Allocates memory on the heap and copies the data into it
println!("{b}");             // Prints "hello"
println!("{a}");             // Also prints "hello"
<span class="boring">}</span></code></pre></pre>
<p>You’ll also note that we used a full fat <code>String</code> here, not a string slice reference. Here’s what that would look like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let a = "hello";   // `a` is a reference to data that exists in the binaries "data"
let b = a;         // references are Copy so the reference is copied from a to b
println!("{b}");   // Prints "hello"
println!("{a}");   // Also prints "hello"
<span class="boring">}</span></code></pre></pre>
<p>Because <code>"hello"</code> exists inside the binaries data you can not “Own” it. Ownership would imply that once its no longer
used it can be freed, but as its part of the binary, that wouldn’t make sense. Instead, we just get a reference to where
the value exists in memory. This reference is also immutable, you can’t change values in the binary. Immutable
references <em>are</em> Copy though.</p>
<p>What does this have to do with functions though?</p>
<h3 id="functions-and-ownership"><a class="header" href="#functions-and-ownership">Functions and Ownership</a></h3>
<p>When we pass data into functions through the use of parameters, the data follows the rules of move semantics.</p>
<p>Let’s go back to our <code>create_greeting()</code> function. Instead of passing in a string slice reference, what would happen if
we passed in a <code>String</code>?</p>
<pre><pre class="playground"><code class="language-rust compile_fail">fn create_greeting(name: String) -&gt; String {
    let message = format!("Hello, {name}");
    message
}

fn main() {
  let yuki = "Yuki".to_string();
  let message = create_greeting(yuki);
  println!("{message}"); // This would be fine but...
  println!("{yuki}"); // This won't compile
}</code></pre></pre>
<p>In the above example, we moved ownership of the data stored in the variable <code>yuki</code> into the parameter <code>name</code> in the
function <code>create_greeting</code>. This means after the function the variable <code>yuki</code> can no longer be used.</p>
<p>Because the <code>format!</code> macro does not take ownership of the data in <code>name</code>, we could return both the message <em>and</em> the
original <code>String</code> data using a tuple.</p>
<pre><pre class="playground"><code class="language-rust">fn create_greeting(name: String) -&gt; (String, String) {
    let message = format!("Hello, {name}");
    (message, name)
}

fn main() {
  let yuki = "Yuki".to_string();
  let (message, yuki) = create_greeting(yuki);
  println!("{message}"); 
  println!("{yuki}"); // This works again
}</code></pre></pre>
<p>We’ve changed our <code>create_greeting()</code> function to return a tuple that includes both strings. When the function returns
we destructure the tuple (see <a href="language-basics/control-flow.html">destructuring with patterns</a>) into two new variables,
<code>message</code> and <code>yuki</code>. Note: this new <code>yuki</code> is a different variable from the old <code>yuki</code>, this is called “shadowing”.</p>
<p>This is obviously a terrible way to deal with ownership. Going back to our original function, you can see that we are
taking a reference to a string slice instead. The <code>String</code> type can be “dereferenced” into a reference to a string slice
(remember the internal representation of a String is the same as a string slice), so we can create a reference to our
<code>yuki</code> <code>String</code> using an ampersand:</p>
<pre><pre class="playground"><code class="language-rust">// Changed back to taking a &amp;str
fn create_greeting(name: &amp;str) -&gt; String {
    let message = format!("Hello, {name}");
    message
}

fn main() {
  let yuki = "Yuki".to_string();
  let message = create_greeting(&amp;yuki);
  println!("{message}");
  println!("{yuki}"); // Yuki's ownership was never moved so this now works
}</code></pre></pre>
<p>Let’s say we wanted our function to modify the string instead. Ideally we’d want to avoid modifying data that’s passed
to a function but sometimes that’s not possible, if you need to do it you can pass a mutable reference.</p>
<pre><pre class="playground"><code class="language-rust">// Change &amp;str to &amp;mut String
fn create_greeting(greeting: &amp;mut String, name: &amp;str)  {
    greeting.push_str(", ");
    greeting.push_str(name);
}

fn main() {
  let mut greeting = "Hello".to_string();
  let name = "Yuki".to_string();
  create_greeting(&amp;mut greeting, &amp;name);
  println!("{greeting}");
}</code></pre></pre>
<p>Some things to note:</p>
<ul>
<li>In order to mutate greeting via a mutable reference, the variable itself must also be mutable: <code>let mut greeting ...</code></li>
<li>When we pass the reference, we are explicit that we are allowing the reference to be mutable too:
<code>create_greeting(&amp;mut greeting, ...)</code></li>
<li>The function takes a mutable reference to a String, not a string slice, as string slices are not mutable, but Strings
are.</li>
</ul>
<p>Finally, when it comes to references, you can have as many immutable references to a value as you like, OR a single
mutable reference. Mutable references are not Copy.</p>
<h3 id="lifetimes"><a class="header" href="#lifetimes">Lifetimes</a></h3>
<p>So far so clear, but it turns out that keeping track of those references is actually quite hard.</p>
<p>Let’s create a function that takes a reference to a string and returns two parts to that string:</p>
<pre><pre class="playground"><code class="language-rust">fn split(input: &amp;str, at: usize) -&gt; (&amp;str, &amp;str) {
  let up_to = std::cmp::min(at, input.len()); // Prevent out of bounds
  (&amp;input[..up_to], &amp;input[up_to..])
}

fn main() {
  let input = "yuki".to_string();
  let (left, right) = split(&amp;input, 2);

  println!("Input: {input}"); // yuki
  println!("Left:  {left}");  // yu
  println!("Right: {right}"); // ki
}</code></pre></pre>
<blockquote>
<p>Note, we are taking a sub slice of the input string using ranges. <code>&amp;input[..up_to]</code> means the subslice starts at the
beginning of the string and runs up to, but does not include the “up_to“th element (remember indexing starts at 0, so
if up_to is 2, then the sub slice includes bytes 0 and 1 but not 2). <code>&amp;input[up_to..]</code> starts at the “up_to“th byte
and continues until the end of the “input” slice. Also note that these are ranges of bytes, not characters so there is
a danger here if using multibyte characters. Try not to split strings like this as it’s not guaranteed the result is a
valid utf-8 string.</p>
</blockquote>
<p>The function split takes a reference to a string, a point to split at, and the returns everything on the left of the
split and everything on the right. The cool thing here is that the string isn’t duplicated, the values <code>left</code> and
<code>right</code> are references that point to the inside of our input string!</p>
<p>How does Rust know that though? Let’s confuse it a bit.</p>
<p>Instead of splitting at a particular point, we’ll find a sub string inside the input string, then split around that:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">fn split(input: &amp;str, sub_string: &amp;str) -&gt; (&amp;str, &amp;str) {
  if let Some(found_at) = input.find(sub_string) {
    (&amp;input[..found_at], &amp;input[found_at + sub_string.len()..])
  } else {
    (&amp;input[..], &amp;input[input.len()..])
  }
}

fn main() {
  let input = "yuki".to_string();
  let sub_string = "uk";
  let (left, right) = split(&amp;input, sub_string);

  println!("Input: {input}"); // yuki
  println!("Left:  {left}"); // y
  println!("Right: {right}"); // i
}</code></pre></pre>
<p>This example won’t compile, we get the error: <code>expected named lifetime parameter</code>, what does that mean?</p>
<p>We also get guidance from the Rust compiler on how to fix our problem, and what it suggests will work, but once you
understand the problem, you’ll see there’s a better way to solve it.</p>
<p>A lifetime is Rust’s way of tracking reference usage. A reference needs to be tied back to its owning variable and this
relationship must be understood at compile time.</p>
<p>Remember the stack? Let’s tie what we know about ownership to what we know about the stack.</p>
<ul>
<li>Some data is stored on the stack, some is stored on the heap</li>
<li>Heap data is tied back to variables on the stack that “own” the heap data</li>
<li>As we enter a function, all the space required for the stack data is added to the top of the stack</li>
<li>Further functions go up the stack</li>
<li>As functions come to an end they are removed from the top of the stack</li>
<li>Owned data that is not returned down the stack is freed</li>
</ul>
<p>When it comes to references, we need to make sure that a reference to owned data does not out live the owned data.</p>
<p>For example, lets create a string on the heap called <code>my_string</code>. We’ll then return a reference to that string, but not
the string itself. This would mean that when the function comes to an end, the variable <code>my_string</code> goes out of scope,
so the data that it owns on the Heap is freed… what would our reference point at now? Luckily Rust won’t let us do
this:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn bad() -&gt; &amp;str {
  let my_string = "Oh no!".to_string();
  &amp;my_string
}
<span class="boring">}</span></code></pre></pre>
<p>In order to prevent this, Rust tracks the lifetimes of each reference and its owned data. It can often do this
automatically. In the first version of our function Rust can see that only one reference enters the function, no other
references are in play, so Rust knows that the two references that are returned <em>must</em> be tied to the same data as the
incoming reference.</p>
<p>In the second version of our function, we pass two references in, now Rust is now less sure about which data the
returned references should be tied to. The suggestion the Rust compiler gives us is to tie all the references to the
same lifetime. This actually is a valid approach as Rust will use the shortest living bit of data to tie the references
to.</p>
<p>Let’s do what it says. Rust lifetimes are annotated with generic labels. If we’re being lazy we might use a single
lettered label like <code>'a</code>, though if a lot of lifetimes are at play it’s definitely better to use longer, clearer labels.</p>
<p>We’ll change the header of our function to include the lifetime <code>'a</code>. First we tell Rust we want to use a lifetime by
putting it inside triangle brackets after the function name. Then we mark each reference with that lifetime.</p>
<pre><pre class="playground"><code class="language-rust">fn split&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;'a str) -&gt; (&amp;'a str, &amp;'a str) {
    // ...
<span class="boring">  if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">    (&amp;input[..found_at], &amp;input[found_at + sub_string.len()..])
</span><span class="boring">  } else {
</span><span class="boring">    (&amp;input[..], &amp;input[input.len()..])
</span><span class="boring">  }
</span>}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">  let input = "yuki".to_string();
</span><span class="boring">  let sub_string = "uk";
</span><span class="boring">  let (left, right) = split(&amp;input, sub_string);
</span><span class="boring">
</span><span class="boring">  println!("Input: {input}"); // yuki
</span><span class="boring">  println!("Left:  {left}"); // y
</span><span class="boring">  println!("Right: {right}"); // i
</span><span class="boring">}</span></code></pre></pre>
<p>You can run the above and see this example works just fine, however, it’s not ideal. We’ve tied all the references to
the same lifetime. The following shows that we can’t compile code that we know should work.</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">fn split&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;'a str) -&gt; (&amp;'a str, &amp;'a str) {
</span><span class="boring">    if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">        (&amp;input[..found_at], &amp;input[found_at + sub_string.len()..])
</span><span class="boring">    } else {
</span><span class="boring">        (&amp;input[..], &amp;input[input.len()..])
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>let input = "yuki".to_string();

let (left, right) = {
    let sub_string = "uk".to_string();
    split(&amp;input, &amp;sub_string)
};

println!("Input: {input}"); // yuki
println!("Left:  {left}"); // y
println!("Right: {right}"); // i
<span class="boring">}</span></code></pre></pre>
<p>This is contrived but here we’ve created an inner scope for our sub string. When that scope ends, that substring will be
freed. You and I know that the left and right references are tied to the input variable in the outer scope, but we told
Rust that it should tie all the lifetimes together. Since the sub string lasts the least amount of time, that’s the
lifetime it used.</p>
<p>To fix this problem we can just remove the lifetime annotation from the sub_string parameter. Now everything works
as we’d expect:</p>
<pre><pre class="playground"><code class="language-rust">fn split&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str) -&gt; (&amp;'a str, &amp;'a str) {
  // ...
<span class="boring">  if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">    (&amp;input[..found_at], &amp;input[found_at + 1..])
</span><span class="boring">  } else {
</span><span class="boring">    (&amp;input[..], &amp;input[input.len()..])
</span><span class="boring">  }
</span>}

fn main() {
    let input = "yuki".to_string();
    
    let (left, right) = {
        let sub_string = "uk".to_string();
        split(&amp;input, &amp;sub_string)
    };
    
    println!("Input: {input}"); // yuki
    println!("Left:  {left}"); // y
    println!("Right: {right}"); // i
}</code></pre></pre>
<p>References and lifetimes get really tricky. Here’s how I like to think about them. Imagine a person flying a kite. The
person is the owner of the data, the kite is the reference, and the string tying them together is the lifetime.</p>
<p>The kite can go up and down the stack freely, but it can’t go below where the person is standing, that’s the equivalent
of the ground.</p>
<p>Multiple people can fly their kites through the same functions, and each one has its own kite string (lifetime).</p>
<p>Its even possible to entwine the kites. Imagine a function that takes two string references and returns the longest.
This is like a function that accepts two kites but only the largest is returned. Because you don’t know who that kite
belongs to, it can’t go below the person standing highest on the stack.</p>
<p>Lifetimes can be incredibly powerful, there’s no need to fear them. One amazing example is that you can have a string
that contains some data, for example it could be a serialized format like JSON or YAML, or it could be something like
an Advent of Code input string. Lifetimes mean that you bring that String into your program, allocating the memory for
it once, then turn it into a complex data structure. So long as the original String exists, the data structure can need
not allocate any further memory, which is incredibly efficient.</p>
<pre><pre class="playground"><code class="language-rust">struct User&lt;'a&gt; {
  name: &amp;'a str,
  fur_color: &amp;'a str,
}


fn parse_user&lt;'a&gt;(input: &amp;'a str) -&gt; User&lt;'a&gt; {
    // ...
<span class="boring">    // ok, you caught me, this isn't a real parser
</span><span class="boring">    let mut iter = input.lines();
</span><span class="boring">    let name = &amp;iter.next().unwrap()[6..];
</span><span class="boring">    let fur_color = &amp;iter.next().unwrap()[5..];
</span><span class="boring">    User {
</span><span class="boring">      name,
</span><span class="boring">      fur_color,
</span><span class="boring">    }
</span>}

fn main() {
    let user = "name: Yuki
fur: white"
            .to_string();
    let User { name, fur_color } = parse_user(&amp;user);
    println!("User {name} is a {fur_color} cat");
}</code></pre></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<p>Here are some best practices when it comes to working with functions:</p>
<ul>
<li>Create a function whenever a section of code can be described in a few words</li>
<li>The function name should describe what that code is doing</li>
<li>Functions should only do one thing, avoid big branches inside functions</li>
<li>Keep functions short, but not too short. Functions should be set of instructions grouped together, too few, and it may
not be worth the function, too many, and it may need to be broken down into more functions</li>
<li>Do not take ownership unless you expressly need to own the data</li>
<li><em>Try</em> to avoid mutable parameters</li>
<li>Be specific about your lifetimes, if using more than one or two, try naming them</li>
</ul>
<h2 id="homework-1"><a class="header" href="#homework-1">Homework</a></h2>
<p>This time I’d like you to create a function that splits our string like before, but instead of returning a left and
right side it splits every part of the string.</p>
<p>There is already a split method on string slices, but I’d like you to only use find, and create a recursive function.</p>
<p>You’ll need to use a collection type to store all the chunks created by the split, I suggest using <code>Vec</code> (see the
<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html" title="" target="_blank">Documentation</a>) which is built into Rusts standard library.</p>
<p>A Vec is a variably sized array that you can push new items on to the end of using the <code>.push(...)</code> method.</p>
<p>To check whether your Vec contains the correct information after the program has run, use the <code>dbg!</code> macro (we’ll talk
more about how this works another time, all you need to know is it will work for a Vec of string slice references).</p>
<p>The header of your function might look something like this:</p>
<pre><code class="language-rust ignore">fn split(input: &amp;str, split_at: &amp;str, collection: &amp;mut Vec&lt;&amp;str&gt;)</code></pre>
<p>but you need to work out what the lifetimes will be.</p>
<p>If your main function looks like this:</p>
<pre><code class="language-rust ignore">let test_str = "Hello, world!";
let split_at = "l";
let mut collection = Vec::new();

split(test_str, split_at, &amp;mut collection);

dbg!(collection);</code></pre>
<p>Then your output should look something like this:</p>
<pre><code class="language-text">[src\main.rs:17:5] collection = [
    "He",
    "",
    "o, wor",
    "d!",
]
</code></pre>
<p>This isn’t an easy task, and will require thinking about the lifetimes carefully.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="tests"><a class="header" href="#tests">Tests</a></h1>
<p>Tests. Are. Awesome.</p>
<p>They are my favourite bit of software engineering. I’m sure many of you can relate, but I don’t tend to trust humans
telling me I’m doing well at my job. When I make a test pass though, oh that dopamine hits good.</p>
<p>A good test makes sure that the thing we’re building does what we think it should do.</p>
<p>Anecdotally I recently interviewed at a company where I professed my love of tests, and they told me flatly they don’t
write tests, they “move fast”. Later in the interview they admitted they were having morale issues because their
engineers were constantly getting called out of hours to fix things.</p>
<p>So, it begs the question: are you moving fast if you’re writing software that doesn’t work?</p>
<p>Software engineers are not paid to write software, we’re paid to solve problems. Tests are what make sure we solved the
problem and by automating our tests they make sure we don’t accidentally “unsolve” it further down the line.</p>
<h2 id="the-testing-pyramid"><a class="header" href="#the-testing-pyramid">The testing Pyramid</a></h2>
<p>There are many ways to test software, these largely fall into three categories that make up what we call the testing
pyramid.</p>
<div class="pyramid">
<style scoped>
.pyramid code {
    text-align: center;
}
</style>
<pre><code class="language-text">            ↑         /----------\        |           
            |        / End-to-End \       |           
  more      |       /--------------\      |    less   
expensive   |      /   Integration  \     |  expensive
   use      |     /------------------\    |    use    
  less      |    /        Unit        \   |    more   
            |   /----------------------\  ↓           
</code></pre>
</div>
<p>It’s a pyramid to indicate that, although all tests are important, those lower down the pyramid should be laying the
foundation for the others. Not only should you have more of them, but they will provide the greatest feeling of safety
and security.</p>
<h3 id="end-to-end-tests"><a class="header" href="#end-to-end-tests">End-to-End Tests</a></h3>
<p>E2E tests are designed to make sure that the user of the software you’ve created can complete full user
journeys, for example, can the user open, edit and save a file in a desktop application or can a user add an item to
a shopping cart and checkout of an ecommerce store. End-to-End tests are the slowest form of test and lack depth.</p>
<h3 id="integration-tests"><a class="header" href="#integration-tests">Integration Tests</a></h3>
<p>Integration tests check that the code you control works correctly with code that your program depends on that you
don’t control. This would include things like databases or other data stores, web apis, library apis, etc. Integration
tests are also used if your software produces a public API. You write tests to check that people using your software in
its more natural state. Because of the communication component to these tests, these tests are also quite slow.</p>
<h3 id="unit-tests"><a class="header" href="#unit-tests">Unit Tests</a></h3>
<p>Unit tests test a single unit of functionality. These tests are the simplest, fastest and should make up the bulk
of your testing. These tests are so important, that it is best practice to write them before you write the code
you’re going to test.</p>
<p>For this book, we’re only going to cover Unit Tests. That isn’t to say that Integration Tests and End-to-End Tests
aren’t important, they absolutely are, and there are many good guides out there. But, it is to say, that Unit Tests are
<em>so</em> important, that they significantly impact how we communicate about Rust code and particularly libraries that we
might use, and they’ll change the way we talk about Rust in this book going forward.</p>
<h2 id="introduction-to-modules"><a class="header" href="#introduction-to-modules">Introduction to Modules</a></h2>
<p>Unlike many languages, in Rust, tests live with the code that they’re testing. To explain this we need to talk about
how code in Rust is organised with Modules.</p>
<p>A Module is simply a container for other things, functions, type definitions, other modules, etc. You could think of it
like a physical container, though you can nest any number of containers together. The contents of the module are private
to that module unless explicitly marked as public with the <code>pub</code> keyword.</p>
<p>We define a module with the <code>mod</code> keyword and a name. There are then three ways to define what’s inside that module:</p>
<ol>
<li>With a directory named the same thing as the module which contains the file <code>mod.rs</code>, eg <code>my_module/mod.rs</code></li>
<li>With a file in the same directory named the same thing as the module, eg <code>my_module.rs</code></li>
<li>Inside curly brackets, eg <code>mod my_module { ... }</code></li>
</ol>
<p>If the module exposes anything publicly, you can then reference them with the path to the module and the name of the
thing you’re referencing separate by double colons. Sound familiar? It should, this is how we’ve been accessing Rust’s
standard library. For example, the <code>stdin</code> function is inside the <code>io</code> module, which itself is available inside the
<code>std</code> library.</p>
<p>We access that function using <code>std::io::stdin()</code>. We can also use the <code>use</code> keyword to simplify this a bit, for example:</p>
<pre><code class="language-rust noplayground">use std::io::stdin; // Full name here

fn main() {
    let _ = stdin(); // No need to use the full name here
}</code></pre>
<h2 id="test-modules"><a class="header" href="#test-modules">Test Modules</a></h2>
<p>In Rust, we typically create a test module near the code that is being tested. Let’s say we want to test some of the
functions we wrote in the last chapter (I’ve renamed them slightly below).</p>
<p>First we start by creating a module to test these functions in the same file as the functions exist</p>
<pre><code class="language-rust noplayground">fn split_at(input: &amp;str, at: usize) -&gt; (&amp;str, &amp;str) {
    // ...
<span class="boring">    let up_to = std::cmp::min(at, input.len()); // Prevent out of bounds
</span><span class="boring">    (&amp;input[..up_to], &amp;input[up_to..])
</span>}

fn split_around&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str) -&gt; (&amp;'a str, &amp;'a str) {
    // ...
<span class="boring">  if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">    (&amp;input[..found_at], &amp;input[found_at + sub_string.len()..])
</span><span class="boring">  } else {
</span><span class="boring">    (&amp;input[..], &amp;input[input.len()..])
</span><span class="boring">  }
</span>}

fn split_around_many&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str, collection: &amp;mut Vec&lt;&amp;'a str&gt;) {
    // ...
<span class="boring">    if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">        let end_pos = found_at + sub_string.len();
</span><span class="boring">        collection.push(&amp;input[..found_at]);
</span><span class="boring">        split_around_many(&amp;input[end_pos..], sub_string, collection);
</span><span class="boring">    } else {
</span><span class="boring">        collection.push(&amp;input);
</span><span class="boring">    }
</span>}

mod tests {
    // empty for now
}</code></pre>
<p>As long as nothing in the <code>tests</code> module is used in your main program it shouldn’t appear in your final binary, however,
this isn’t good enough. There’s a risk we might make a mistake, but ever without that, the module will still be
processed by the compiler in order to do things like type checking. We only care about this module when we’re running
our tests and Rust provides us a way to tell it that, the
<a href="https://doc.rust-lang.org/reference/conditional-compilation.html" title="" target="_blank">
<code>#[cfg(...)]</code> attribute</a>.</p>
<p>Attributes are one of Rusts many meta programming tools which we’ll cover more in the future at increasing difficulty
levels. For now, the <code>cfg</code> attribute allows us to tell the Rust Compiler (<code>rustc</code>) <em>when</em> we want to compile something.
There are many, many ways to use conditional compilation, but for tests it’s pretty simple, we only want the module
compiled when we’re building tests and <code>cfg</code> has a “predicate” to identify this simply called <code>test</code>.</p>
<p>We use <code>cfg</code> to only build our tests module when we’re building for tests like this:</p>
<pre><code class="language-rust noplayground"><span class="boring">fn split_at(input: &amp;str, at: usize) -&gt; (&amp;str, &amp;str) {
</span><span class="boring">    let up_to = std::cmp::min(at, input.len()); // Prevent out of bounds
</span><span class="boring">    (&amp;input[..up_to], &amp;input[up_to..])
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn split_around&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str) -&gt; (&amp;'a str, &amp;'a str) {
</span><span class="boring">  if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">    (&amp;input[..found_at], &amp;input[found_at + sub_string.len()..])
</span><span class="boring">  } else {
</span><span class="boring">    (&amp;input[..], &amp;input[input.len()..])
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn split_around_many&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str, collection: &amp;mut Vec&lt;&amp;'a str&gt;) {
</span><span class="boring">    if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">        let end_pos = found_at + sub_string.len();
</span><span class="boring">        collection.push(&amp;input[..found_at]);
</span><span class="boring">        split_around_many(&amp;input[end_pos..], sub_string, collection);
</span><span class="boring">    } else {
</span><span class="boring">        collection.push(&amp;input);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    // still empty
}</code></pre>
<h2 id="writing-tests"><a class="header" href="#writing-tests">Writing Tests</a></h2>
<p>Now we’re ready to write our first test.</p>
<p>A test is simply a function that we mark with another attribute <code>#[test]</code>.</p>
<p>Let’s quickly write a broken test to make sure things are working.</p>
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    
    #[test]
    fn test_split_at() {
        assert!(false, "Intentionally failing a test to show how they work")
    }
}</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=d62bd5aa150a9f0bdab23a98b655fc78" title="" target="_blank">Link to tests</a></p>
<blockquote>
<p>Note: currently mdbook, the tool we’re using to create the IRISS book, does not support running tests natively.
Instead, we’ll provide a permalink to the relevant code in Rust Playground. Inside Rust Playground, click the three
dots next to Run, and choose Test</p>
</blockquote>
<p>The <code>assert!()</code> macro takes either one or two parameters. The first parameter which is not optional is a boolean value,
or something that evaluates to a boolean. If this boolean is false, then the assertion will cause a panic, and the test
will fail (unless it’s expected to panic, more on that later).</p>
<p>The second, optional parameter allows us to annotate the assertion, which can help us more easily determine which (if
any) assertion failed in a test that might have multiple assertions. You’ll find that people don’t use this as much, I’m
guilty of this too, but I do recommend making an effort to describe each specific assertion. The people you work with,
as well as future you, will appreciate the effort.</p>
<p>There are three main assert macros:</p>
<ul>
<li><code>assert!(&lt;boolean value&gt;, &lt;optional message&gt;)</code> asserts value is true or panics with optional message</li>
<li><code>assert_eq!(&lt;left&gt;, &lt;right&gt;, &lt;optional message&gt;)</code> asserts left is equal to right or panics with optional message</li>
<li><code>assert_ne!(&lt;left&gt;, &lt;right&gt;, &lt;optional message&gt;)</code> asserts left is NOT equal to right or panics with optional message</li>
</ul>
<p>There are a couple of restrictions with the assert macros. Values used must implement <code>PartialEq</code> and <code>Debug</code>. Most
built in types already implement both, and we’ll talk about how to implement them for your own types in the Traits
chapter.</p>
<blockquote>
<p>You can also find more assert macros for specific types, in Rusts experimental tool chain, and in other libraries.
There are even libraries specifically built for enhancing your tests but these are out of scope for this book.</p>
</blockquote>
<p>To run tests in our project we use <code>cargo test</code>. In the case of the above we should see the following:</p>
<pre><code class="language-text">running 1 test
test tests::test_split_at ... FAILED

failures:

---- tests::test_split_at stdout ----
thread 'tests::test_split_at' panicked at src/lib.rs:6:9:
Intentionally failing a test to show how they work
note: run with `RUST_BACKTRACE=1` environment variable to display a backtrace


failures:
    tests::test_split_at

test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s
</code></pre>
<h2 id="testing-our-code"><a class="header" href="#testing-our-code">Testing our code</a></h2>
<p>Let’s move on to writing our actual tests, we’ll start with “split_at”.</p>
<p>Before we can write a test, <code>split_at</code> is not part of the <code>tests</code> module, so we need to make it available inside. We can
do that with the <code>use</code> statement in one of two ways, either <code>use super::split_at</code> or <code>use super::*</code>. The <code>super</code> keyword
simply means the module above this one, which for your unit tests should be the module to you’re writing tests for. We
can either bring just the one function in, or we can bring in everything available in that scope. The idiom here is that
your module ideally shouldn’t be so complicated that you can’t bring in everything, so it’s usually safe to
<code>use super::*</code>.</p>
<pre><code class="language-rust noplayground">fn split_at(input: &amp;str, at: usize) -&gt; (&amp;str, &amp;str) {
    // ...
<span class="boring">    let up_to = std::cmp::min(at, input.len()); // Prevent out of bounds
</span><span class="boring">    (&amp;input[..up_to], &amp;input[up_to..])
</span>}
 
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_split_at() {
        let input = "Hello, world!";
        let (split_left, split_right) = split_at(input, 3);
        assert_eq!(split_left, "Hel", "First 3 characters");
        assert_eq!(split_right, "lo, world!", "Rest of input");
    }
}</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=c690b50e621e51a775b9ecf2019ee663" title="" target="_blank">Link to tests</a></p>
<p>Congratulations, we now have our first working test! If you mess with the assertions, you can see how the optional
message helps us find the broken assertion faster. And if you read the optional message, it tells us the expected
behaviour… I think those of you who regularly USE non-english languages will see where the expectation doesn’t meet
the behaviour.</p>
<p>Let’s write another test for <code>split_at</code>:</p>
<pre><code class="language-rust noplayground">fn split_at(input: &amp;str, at: usize) -&gt; (&amp;str, &amp;str) {
    // ...
<span class="boring">    let up_to = std::cmp::min(at, input.len()); // Prevent out of bounds
</span><span class="boring">    (&amp;input[..up_to], &amp;input[up_to..])
</span>}
 
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_split_at() {
        // ...
<span class="boring">        let input = "Hello, world!";
</span><span class="boring">        let (split_left, split_right) = split_at(input, 3);
</span><span class="boring">        assert_eq!(split_left, "Hel", "First 3 characters");
</span><span class="boring">        assert_eq!(split_right, "lo, world!", "Rest of input");
</span>    }
    
    #[test]
    fn test_split_at_multibyte() {
        let input = "こんにちは世界！";
        let (split_left, split_right) = split_at(input, 3);
        assert_eq!(split_left, "こんに", "First 3 characters");
        assert_eq!(split_right, "ちは世界！", "Rest of input");
    }
}</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=cf9de81995dc46c807e4d08e9cc4c75b" title="" target="_blank">Link to tests</a></p>
<p>This is why setting our expectations of functionality in plain, natural language, is so important!</p>
<p>We’ve explained in the test that we expected to split at the nth character NOT the nth byte. Now that we know this
doesn’t match the expectations, we should fix our function.</p>
<p>Don’t worry too much about this next bit yet, but if you’d like an explanation of the fix</p>
<p>In order to do this, we need to find the byte number where our number of characters is met. Looking at the
documentation for <a href="https://doc.rust-lang.org/std/primitive.str.html#method.chars" title="" target="_blank">str</a> we can find there’s a method
for creating an iterator of chars. For small strings, this feels like an acceptable way to find the new place to split
our string slice. We’ll also use a method called
<a href="https://doc.rust-lang.org/std/iter/trait.Iterator.html#method.take" title="" target="_blank">
<code>take</code></a> that we can use to effectively only take the
first X characters. We’ll then <code>map</code> over each item remaining in the iterator to get its size in bytes, before summing
the number of bytes to get our new split point.</p>
<p>We no longer need the bounds check because, if the <code>at</code> is greater than the length of the string in characters, our
<code>chars</code> iterator will end before we reach the <code>take</code> limit.</p>
<pre><code class="language-rust noplayground">fn split_at(input: &amp;str, at: usize) -&gt; (&amp;str, &amp;str) {
    let byte_count = input.chars().take(at).map(|c| c.len_utf8()).sum();
    (&amp;input[..byte_count], &amp;input[byte_count..])
}
 
#[cfg(test)]
mod tests {
    // ...
<span class="boring">    use super::*;
</span><span class="boring">    
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_split_at() {
</span><span class="boring">        let input = "Hello, world!";
</span><span class="boring">        let (split_left, split_right) = split_at(input, 3);
</span><span class="boring">        assert_eq!(split_left, "Hel", "First 3 characters");
</span><span class="boring">        assert_eq!(split_right, "lo, world!", "Rest of input");
</span><span class="boring">    }
</span><span class="boring">    
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_split_at_multibyte() {
</span><span class="boring">
</span><span class="boring">        let input = "こんにちは世界！";
</span><span class="boring">        let (split_left, split_right) = split_at(input, 3);
</span><span class="boring">        assert_eq!(split_left, "こんに", "First 3 characters");
</span><span class="boring">        assert_eq!(split_right, "ちは世界！", "Rest of input");
</span><span class="boring">    }
</span>}</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=09d99c5316173b306ad23c4f938a0b54" title="" target="_blank">Link to tests</a></p>
<p>Now this test works too!</p>
<p>Let’s quickly write the tests for <code>split_around</code> and <code>split_around_many</code>:</p>
<pre><code class="language-rust noplayground">fn split_at(input: &amp;str, at: usize) -&gt; (&amp;str, &amp;str) {
    // ...
<span class="boring">    let byte_count = input.chars().take(at).map(|c| c.len_utf8()).sum();
</span><span class="boring">    (&amp;input[..byte_count], &amp;input[byte_count..])
</span>}

fn split_around&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str) -&gt; (&amp;'a str, &amp;'a str) {
    // ...
<span class="boring">  if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">    (&amp;input[..found_at], &amp;input[found_at + sub_string.len()..])
</span><span class="boring">  } else {
</span><span class="boring">    (&amp;input[..], &amp;input[input.len()..])
</span><span class="boring">  }
</span>}

fn split_around_many&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str, collection: &amp;mut Vec&lt;&amp;'a str&gt;) {
    // ...
<span class="boring">    if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">        let end_pos = found_at + sub_string.len();
</span><span class="boring">        collection.push(&amp;input[..found_at]);
</span><span class="boring">        split_around_many(&amp;input[end_pos..], sub_string, collection);
</span><span class="boring">    } else {
</span><span class="boring">        collection.push(&amp;input);
</span><span class="boring">    }
</span>}
 
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_split_at() {
        // ...
<span class="boring">        let input = "Hello, world!";
</span><span class="boring">        let (split_left, split_right) = split_at(input, 3);
</span><span class="boring">        assert_eq!(split_left, "Hel", "First 3 characters");
</span><span class="boring">        assert_eq!(split_right, "lo, world!", "Rest of input");
</span>    }
    
    #[test]
    fn test_split_at_multibyte() {
        // ...
<span class="boring">        let input = "こんにちは世界!";
</span><span class="boring">        let (split_left, split_right) = split_at(input, 3);
</span><span class="boring">        assert_eq!(split_left, "こんに", "First 3 characters");
</span><span class="boring">        assert_eq!(split_right, "ちは世界!", "Rest of input");
</span>    }
    
    #[test]
    fn test_split_around() {
        let input = "Hello, world!";
        let (split_left, split_right) = split_around(input, ", ");
        assert_eq!(split_left, "Hello", "First 3 characters");
        assert_eq!(split_right, "world!", "Rest of input");
    }

    #[test]
    fn test_split_around_multibyte() {
        let input = "こんにちは世界！";
        let (split_left, split_right) = split_around(input, "世界");
        assert_eq!(split_left, "こんにちは", "First 3 characters");
        assert_eq!(split_right, "！", "Rest of input");
    }
    
    #[test]
    fn test_split_around_many() {
        let input = "The quick brown fox jumped over the lazy dog";
        let mut collection = Vec::new();
        split_around_many(input, " ", &amp;mut collection);
        assert_eq!(collection, vec![
            "The",
            "quick",
            "brown",
            "fox",
            "jumped",
            "over",
            "the",
            "lazy",
            "dog",
        ]);
    }
    
    #[test]
    fn test_split_around_many_multibyte() {
        let input = "The quick brown キツネ jumped over the lazy 犬";
        let mut collection = Vec::new();
        split_around_many(input, " ", &amp;mut collection);
        assert_eq!(collection, vec![
            "The",
            "quick",
            "brown",
            "キツネ",
            "jumped",
            "over",
            "the",
            "lazy",
            "犬",
        ]);
    }
}</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=1192fc71d8bf6be488c241a0a7f0a827" title="" target="_blank">Link to tests</a></p>
<p>Note that we didn’t need to update the other functions for multibyte because we’re specifically looking for a substring
that either exists or doesn’t.</p>
<p>Now, what if I told you: we just did all of this backwards 😲</p>
<h2 id="test-driven-development"><a class="header" href="#test-driven-development">Test Driven Development</a></h2>
<p>So now, hopefully, you’re eager to write a load of code and then write a load of tests, but wait!</p>
<p>As we alluded to at the top of chapter, and again halfway through, the point of tests isn’t to test that your code does
what you <em>think</em> it does, it’s to make sure it does what it’s <em>supposed</em> to do.</p>
<p>The best way to achieve this is to work out what your code is supposed to do, then write the test, then write the code.
This is called Test Driven Development (TDD).</p>
<p>Let’s try some TDD. We’ll create a function that checks if a given string is a palindrome (a word that’s the same
forwards and backwards).</p>
<p>We’ll start by writing our test:</p>
<pre><code class="language-rust noplayground">#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_is_palindrome() {
        assert!(is_palindrome("kayak"));
        assert!(is_palindrome("racecar"));
        assert!(!is_palindrome("wood"));
    }
}</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=6f6409b54d8e8d3af13086a02030c3f4" title="" target="_blank">Link to tests</a></p>
<p>This won’t compile though, so in order to run our test (even though it won’t work), we need to write the function. We
don’t want to write any code inside it yet though, so we’ll use the <code>todo!()</code> macro.</p>
<pre><code class="language-rust noplayground">fn is_palindrome(_input: &amp;str) -&gt; bool {
    todo!("Implement the palindrome checker");
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_is_palindrome() {
        // ...
<span class="boring">        assert!(is_palindrome("kayak"));
</span><span class="boring">        assert!(is_palindrome("racecar"));
</span><span class="boring">        assert!(!is_palindrome("wood"));
</span>    }
}</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=64e08f5b84aaf37520679327ae0eb015" title="" target="_blank">Link to tests</a></p>
<p>We use the <code>todo!</code> macro to state we are intending to come back and fix this code soon. It works even in our function
that’s supposed to return a boolean because Rust recognises that the todo macro will kill the program, and therefore the
function can will never return.</p>
<p>We’ve also used an underscore on the front of the <code>_input</code> parameter just to let Rust know that <em>we</em> know that parameter
isn’t used yet (otherwise it’ll warn us about it).</p>
<p>Let’s think about our implementation. The string slice type doesn’t have a reverse method built in to it and even if it
did, that would require allocating memory. Instead, lets use the chars iterator like we did earlier, we’ll create two
iterators, reverse one of them, then zip them together. If every character matches its counterpart then the string is
a palindrome.</p>
<pre><code class="language-rust noplayground">fn is_palindrome(input: &amp;str) -&gt; bool {
    let forward = input.chars();
    let backward = forward.clone().rev();
    forward.zip(backward).all(|(f, b)| f == b)
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_is_palindrome() {
        assert!(is_palindrome("kayak"));
        assert!(is_palindrome("racecar"));
        assert!(!is_palindrome("wood"));
    }
}</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=29b7f57a396eef9d06d0d0c501bd3e8c" title="" target="_blank">Link to tests</a></p>
<blockquote>
<p>ℹ️ Curiously, cloning an iterator does not necessarily cause a memory allocation. In this case we’re safe, but it can
be worth checking these things when speed and efficiency are important.</p>
</blockquote>
<p>And now our test passes! But, uh-oh, when we send the code to be reviewed by a peer, they point out “racecar” isn’t a
word. They do think that “race car” (with a space) should be considered a palindrome, so we update our test, but now it
fails.</p>
<pre><code class="language-rust noplayground">fn is_palindrome(input: &amp;str) -&gt; bool {
    // ...
<span class="boring">    let forward = input.chars();
</span><span class="boring">    let backward = forward.clone().rev();
</span><span class="boring">    forward.zip(backward).all(|(f, b)| f == b)
</span>}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_is_palindrome() {
        assert!(is_palindrome("kayak"));
        assert!(is_palindrome("race car"));
        assert!(!is_palindrome("wood"));
    }
}</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=55ca613fc48720fe1b2ab48370ccf866" title="" target="_blank">Link to tests</a></p>
<p>Now we broke our test, lets fix the code. This one is easy, we just ignore anything that’s not a letter or a number.
We can do this by adding a filter to the iterator.</p>
<pre><code class="language-rust noplayground">fn is_palindrome(input: &amp;str) -&gt; bool {
    let forward = input.chars().filter(|c| c.is_alphanumeric());
    let backward = forward.clone().rev();
    forward.zip(backward).all(|(f, b)| f == b)
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_is_palindrome() {
        assert!(is_palindrome("kayak"));
        assert!(is_palindrome("race car"));
        assert!(!is_palindrome("wood"));
    }
}</code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=0b7ab806e298c477989d64dd899985b3" title="" target="_blank">Link to tests</a></p>
<p>And we’ve fixed the code. The person reviewing the code is happy, so it goes out to customers, but someone complains.
Their name is Anna, which is an anagram. We add it to the test:</p>
<pre><code class="language-rust noplayground"><span class="boring">fn is_palindrome(input: &amp;str) -&gt; bool {
</span><span class="boring">    let forward = input.chars().filter(|c| c.is_alphanumeric());
</span><span class="boring">    let backward = forward.clone().rev();
</span><span class="boring">    forward.zip(backward).all(|(f, b)| f == b)
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    
</span>#[test]
fn test_is_palindrome() {
    assert!(is_palindrome("kayak"));
    assert!(is_palindrome("race car"));
    assert!(!is_palindrome("wood"));
    assert!(is_palindrome("Anna"));
}
<span class="boring">}</span></code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=62e10f1d7a723de4637d560c5153219c" title="" target="_blank">Link to tests</a></p>
<p>Capital letters are a little more complex as an uppercase character might be the same for multiple lowercase characters.
When we call <code>.to_lowercase()</code> on a character in Rust, it will return an iterator for each character that could
conceivably be turned into that uppercase character. If we map over each character and use <code>.to_lowercase()</code> then we
have an iterator of iterators of characters. We can flatten this out with the <code>.flatten()</code> method to turn it back into
an iterator of characters. Because we use <code>.rev()</code> after this point, it should still work with strings that contain
characters that could have multiple lowercase counterparts.</p>
<pre><code class="language-rust noplayground">fn is_palindrome(input: &amp;str) -&gt; bool {
    let forward = input
        .chars()
        .filter(|c| c.is_alphanumeric())
        .map(|c| c.to_lowercase())
        .flatten();
    let backward = forward.clone().rev();
    forward.zip(backward).all(|(f, b)| f == b)
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_is_palindrome() {
</span><span class="boring">        assert!(is_palindrome("kayak"));
</span><span class="boring">        assert!(is_palindrome("race car"));
</span><span class="boring">        assert!(!is_palindrome("wood"));
</span><span class="boring">        assert!(is_palindrome("Anna"));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p><a href="https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=e012e666c1862768da409a7995116cfe" title="" target="_blank">Link to tests</a></p>
<p>This function still isn’t perfect, but it works for the given test conditions.</p>
<blockquote>
<p>If you want to continue developing this function to include things like diacritics, please do! But, you will need to
start using external crates which is out of scope of this section of the book.</p>
</blockquote>
<h2 id="how-many-tests-should-a-good-test-writer-write-if-a-good-test-writer-could-write-good-tests"><a class="header" href="#how-many-tests-should-a-good-test-writer-write-if-a-good-test-writer-could-write-good-tests">How many tests should a good test writer write if a good test writer could write good tests?</a></h2>
<p>The perennial of questions when it comes to testing: How many tests should you write?</p>
<p>The important thing here is “coverage”. Do you have a test that “covers” each line of code.</p>
<p>Take for example this really silly function:</p>
<pre><code class="language-rust noplayground">fn is_positive(num: i32) -&gt; bool {
    if num &gt; 0 {
        true
    } else {
        true
    }
}</code></pre>
<p>If we only test this function by giving it a number greater than 0, we’ll only “cover” the line first branch of the
<code>if</code>, we miss the fact there is a mistake in the second branch.</p>
<p>So what percent coverage should you aim for?</p>
<p>Anecdotally, when I was creating my own API framework in PHP, I decided I wanted to get 100% coverage, that is, every
line should have a test that hits it. The very last line that was uncovered was:</p>
<pre><code class="language-php ignore">        }
</code></pre>
<p>I wondered if it was worth the effort, decided it was. The reason this was the last uncovered line was that it was part
of a nested <code>if</code>. I’d tested what happens if you went into both <code>if</code>s, what happens if you didn’t go into the first, but
not what happens if you went into the first, but not the second.</p>
<pre><code class="language-php">function example() {
    if first_condition {
        if second_condition {
            return do_something();
        }
    } // &lt;- It was this line
    return do_something_else();
}
</code></pre>
<p>I wrote the test and… found a bug so severe that I had to rewrite almost a third of the framework. Should have written
the tests first, right?</p>
<p>My personal feelings are that you as an engineer should strive for 100% coverage of your code.</p>
<p>As a manager or engineering lead though, test coverage is a terrible metric. Test coverage doesn’t tell you if the test
was any good. If you make arbitrary metrics like this, you’re not improving code quality, engineers will write tests
that meet that metric, but don’t for-fill the reason we want tests in the first place which is to answer: “does this
code do what we want it to do?”.</p>
<p>As an engineer, it’s a matter of pride. Get your code right now, and you won’t have to deal with it later. As a leader,
make sure your engineers are encouraged to be the best they can. That means giving them the time to write tests first,
giving them access to the resources they need to learn how to write the best tests, etc.</p>
<h2 id="homework-2"><a class="header" href="#homework-2">Homework</a></h2>
<p>We’ve already let on how you can solve last chapters homework:</p>
<pre><code class="language-rust noplayground">fn split_around_many&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str, collection: &amp;mut Vec&lt;&amp;'a str&gt;) {
    if let Some(found_at) = input.find(sub_string) {
        let end_pos = found_at + sub_string.len();
        collection.push(&amp;input[..found_at]);
        split_around_many(&amp;input[end_pos..], sub_string, collection);
    } else {
        collection.push(&amp;input);
    }
}</code></pre>
<p>We only needed one lifetime to represent the link between the input string slice and the string slice inside our vector.</p>
<p>For a cleaner API though you could keep our recursive function private and expose a public function that creates the
vector for us. Because we have control of the vector in this example we can make sure we create a vector with a capacity
that is at least as large as the maximum possible entries in it. This is useful as when you create a new Vector in Rust
it has a default size, and any time you try to add an item to a vector that is already full, Rust will allocate the
memory for a new larger vector in the background, copy the data from the old location to the new location, then free the
memory in the old location.</p>
<pre><code class="language-rust noplayground">fn split_around_many_recurse&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str, collection: &amp;mut Vec&lt;&amp;'a str&gt;) {
    // ...
<span class="boring">    if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">        let end_pos = found_at + sub_string.len();
</span><span class="boring">        collection.push(&amp;input[..found_at]);
</span><span class="boring">        split_around_many_recurse(&amp;input[end_pos..], sub_string, collection);
</span><span class="boring">    } else {
</span><span class="boring">        collection.push(&amp;input);
</span><span class="boring">    }
</span>}

pub fn split_around_many&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str) -&gt; Vec&lt;&amp;'a str&gt; {
    let mut output = Vec::with_capacity(input.matches(sub_string).count());
    split_around_many_recurse(input, sub_string, &amp;mut output);
    output
}</code></pre>
<p>For the homework in this chapter, I would like you to write the tests for, and then implement the code for the following
requirements, one at a time, in this order:</p>
<ol>
<li>Create a function that will reverse the words in an English sentence.</li>
<li>If the string starts or ends with whitespace, it should be removed (trimmed) from the returned String.</li>
<li>If the string contains more than one sentence, the function should return an error (though for now, that error can
be the unit type <code>()</code>).</li>
</ol>
<p>Your function will need to allocate memory and should probably have the header:</p>
<pre><code class="language-rust ignore">fn reverse_sentence(input: &amp;str) -&gt; Result&lt;String, ()&gt;</code></pre>
<p>Here is the documentation on <a href="https://doc.rust-lang.org/std/string/struct.String.html" title="" target="_blank">String</a> and
<a href="https://doc.rust-lang.org/std/result/enum.Result.html" title="" target="_blank">Result</a></p>
<h2 id="going-forward"><a class="header" href="#going-forward">Going forward</a></h2>
<p>As I mentioned, after this chapter we will be talking about Rust differently. This will primarily be by using the assert
macros to state what a value <em>should</em> be.</p>
<p>For example, one of our earlier code examples looks like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let min_byte: u8 = 0b0000_0000;
let max_byte: u8 = 0b1111_1111;
println!("min_byte: {min_byte}"); // 0
println!("max_byte: {max_byte}"); // 255
<span class="boring">}</span></code></pre></pre>
<p>But from here on out it’ll look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let min_byte: u8 = 0b0000_0000;
let max_byte: u8 = 0b1111_1111;
assert_eq!(min_byte, 0);
assert_eq!(max_byte, 255);
<span class="boring">}</span></code></pre></pre>
<p>Now that you’ve seen the assert macros, this should be cleaner and clearer.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="documentation"><a class="header" href="#documentation">Documentation</a></h1>
<p>Documentation. Is. Awesome… in Rust.</p>
<p>Good documentation is awesome all the time but Rust provides some tools that make documenting your project a truly
magical experience. In Rust good documentation is low effort and high value.</p>
<p>Documentation is important. You’ll hear a lot of things in Software like “the code should document itself” and “the
tests should document the code”, and this is all true, but it’s not a <em>substitute</em> for documentation. Easy to understand
code is incredibly important when you work in a code base so that you can easily understand it and maintain it. And, as
we spoke about in the last chapter, tests are important to show our expectations of what the code will do when used.</p>
<p>But code and tests are not there primarily to teach someone how to use the code. They can do that, but its secondary,
meaning that someone consuming this for the purpose of learning how to use the code, is having to deal with information
they don’t need.</p>
<p>As software engineers, a huge part of our role is communication, and good documentation conveys how to use our work as
quickly, and as painlessly as possible. Rust understands this and provides a full suite of tools that make producing
documentation, not just trivial, but also fun!</p>
<h2 id="libraries"><a class="header" href="#libraries">Libraries</a></h2>
<p>In order to show the value of documentation, we’re going to create our first Rust library.</p>
<p>Up to now, we’ve been building binaries. Rust compiles <code>main.rs</code> into an executable, but our projects can link to and,
use functionality from, libraries. This is particularly helpful when sharing and reusing code. We’ll be talking much
more about how we share code with each other when we cover the Rust ecosystem, but even as we’re just learning the
language, we can leverage the power of libraries for things like code reuse within the same project.</p>
<p>Let’s try it out. First, lets make a normal program, remember you can do this with something like:
<code>cargo new iriss-documentation</code></p>
<p>In <code>main.rs</code>, we’ll make a single function and our main program will just check it works.</p>
<pre><pre class="playground"><code class="language-rust">fn add(a: usize, b: usize) -&gt; usize {
    a + b
}

fn main() {
    assert_eq!(add(40, 2), 42);
}</code></pre></pre>
<p>Next, lets migrate the add function to a library. Create a new file called <code>lib.rs</code>. In the same way that <code>main.rs</code> is
the entry to our binary, <code>lib.rs</code> is the entry point to our library. Our library acts like any other module and the
module is named the same thing as our project (though swap hyphens <code>-</code> for underscores <code>_</code>). Anything public in <code>lib.rs</code>
will be available to anyone using the library.</p>
<p>We’ll move our add function to the <code>lib.rs</code> and make it public so that we can access it from <code>main.rs</code>:</p>
<pre><code class="language-rust noplayground">// lib.rs
pub fn add(a: usize, b: usize) -&gt; usize {
    a + b
}</code></pre>
<p>We can now use this function in our main function via the project module (eg, <code>iriss_documentation</code>).</p>
<pre><code class="language-rust noplayground"><span class="boring">// This is included for `mdbook test` which I'm using to check for obvious mistakes,
</span><span class="boring">// this _should_ be in lib.rs in your project and not in a module
</span><span class="boring">mod iriss_documentation {
</span><span class="boring">    pub fn add(a: usize, b: usize) -&gt; usize {
</span><span class="boring">        a + b
</span><span class="boring">    }
</span><span class="boring">}
</span>// main.rs
use iriss_documentation::add;

fn main() {
    assert_eq!(add(40, 2), 42, "We expect 40 + 2 = 42");
}</code></pre>
<blockquote>
<p>ℹ️ Note: Although our project name  is <code>iriss-documentation</code> with a hyphen, the library name will be
<code>iriss_documentation</code> with an underscore.</p>
</blockquote>
<p>If we run our program right now, you can see that it still works but… we’re not really taking advantage of the library
though, what’s the difference between this and what we had before?</p>
<p>The main way you’re likely to share code is through Rusts package management system called Crates. Were you to publish
this project right now (please don’t though, <em>this</em> project is obviously pretty useless 😅), then theoretically other
people could use your <code>add()</code> function. But, we aren’t going to cover Crates at all in the language basics portion of
this book.</p>
<p>That doesn’t mean this technique isn’t useful though. To show how it can be useful, lets make another change to our
project.</p>
<p>Now that we’ve got our <code>lib.rs</code>, lets move <code>main.rs</code> to <code>bin/main.rs</code>. The program still runs if you use <code>cargo run</code> but
if you look closely there is a difference.</p>
<p>Before:</p>
<p><img src="language-basics/documentation/bin-before.png" alt="Before we moved to bin" /></p>
<p>After:</p>
<p><img src="language-basics/documentation/bin-after.png" alt="After we moved to bin" /></p>
<p>In the last line, you’ll see the name of the binary has changed from <code>iriss-documentation.exe</code> to <code>main.exe</code>. This is
because when the project was a single binary file, the executable was simply named after the project. By using the
<code>bin</code> directory, we’re telling Rust we expect to produce multiple binaries from this project, so now it takes the name
from the file name instead of the project.</p>
<p>To fix this, rename <code>bin/main.rs</code> to <code>bin/iriss-documentation.rs</code> and cargo will go back to creating
<code>iriss-documentation.exe</code>.</p>
<p>You can now create more binaries in this directory called different things and all of them will have access to the
library we’ve created!</p>
<p>Feel free to try this out, but bear in mind that once you have more than one file in that directory, you will have to
tell cargo which binary you want it to focus on. For example: <code>cargo run --bin iriss-documentation</code></p>
<h2 id="rustdoc"><a class="header" href="#rustdoc">rustdoc</a></h2>
<p>The Rust toolset includes a program called <code>rustdoc</code> which we can run through Cargo using <code>cargo doc</code>. It’s builds and
combines the documentation, not only from your code, but from any libraries and crates you’re using.</p>
<p>Let’s jump in and try it out with our code, if you run <code>cargo doc --open</code> it will build the documentation and then open
it in your browser. As you can see, without us doing anything rustdoc has figured out about our add function.</p>
<p><img src="language-basics/documentation/rustdoc-1.png" alt="Our documentation’s home page" /></p>
<p>You’ll notice that it’s only documented our library. This is because people consuming your code can’t use code in the
binary.</p>
<p>If you click the <code>add</code> function, it’ll take you to the documentation page. Rustdoc has already worked out the header
for the function, but that’s all the information there is for now.</p>
<p><img src="language-basics/documentation/rustdoc-2.png" alt="Add function documentation, it’s a bit bland" /></p>
<p>So how do we actually give the consumers of our library the information they need? Comments! … kinda.</p>
<h2 id="doc-comments"><a class="header" href="#doc-comments">Doc Comments</a></h2>
<p>Comments are used to communicate information to anyone reading the source code, but are completely ignored by the
compiler. We usually talk about two styles of comments:</p>
<ul>
<li>Line comments: starting at <code>//</code> and ending at the end of the line</li>
<li>Block comments: starting at <code>/*</code> and ending with <code>*/</code></li>
</ul>
<p>Many languages like Java, JavaScript, PHP, and more, also support a special type of comment called a Doc Comment. Like
comments, these are to convey information about nearby code, and are ignored by the compiler, however you can use
documentation tooling to read them and produce the documentation for you.</p>
<p>Rust takes this idea and turbocharges it… but we’ll get to that.</p>
<p>For now, there are two subtypes of Doc Comments:</p>
<ul>
<li>Outer Doc Comments</li>
<li>Inner Doc Comments</li>
</ul>
<p>It’s possible to create these comments as either line comments or block comments <em>however</em>, the convention<sup class="footnote-reference"><a href="#rfc1574">1</a></sup> is
to always use line comments, even if the comment spans many lines. The reason for this appears to be ambiguity in
terminating block comments, and the desire for consistency.</p>
<p>Outer Doc Comments are placed before the thing that’s being documented and use <code>///</code> for each line of the comment, and
we’ll use them for most things like modules, types and our <code>add()</code> function.</p>
<pre><code class="language-rust noplayground">/// Adds two numbers together.
pub fn add(a: usize, b: usize) -&gt; usize {
    a + b
}</code></pre>
<p>We can re-run <code>cargo doc</code> and refresh the page in our browser and our <code>add</code> function now has a little explanation.</p>
<p><img src="language-basics/documentation/rustdoc-3.png" alt="add() description" /></p>
<p>That’s neat, but we could have worked that out from the name. Rust documentation uses markdown, which means we can
use formatting and code snippets, as well as consecutive lines being treated as a single paragraph. Let’s add some more
detail and explain how to use the function using the same technique we learned in the last chapter, assertions.</p>
<p>Doing it this way may seem odd, but all will be explained in a moment.</p>
<pre><code class="language-rust noplayground">/// Adds two numbers together.
///
/// You can use this function to add two `usize` numbers together. It's a little bit pointless, obviously, we're only
/// doing this to demonstrate the benefits of good documentation.
///
/// ```
/// use iriss_documentation::add;
///
/// let a = 40;
/// let b = 2;
/// let c = add(a, b);
///
/// assert_eq!(c, 42, "We expect {a} + {b} = 42");
/// ```
pub fn add(a: usize, b: usize) -&gt; usize {
    a + b
}</code></pre>
<p>Rebuilding our documentation now gives us the code sample too, isn’t that cute!</p>
<p><img src="language-basics/documentation/rustdoc-4.png" alt="add() with code sample" /></p>
<p>What’s also cool, is that if we go back to the top level of our library where our <code>add</code> function was listed, you can
see that <code>add</code> now has a nice little summary, it’s the first line of our documentation. This is worth bearing in mind
as you write your documentation. Try to keep this line terse but descriptive.</p>
<p><img src="language-basics/documentation/rustdoc-5.png" alt="Summary of add()" /></p>
<p>Before we move on, we should also provide some documentation for our library. We can’t put Outer Doc Comments before the
library because the library <em>is</em> the file. Instead, we use Inner Doc Comments, which are prefixed with <code>//!</code>. We do this
at the top of the file. Let’s provide a little</p>
<pre><code class="language-rust ignore">//! This library does little more than provide us a way of playing with documentation
//!
//! We can use all kinds of markdown in Doc Comments, including:
//!
//! Various
//! =======
//!
//! Heading
//! -------
//!
//! ### Styles
//!
//! Horizontal lines
//!
//! ---
//!
//! And even code!
//!
//! ```
//! println!("Hello, world!");
//! ```

/// ...
pub fn add(a: usize, b: usize) -&gt; usize { /* ... */ }</code></pre>
<p>And all of this will render nicely into our documentation.</p>
<p><img src="language-basics/documentation/rustdoc-6.png" alt="Top level documentation" /></p>
<blockquote>
<p>ℹ️ Note: You can use Inner Doc Comments for all sorts of things, like modules that are in curly brackets. But, again,
the convention<sup class="footnote-reference"><a href="#rfc1574">1</a></sup> is to only use Inner Doc Comments for files, whether thats your main library file, or module
files (eg, <code>my_module/mod.rs</code>, or <code>./my_module.rs</code>).</p>
</blockquote>
<h2 id="doc-tests"><a class="header" href="#doc-tests">Doc-Tests</a></h2>
<p>Some people say tests should be the documentation, but here we say the documentation should be the tests!</p>
<p>Well, ok, not <em>the</em> test, you absolutely should still write your unit tests, etc. 😅</p>
<p>But without doing anything else to our project, try running <code>cargo test</code>.</p>
<p><img src="language-basics/documentation/doc-tests.png" alt="Doc-Tests" /></p>
<p>There’s a few things to notice here.</p>
<p>First, we seem to be getting three sets of tests. Second, we have two passing tests… but we didn’t write any tests,
did we?</p>
<p>The order of test suites, and individual tests you see may differ from the above, but you should have one test suite
for our library (<code>lib.rs</code>), one test suite for our binary (<code>iriss-documentation.rs</code>), and one for Doc-tests. The first
two have no tests, but Doc-tests have two tests.</p>
<p>What’s happened here is that <code>cargo test</code> is treating any code samples as tests (unless we ask it not to).</p>
<p>Let’s quickly add a test to <code>lib.rs</code> to look more closely at the difference.</p>
<pre><code class="language-rust ignore">//! ...

/// ...
pub fn add(a: usize, b: usize) -&gt; usize { /* ... */ }

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        let a = 40;
        let b = 2;
        let c = add(a, b);

        assert_eq!(c, 42, "We expect {a} + {b} = 42");
    }
}
</code></pre>
<p>Now when we run again we get some interesting comparison.</p>
<p>Unit Tests:</p>
<p><img src="language-basics/documentation/doc-tests-comparison-unit.png" alt="Unit Tests" /></p>
<p>Doc Tests:</p>
<p><img src="language-basics/documentation/doc-tests-comparison-doc.png" alt="Doc Tests" /></p>
<p>In the unit test, the test name is the fully qualified path to the test function (<code>test::test_add</code>)</p>
<p>In the doc tests, it’s the file, the name of the thing being documented (unless it <em>is</em> the file) and the line of the
start of the code block.</p>
<p>This makes them slightly less useful <em>as</em> tests. So why would we do it?</p>
<p>Well, the leading cause of bad documentation, and the reason why people so often don’t bother writing it to start with
is that it needs to be maintained. One of the worst things we can do in documentation is tell someone they can achieve
an outcome in a particular way, then change the code so that particular way no longer works as expected.</p>
<p>Writing our documentation as test ensures that our documentation is correct, and keeping our documentation right next
to the thing being documented makes it trivial to update. Rust guarantees that if you said the code works in a
particular way, so long as you also wrote an example with assertions, then the documentation is correct!</p>
<h2 id="sharing-documentation"><a class="header" href="#sharing-documentation">Sharing Documentation</a></h2>
<p>To paraphrase Dr Strangelove: Of course, the whole point of <strong>documentation</strong> is lost, if you keep it a secret!</p>
<p>How do we tell people about our documentation?</p>
<p>There’s two ways documentation gets shared and neither of them require any work on your behalf.</p>
<p>We’ll go into this a further in the ecosystem section of the book, however when you’re ready to share your code, we
use cargo to “publish” the code to <a href="https://crates.io" title="" target="_blank">crates.io</a>. When someone downloads your code from there, they
get the source code which includes your documentation. This means when they build their documentation, they can also
build your documentation.</p>
<p>The second way our documentation is shared is that when we publish to crates.io, our documentation is compiled and
uploaded to another service, <a href="https://docs.rs" title="" target="_blank">docs.rs</a>. On this service you can find every version of API documentation
for every crate (library) ever published!</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>So Rust documentation has some really compelling things going on:</p>
<ol>
<li>Documentation tooling comes with the rust tool suite</li>
<li>Documentation is written with code, not separately from it</li>
<li>Code examples are run with tests, meaning it’s very hard to produce documentation that’s wrong</li>
</ol>
<p>Because the prescribed method of writing documentation is so good, everyone ends up using the same tools and the same
conventions, which means Rust documentation will always feel somewhat familiar, significantly reducing the burden of
learning.</p>
<p>It’s one of the many examples of how the Rust community feeds into itself, helping us all be better software engineers.</p>
<h2 id="homework-3"><a class="header" href="#homework-3">Homework</a></h2>
<p>In the last chapter, we asked you to do three things, one at a time, starting with the test and then writing the
implementation.</p>
<ol>
<li>Create a function that will reverse the words in an English sentence.</li>
<li>If the string starts or ends with whitespace, it should be removed (trimmed) from the returned String.</li>
<li>If the string contains more than one sentence, the function should return an error (though for now, that error can
be the unit type <code>()</code>).</li>
</ol>
<blockquote>
<p>Please note an earlier version of this book had 4 requirements, the second one has been removed. See the
<a href="https://www.youtube.com/watch?v=MLTy-UmLCnk?t=856" title="" target="_blank">homework section of this chapters video</a> to see how it can be
solved, and why I chose to remove it.</p>
</blockquote>
<p>We want to start with the test, but we can’t create the test without the function existing, so the easiest way to
proceed is to design the interface of the function and use the <code>todo!</code> macro so that we can integrate it into a test.
We know later we’ll want to return an Error, so we’ve got a string slice input, and a Result output where the Ok variant
is a <code>String</code>.</p>
<pre><code class="language-rust noplayground">fn reverse_sentence(_input: &amp;str) -&gt; Result&lt;String, ()&gt; {
    todo!("Write the reverse_sentence function")
}</code></pre>
<p>We then create our first test, but because our first requirement doesn’t tell us too much, we’ll keep it simple; all
lowercase, no punctuation.</p>
<pre><code class="language-rust noplayground"><span class="boring">fn reverse_sentence(_input: &amp;str) -&gt; Result&lt;String, ()&gt; {
</span><span class="boring">    todo!("Write the reverse_sentence function")
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_reverse_words() {
        let input = "this is my test input";
        let output = reverse_sentence(input);
        assert_eq!(output, Ok("input test my is this".to_string()));
    }
}</code></pre>
<p>Now that we have a failing test, lets fix the code. I’m going to use our split_around_many function but if you used the
built-in split function instead, well done, bonus points to you! It’s actually more efficient that way, and you can in
fact reduce the memory allocations down to just one.</p>
<p>I decided to stick with our existing functions for simplicity. We can split the string around spaces to get a vector of
words, then we can call reverse on the vector to get the words in the opposite order. Finally, we can join the vector of
strings with spaces to create our output string.</p>
<pre><code class="language-rust noplayground"><span class="boring">fn split_around_many_recurse&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str, collection: &amp;mut Vec&lt;&amp;'a str&gt;) {
</span><span class="boring">    if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">        let end_pos = found_at + sub_string.len();
</span><span class="boring">        collection.push(&amp;input[..found_at]);
</span><span class="boring">        split_around_many_recurse(&amp;input[end_pos..], sub_string, collection);
</span><span class="boring">    } else {
</span><span class="boring">        collection.push(&amp;input);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn split_around_many&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut output = Vec::with_capacity(input.matches(sub_string).count());
</span><span class="boring">    split_around_many_recurse(input, sub_string, &amp;mut output);
</span><span class="boring">    output
</span><span class="boring">}
</span><span class="boring">
</span>fn reverse_sentence(input: &amp;str) -&gt; Result&lt;String, ()&gt; {
    let mut words: Vec&lt;&amp;str&gt; = split_around_many(input, " ");
    words.reverse();
    Ok(words.join(" "))
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_reverse_words() {
</span><span class="boring">        let input = "this is my test input";
</span><span class="boring">        let output = reverse_sentence(input);
</span><span class="boring">        assert_eq!(output, Ok("input test my is this".to_string()));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Now the test passes.</p>
<p>Next lets look at trimming the string.</p>
<p>In the requirements I did say “any whitespace” so lets test with a space on one end and a tab on the other.</p>
<pre><code class="language-rust noplayground"><span class="boring">fn split_around_many_recurse&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str, collection: &amp;mut Vec&lt;&amp;'a str&gt;) {
</span><span class="boring">    if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">        let end_pos = found_at + sub_string.len();
</span><span class="boring">        collection.push(&amp;input[..found_at]);
</span><span class="boring">        split_around_many_recurse(&amp;input[end_pos..], sub_string, collection);
</span><span class="boring">    } else {
</span><span class="boring">        collection.push(&amp;input);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn split_around_many&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut output = Vec::with_capacity(input.matches(sub_string).count());
</span><span class="boring">    split_around_many_recurse(input, sub_string, &amp;mut output);
</span><span class="boring">    output
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn reverse_sentence(input: &amp;str) -&gt; Result&lt;String, ()&gt; {
</span><span class="boring">    let mut words: Vec&lt;&amp;str&gt; = split_around_many(input, " ");
</span><span class="boring">    words.reverse();
</span><span class="boring">    Ok(words.join(" "))
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    // ...
<span class="boring">    #[test]
</span><span class="boring">    fn test_reverse_words() {
</span><span class="boring">        let input = "this is my test input";
</span><span class="boring">        let output = reverse_sentence(input);
</span><span class="boring">        assert_eq!(output, Ok("input test my is this".to_string()));
</span><span class="boring">    }
</span>
    #[test]
    fn test_reverse_words_trims_string() {
        let input = " this string has weird whitespace\t";
        let output = reverse_sentence(input);
        assert_eq!(output, Ok("whitespace weird has string this".to_string()));
    }
}</code></pre>
<p>Again, this test won’t pass when we run it, so lets implement the feature.</p>
<p>String slices have a <a href="https://doc.rust-lang.org/std/primitive.str.html#method.trim" title="" target="_blank">method called <code>.trim()</code></a>, which will
return a string slice that points to the characters inside the original string slice without surrounding whitespace.
This is really cool because it means we didn’t need to allocate any more memory. We can also shadow the <code>input</code>
variable, so we only need to add one line to the function!</p>
<pre><code class="language-rust noplayground"><span class="boring">fn split_around_many_recurse&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str, collection: &amp;mut Vec&lt;&amp;'a str&gt;) {
</span><span class="boring">    if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">        let end_pos = found_at + sub_string.len();
</span><span class="boring">        collection.push(&amp;input[..found_at]);
</span><span class="boring">        split_around_many_recurse(&amp;input[end_pos..], sub_string, collection);
</span><span class="boring">    } else {
</span><span class="boring">        collection.push(&amp;input);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn split_around_many&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut output = Vec::with_capacity(input.matches(sub_string).count());
</span><span class="boring">    split_around_many_recurse(input, sub_string, &amp;mut output);
</span><span class="boring">    output
</span><span class="boring">}
</span><span class="boring">
</span>fn reverse_sentence(input: &amp;str) -&gt; Result&lt;String, ()&gt; {
    let input = input.trim();
    let mut words: Vec&lt;&amp;str&gt; = split_around_many(input, " ");
    words.reverse();
    Ok(words.join(" "))
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_reverse_words() {
</span><span class="boring">        let input = "this is my test input";
</span><span class="boring">        let output = reverse_sentence(input);
</span><span class="boring">        assert_eq!(output, Ok("input test my is this".to_string()));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_reverse_words_trims_string() {
</span><span class="boring">        let input = " this string has weird whitespace\t";
</span><span class="boring">        let output = reverse_sentence(input);
</span><span class="boring">        assert_eq!(output, Ok("whitespace weird has string this".to_string()));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>The final requirement is to return an error if there is more than one sentence. We haven’t dealt with punctuation yet
so let’s create an assertion that an ending dot is fine, and a second assertion that one in the middle of a sentence
causes an error. The first assertion should pass without any changes, but helps make sure we don’t break this as we
implement feature.</p>
<pre><code class="language-rust noplayground"><span class="boring">fn split_around_many_recurse&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str, collection: &amp;mut Vec&lt;&amp;'a str&gt;) {
</span><span class="boring">    if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">        let end_pos = found_at + sub_string.len();
</span><span class="boring">        collection.push(&amp;input[..found_at]);
</span><span class="boring">        split_around_many_recurse(&amp;input[end_pos..], sub_string, collection);
</span><span class="boring">    } else {
</span><span class="boring">        collection.push(&amp;input);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn split_around_many&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut output = Vec::with_capacity(input.matches(sub_string).count());
</span><span class="boring">    split_around_many_recurse(input, sub_string, &amp;mut output);
</span><span class="boring">    output
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn reverse_sentence(input: &amp;str) -&gt; Result&lt;String, ()&gt; {
</span><span class="boring">    let input = input.trim();
</span><span class="boring">    let mut words: Vec&lt;&amp;str&gt; = split_around_many(input, " ");
</span><span class="boring">    words.reverse();
</span><span class="boring">    Ok(words.join(" "))
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    // ...
<span class="boring">    #[test]
</span><span class="boring">    fn test_reverse_words() {
</span><span class="boring">        let input = "this is my test input";
</span><span class="boring">        let output = reverse_sentence(input);
</span><span class="boring">        assert_eq!(output, Ok("input test my is this".to_string()));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_reverse_words_trims_string() {
</span><span class="boring">        let input = " this string has weird whitespace\t";
</span><span class="boring">        let output = reverse_sentence(input);
</span><span class="boring">        assert_eq!(output, Ok("whitespace weird has string this".to_string()));
</span><span class="boring">    }
</span>
    #[test]
    fn test_reverse_words_reject_multiple_sentances() {
        let input = "sentance one.";
        let output = reverse_sentence(input);
        assert_eq!(output, Ok("one. sentance".to_string()));

        let input = "sentance one. sentance two";
        let output = reverse_sentence(input);
        assert_eq!(output, Err(()));
    }
}</code></pre>
<p>To implementing this feature, we can check the words iterator after the split, but before the reverse, for any full
stops that occur before the final word. To do this we’ll iterate over the vector, taking all but the last element, and
if any word ends with a <code>.</code> we can assume it’s a sentence break.</p>
<pre><code class="language-rust noplayground"><span class="boring">fn split_around_many_recurse&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str, collection: &amp;mut Vec&lt;&amp;'a str&gt;) {
</span><span class="boring">    if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">        let end_pos = found_at + sub_string.len();
</span><span class="boring">        collection.push(&amp;input[..found_at]);
</span><span class="boring">        split_around_many_recurse(&amp;input[end_pos..], sub_string, collection);
</span><span class="boring">    } else {
</span><span class="boring">        collection.push(&amp;input);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn split_around_many&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut output = Vec::with_capacity(input.matches(sub_string).count());
</span><span class="boring">    split_around_many_recurse(input, sub_string, &amp;mut output);
</span><span class="boring">    output
</span><span class="boring">}
</span><span class="boring">
</span>fn reverse_sentence(input: &amp;str) -&gt; Result&lt;String, ()&gt; {
    let input = input.trim();
    let mut words: Vec&lt;&amp;str&gt; = split_around_many(input, " ");
    
    if words
        .iter()
        .take(words.len() - 1)
        .any(|word| word.ends_with('.'))
    {
        return Err(());
    }
    
    words.reverse();
    Ok(words.join(" "))
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_reverse_words() {
</span><span class="boring">        let input = "this is my test input";
</span><span class="boring">        let output = reverse_sentence(input);
</span><span class="boring">        assert_eq!(output, Ok("input test my is this".to_string()));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_reverse_words_trims_string() {
</span><span class="boring">        let input = " this string has weird whitespace\t";
</span><span class="boring">        let output = reverse_sentence(input);
</span><span class="boring">        assert_eq!(output, Ok("whitespace weird has string this".to_string()));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_reverse_words_reject_multiple_sentances() {
</span><span class="boring">        let input = "sentance one.";
</span><span class="boring">        let output = reverse_sentence(input);
</span><span class="boring">        assert_eq!(output, Ok("one. sentance".to_string()));
</span><span class="boring">
</span><span class="boring">        let input = "sentance one. sentance two";
</span><span class="boring">        let output = reverse_sentence(input);
</span><span class="boring">        assert_eq!(output, Err(()));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Were we doing this properly, of course we’d use proper errors… but proper errors are for another time 😉</p>
<p>This time for the homework, I’d like you to create a library that contains our three split functions from the last few
chapters (I’ve rewritten them below, use the 👁️ icon to show hidden lines).</p>
<pre><code class="language-rust noplayground">pub fn split_at(input: &amp;str, at: usize) -&gt; (&amp;str, &amp;str) {
<span class="boring">    let up_to = std::cmp::min(at, input.len()); // Prevent out of bounds
</span><span class="boring">    (&amp;input[..up_to], &amp;input[up_to..])
</span>}

pub fn split_around&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str) -&gt; (&amp;'a str, &amp;'a str) {
<span class="boring">    if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">      (&amp;input[..found_at], &amp;input[found_at + sub_string.len()..])
</span><span class="boring">    } else {
</span><span class="boring">      (&amp;input[..], &amp;input[input.len()..])
</span><span class="boring">    }
</span>}

<span class="boring">fn split_around_many_recurse&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str, collection: &amp;mut Vec&lt;&amp;'a str&gt;) {
</span><span class="boring">    if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">        let end_pos = found_at + sub_string.len();
</span><span class="boring">        collection.push(&amp;input[..found_at]);
</span><span class="boring">        split_around_many_recurse(&amp;input[end_pos..], sub_string, collection);
</span><span class="boring">    } else {
</span><span class="boring">        collection.push(&amp;input);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn split_around_many&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str) -&gt; Vec&lt;&amp;'a str&gt; {
<span class="boring">    let mut output = Vec::with_capacity(input.matches(sub_string).count());
</span><span class="boring">    split_around_many_recurse(input, sub_string, &amp;mut output);
</span><span class="boring">    output
</span>}</code></pre>
<p>You can make a library directly with no executable with <code>cargo new --lib &lt;name&gt;</code> where <name> is whatever you want to
call it, this saves you moving things around too much.</p>
<p>Write documentation for the functions that explains how they work with code samples and assertions. Note that the
<code>split_around_many_recurse</code> function probably shouldn’t be public, so you won’t see it in your library documentation.</p>
<div class="footnote-definition" id="rfc1574"><sup class="footnote-definition-label">1</sup>
<p>https://rust-lang.github.io/rfcs/1574-more-api-documentation-conventions.html</p>
</div>
<div style="break-before: page; page-break-before: always;"></div><h1 id="clippy-and-fmt"><a class="header" href="#clippy-and-fmt">Clippy and Fmt</a></h1>
<p>The Rust ecosystem has a wealth of tools that support us when writing Rust but there are two important tools I want to
cover at this point:</p>
<ul>
<li><code>rustfmt</code> - Pronounced Rust Format, helps us keep our code styles consistent, so that its easy to share your code or
read and learn from someone else’s.</li>
<li><code>clippy</code> - Named after the old Microsoft Office tool, helps spot common mistakes, antipatterns, and even make
suggestions on things like performance, scalability or readability improvements.</li>
</ul>
<p>I also want to talk a little bit about <code>cargo check</code> and how we can use all of these tools together to make sure our
work is always the best we can make it!</p>
<h2 id="rustfmt"><a class="header" href="#rustfmt">rustfmt</a></h2>
<p><code>rustfmt</code> is a formatting tool for Rust. Programming language formatting tools allow you to configure how you want your
code to look. For example:</p>
<ul>
<li>
<p>Do you like opening curly brakets on the end of a line, like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn example() {
    // ...
}
<span class="boring">}</span></code></pre></pre>
<p>or on a new line like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn example()
{
    // ...
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Do you indent with four spaces:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn hello() {
    println!("Hello");  
}
<span class="boring">}</span></code></pre></pre>
<p>or two:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn hello() {
  println!("Hello");  
}
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>Does the last item in a list across multiple lines have a trailing comma:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let list = [
    "one",
    "two",
];
<span class="boring">}</span></code></pre></pre>
<p>or not:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let list = [
    "one",
    "two"
];
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p>How many empty lines are allowed between lines of code in a function?</p>
</li>
<li>
<p>etc…</p>
</li>
</ul>
<p>Maintaining a consistent style improves the legibility of code, making it faster for engineers to read and understand
what’s happening. This is true, even if you only write code for yourself, using familiar patterns reduces the cognitive
load to parse what you’re looking at. When working together as a group, it’s important to come to an agreement as to
how you will style your code together, but luckily a Formatter will reduce the burden of having to maintain the style
once you’ve picked what to use.</p>
<p>Different languages have different “styles” that they follow. Some older languages may have multiple well established
styles to choose from. Luckily there’s an official <a href="https://doc.rust-lang.org/nightly/style-guide/" title="" target="_blank">Rust Style Guide</a>
that gives us a compelling reason in the community to all write code the same way, and Rust comes with its own formatter
called “Rust Format” that will automatically maintain the style for you!</p>
<p>You can call Rust Format manually using <code>cargo fmt</code> and it will automatically reformat your entire project, however its
definitely best if you can set your IDE to automatically run it any time you save a file. This will save you any big
unexpected changes.</p>
<p>If you just want it to tell you if anything is incorrectly formatted, you can use <code>cargo fmt --check</code>. We’ll come back
to this later!</p>
<p>Finally, it might be that you and your team find some aspect of the official Rust Style Guide particularly egregious,
that’s fine! Rust Format allows you to configure how it will format your code through <code>rustfmt.toml</code>. You can find
a complete guide to what you can control, and how, here:
<a href="https://rust-lang.github.io/rustfmt/" title="" target="_blank">https://rust-lang.github.io/rustfmt/</a></p>
<p><code>rustfmt</code> now comes with the rust tool suite by default, but if for some reason you don’t have it, you can install it
with <code>rustup component add rustfmt</code></p>
<h2 id="clippy"><a class="header" href="#clippy">clippy</a></h2>
<p>Clippy is Rust’s linter, a tool that can not only make sure your code is correct (<code>rustc</code> technically already does
<em>that</em> for you) but even offer suggestions on how to improve your code, and explain why an alternative might be better!</p>
<p>To run Clippy with the default configuration, simply type <code>cargo clippy</code></p>
<p>This is an incredibly powerful tool, not just for making sure your code is the best it can be, but as an aid for
learning.</p>
<p>Antithetical to that, though still incredibly useful, Clippy can go right ahead and fix many of the common issues it
might find, simply by passing the <code>--fix</code> flag (eg: <code>cargo clippy --fix</code>). Obviously I recommend making sure you
understand the changes it’s suggesting before allowing it to proceed.</p>
<p>And, Clippy won’t just check your code either, it can also spot common mistakes in your documentation (we love
documentation here if you couldn’t tell 😅). For example, if in your doc comments you use underscores <code>_</code> or double
colons <code>::</code> outside of backticks, Clippy will assume this is a mistake and let you know.</p>
<p>There’s a lot of flexibility in how you can configure Clippy. Lints are broken up into groups for easy control, so we
typically might decide at the group level, what to include, and whether it should be considered a warning or completely
denied. For example, I tend to include a group of lints called <code>pedantic</code>  with a warning (these are usually allowed by
clippy which means you don’t get told if there is a potential issue).</p>
<p>To do this you can either:</p>
<ul>
<li>run: <code>cargo clippy -- -W clippy::pedantic</code> or…</li>
<li>in your entry file to my project (eg, <code>main.rs</code>, or <code>lib.rs</code>) you can add the line:
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![warn(clippy::pedantic)]
<span class="boring">fn main() {
</span><span class="boring">}</span></code></pre></pre>
</li>
</ul>
<p>The benefit of the latter is you can set a nice default for the project without you or anyone else needing to remember
what options to pass to Clippy, while the former is useful if you want to override that or any other behaviour.</p>
<p>For a full list of lints, check the list here:
<a href="https://rust-lang.github.io/rust-clippy/master/index.html#/Configuration" title="" target="_blank">https://rust-lang.github.io/rust-clippy/master/index.html#/Configuration</a></p>
<p>Clippy now comes with the rust tool suite by default, but if for some reason you don’t have it, you can install it with
<code>rustup component add clippy</code>.</p>
<h2 id="cargo-check"><a class="header" href="#cargo-check">Cargo Check</a></h2>
<p>There’s one last tool I want to mention quickly, and it will initially seem quite underwhelming by comparison to the
others, but stick with me.</p>
<p><code>cargo check</code> is a tool which will… check your code and all its dependencies for errors. Groundbreaking, right?</p>
<p>But, we’d find out that our code has errors when we try to build it with <code>cargo build</code>, so what’s the point of
<code>cargo check</code>? Well, <code>cargo check</code> essentially does the same job as <code>cargo build</code> but skips the final step of code
generation. This means it’s faster, and importantly, cheaper to perform, so it can be used as a fast-fail.</p>
<p>The work it does isn’t wasted either. Because it does in fact perform some of the compilation steps, the output of this
is cached on your machine so that other tools (such as <code>cargo build</code> and Clippy) can use that to skip earlier steps in
their own processes.</p>
<p>This might not seem very useful on your machine, but it comes in very handy with Continuous Integration.</p>
<h2 id="continuous-integration"><a class="header" href="#continuous-integration">Continuous Integration</a></h2>
<p>Continuous Integration (CI) is a technique that we use to maintain high quality, robust, and “correct” code in our code
base. CI is usually used to help control what goes into your Version Control Systems (VCS), where you might be storing
your code.</p>
<p>Version Control Systems like Git, Mercurial, Subversion (SVN), etc., are out of scope for this book, however, if you
haven’t already, you should learn to use one of these as quickly as possible. I can’t tell you which to use though as it
depends on what kind of application you’re building. Git is very common, and it’s what I use for this book, but it’s
better for things that are being <em>primarily</em> built from text based resources, like websites, or desktop application.
If you’re making games or something that uses a lot of images or other non-text based assets though you might want to
use Plastic or Perforce.</p>
<p>Whatever you choose, you can use Continuous Integration to make sure that every time you make changes, those changes
make your project better, and minimise the risk of them making things worse.</p>
<p>How you achieve this will vary depending on not only what VCS you use, but potentially who hosts it. GitLab CI is
very different from GitHub Actions. The main idea however is to run a set of instructions before allowing changes to
be integrated (or merged) into the main project.</p>
<p>For example, a typical Git workflow might have a <code>main</code> branch. When you come to do some work, you’d create a new branch
based on what’s currently in <code>main</code> and name it something relevant to the work you’re going to do (for example, as I
write this chapter of the book, I’m on a branch called <code>clippy-and-fmt</code>). When you’re happy with your code, you would
merge your branch with <code>main</code> and <code>main</code> would get all of your changes. This is where CI helps, it makes sure that
whatever you’re doing on your branch is up to the level of quality that is expected of code in <code>main</code>.</p>
<p>We can use the tools we’ve talked about in this and previous chapters to create a CI workflow.</p>
<p>Roughly what we want to do is:</p>
<ol>
<li>
<p>run <code>cargo check</code>, if this fails, there’s not a lot of point in continuing, so we get our results faster</p>
</li>
<li>
<p>run <code>cargo fmt --check</code> which will make sure code abides by our style guide without changing anything</p>
</li>
<li>
<p>run <code>cargo clippy -- -D warnings</code> which error if there are any warnings from clippy</p>
<blockquote>
<p>Remember, although warnings don’t necessarily mean something is actually wrong, you should try to make sure you
to fix them all anyway as the more irrelevant warnings you’re outputting, the more likely it is that you’ll miss
something that is relevant!</p>
</blockquote>
</li>
<li>
<p><code>cargo test</code> will run all tests and doc tests</p>
</li>
<li>
<p><code>cargo build</code> will make sure your code actually compiles</p>
<blockquote>
<p>This can also be very useful in Continuous Deployment (CD) processes, after merging to main, allowing you to
immediately deploy your latest code automatically</p>
</blockquote>
</li>
</ol>
<p>Running all of this one after the other can be very time-consuming, but some of it can be run in parallel.</p>
<p><code>cargo check</code> and <code>cargo fmt --check</code> do not depend on anything else, and can act as fast fails, letting you know that
it’s not worth continuing the process.</p>
<p><code>cargo test</code> and <code>cargo clippy -- -D warnings</code> are only going to work if <code>cargo check</code> also works, so as soon as
<code>cargo check</code> is complete, we can start working on them</p>
<p>Finally, once <code>cargo test</code> and <code>cargo clippy</code> have succeeded, we can move to the final check, <code>cargo build</code>. At this
point, everything that could be caught should have been caught so there should be no surprises which means we might as
well wait for <code>cargo fmt</code> to complete too.</p>
<p>This gives us this order of events:</p>
<p><img src="language-basics/./clippy-and-fmt/rust-ci.svg" alt="rust-ci.svg" /></p>
<p>Depending on your CI suite though, it might be that each of these tasks runs in isolation. For example, it might run
each step in a docker container. But, <code>cargo check</code> is going to do a lot of hard work some of the other steps can use.
This is where its worth learning your CI suite’s caching process, so that you can cache the output of the <code>cargo check</code>
step.</p>
<p><img src="language-basics/./clippy-and-fmt/rust-ci-with-cache.svg" alt="rust-ci-with-cache.svg" /></p>
<h2 id="next-chapter"><a class="header" href="#next-chapter">Next Chapter</a></h2>
<p>Next we’re going to explain how to add functionality to types, why that’s useful and show off some real power moves of
the type system.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="giving-types-functionality"><a class="header" href="#giving-types-functionality">Giving types functionality</a></h1>
<p>Next we’re going to learn how to add functionality to data by modelling a common emotional pattern followed by my cat,
Yuki.</p>
<h2 id="yuki-states"><a class="header" href="#yuki-states">Yuki States</a></h2>
<p>We’ll model 3 emotional states of my Cat, give him behaviours unique to each state, and allow him to transition between
those states.</p>
<style>
  img {
    display: block;
    margin: 0 auto;
  }
</style>
<p><img src="language-basics/./impl/YukiStateMachine.svg" alt="YukiStateMachine.svg" /></p>
<p>So what is the behaviour we want to model in these states?</p>
<h3 id="mischievous"><a class="header" href="#mischievous">Mischievous</a></h3>
<ul>
<li>We’ll initialise Yuki in the Mischievous state because that’s how he wakes up.</li>
<li>In this state he’ll make a lot of fun little noises</li>
<li>He’ll also try to get up to various naughtiness</li>
<li>If we forget to feed him he’ll get Hangry</li>
</ul>
<h3 id="hangry-hungry-and-angry"><a class="header" href="#hangry-hungry-and-angry">Hangry (Hungry and Angry)</a></h3>
<ul>
<li>While hangry, he only really makes one noise, a desperate plea to “pay attention and do your job”</li>
<li>He’ll get hyper focused on you getting your attention and may choose violence</li>
<li>Once he’s eaten, he’ll get Eepy</li>
</ul>
<h3 id="eepy-sleepy"><a class="header" href="#eepy-sleepy">Eepy (Sleepy)</a></h3>
<ul>
<li>Once he’s eaten, he’ll get sleepy, he won’t make any noises he’ll just settle down in one of his beds</li>
<li>Once he’s slept, he’ll get back to his mischeivous state</li>
</ul>
<h2 id="making-a-cat"><a class="header" href="#making-a-cat">Making a Cat</a></h2>
<p>Let’s create a new project with <code>cargo new yuki-state-machine</code> and open it in our IDE of choice.</p>
<p>For this project we’re going to need to organise our code a bit. We’ve talked a little bit about modules before, they’re
Rust’s way of organising and grouping code. We’ve created modules to contain tests, that we’ve then excluded from our
build. You can create them with the <code>mod</code> keyword, then a name, then either:</p>
<ul>
<li>a block of code surrounded by curly brackets</li>
<li>a file called the same thing as the module (e.g. <code>mod my_module</code> and a file called <code>my_module.rs</code>)</li>
<li>a directory called the same thing as the module and a file called <code>mod.rs</code> (e.g. <code>mod my_module</code> and a file called
<code>my_module/mod.rs</code>)</li>
</ul>
<p>We’re going to use all of these techniques in this project, though only the latter two today.</p>
<p>To organise our cat code away from the main binary, lets create a cat module inside our main file, so it looks something
like this:</p>
<pre><code class="language-rust ignore">// File: main.rs

mod cat;

fn main() {
    println!("Hello, world!");
}</code></pre>
<p>If you’re using VSCode, RustRover or similar, you might be able to use the context menu to create <code>cat.rs</code> by
putting the cursor over <code>cat</code> and activating the context actions (in VSCode that’s <code>Ctrl</code>/<code>⌘</code> + <code>.</code>, in IntelliJ
products like RustRover it’s <code>Alt</code>/<code>⌥</code> + <code>enter</code>). If you aren’t able to do that, create a file called <code>cat.rs</code> in your
<code>src</code> folder.</p>
<p>Inside our <code>cat.rs</code> file lets create a structure to hold a cat, we’ll make it public by putting the word <code>pub</code> in front
of the struct.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: cat.rs

pub struct Cat {
    name: String,
}
<span class="boring">}</span></code></pre></pre>
<p>We can access the <code>Cat</code> struct back in our <code>main</code> function either by giving a full reference to the <code>Cat</code> struct in its
module, <code>cat::Cat</code> or by using the <code>use</code> keyword. However, you’ll find we can’t actually <em>create</em> the structure.</p>
<pre><pre class="playground"><code class="language-rust compile_fail no_run"><span class="boring">// This would be in your `cat.rs`, I need to put it here to make the code work in mdbook
</span><span class="boring">mod cat {
</span><span class="boring">  pub struct Cat {
</span><span class="boring">    name: String,
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span>// File: main.rs

mod cat;

use cat::Cat;

fn main() {
    let yuki = Cat { name: "Yuki".to_string() };
}</code></pre></pre>
<pre><code class="language-text">   |
6  |     let yuki = Cat { name: "Yuki".to_string() };
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^ private field
</code></pre>
<p>This is because although <code>Cat</code> is public, it’s <code>name</code> is not.</p>
<p>We could, of course, simple make <code>name</code> public, but this means anything can access it at any time and, if your <code>cat</code> is
mutable, the name can be changed. We don’t want anything renaming Yuki, so, we’ll manage the property privately.</p>
<p>To create the object then, we’ll need a “constructor”, a function that is associated with our <code>Cat</code> type, that returns
an instantiated object. To do this we need to use an <code>impl</code> block.</p>
<h2 id="impl"><a class="header" href="#impl">impl</a></h2>
<p>In Rust, code that is associated with specific types is called “implementation” code, and lives inside an <code>impl</code> block.</p>
<p><code>impl</code> blocks are incredibly flexible, and we’ll see more of this in the next chapter, for now though, the simplest use
of the block is:</p>
<pre><code class="language-rust ignore">impl TypeName {
    // code goes here
}</code></pre>
<p>Our constructor is simply a function that lives inside the impl block of <code>Cat</code>, takes the cats name, and returns an
instantiated <code>Cat</code> with the given name. One nice thing about <code>impl</code> blocks is that they have a special shortcut when
referring to the type that is being implemented called <code>Self</code>. This means that while we <em>could</em> specifically return
the <code>Cat</code> type, but we could also use <code>Self</code>. There are a lot of benefits to the latter in more advanced code, so we’ll
use that here.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: cat.rs

pub struct Cat {
    name: String,
}

impl Cat {
    pub fn new(name: String) -&gt; Self {
        Self { name }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Above, the <code>new</code> function takes a <code>String</code> and returns a <code>Cat</code>. Here we can instantiate the <code>Cat</code> type with <code>Self</code> too,
and inside the <code>impl</code> block, we have access to the private <code>name</code> field. Finally, because the <code>name</code> variable is called
the same as thing as the <code>name</code> field, writing <code>Self { name: name }</code> is redundant, we can just write <code>Self { name }</code>.</p>
<p>Let’s make our <code>Cat</code> implementation slightly more useful by adding a function that will get the name of our cat too. In
order to get the name we’ll create a function with a special parameter <code>&amp;self</code>. You might notice a couple of odd things
about this. First, it has no type, and second, the variable self name itself gets the <code>&amp;</code> which would normally be on the
type, to show that it is a reference.</p>
<p><code>self</code> is a keyword, that translates in the parameters of a function header to <code>self: Self</code>, ie, a variable called
<code>self</code> with the type of whatever the implementation is for. When you use <code>&amp;self</code> it instead translates to <code>self: &amp;Self</code>.
Similarly, <code>&amp;mut self</code> translates to <code>self: &amp;mut Self</code>.</p>
<p>We don’t need to take ownership, or have a mutable reference, so for our function we’ll use <code>&amp;self</code> to get an immutable
reference.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: cat.rs

<span class="boring">pub struct Cat {
</span><span class="boring">    name: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Cat {
    pub fn new(name: String) -&gt; Self { // ...
<span class="boring">        Self { name }
</span><span class="boring">    }
</span>
    pub fn get_name(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Note:</strong> We can safely return a reference to owned data at this point because the function acts like any other, there
is only one reference coming in, <code>&amp;self</code>, and one reference going out <code>&amp;str</code>, they must have the same lifetime. Rust
will not allow you to compile any code where you keep the <code>&amp;str</code> beyond the point where whatever the owner of <code>&amp;self</code>
is goes out of scope.</p>
</blockquote>
<p>Any implementation function where the first parameter is some form of <code>self</code> may be referred to as a “method”, and is
available on the instantiated type. Any other function in the implementation is called a “static method”.</p>
<p>We can finally create a working program, so returning to <code>main</code>, lets use our new implementation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">// This would be in your `cat.rs`, I need to put it here to make the code work in mdbook
</span><span class="boring">mod cat {
</span><span class="boring">    pub struct Cat {
</span><span class="boring">        name: String,
</span><span class="boring">    }
</span><span class="boring">    impl Cat {
</span><span class="boring">        pub fn new(name: String) -&gt; Self {
</span><span class="boring">           Self { name }
</span><span class="boring">        }
</span><span class="boring">        pub fn get_name(&amp;self) -&gt; &amp;str {
</span><span class="boring">            &amp;self.name
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// File: main.rs

// ...
<span class="boring">use cat::Cat;
</span>
fn main() {
    let mut yuki = Cat::new("Yuki".to_string());
    println!("Our cat is called {}", yuki.get_name());
}</code></pre></pre>
<p>Great, lets move on to Yuki’s state!</p>
<h2 id="state-machines-and-rust"><a class="header" href="#state-machines-and-rust">State Machines and Rust</a></h2>
<p>We want to represent three of Yuki’s many “states”, but in particular, we want to move between them in a very specific
way.</p>
<p>A naive approach to this could use an <code>enum</code> to represent the states, and then we could have methods that change the
state.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: cat.rs

pub enum CatState {
    Mischievous,
    Hangry,
    Eepy,
}

pub struct Cat {
    name: String,
    state: CatState,
}

impl Cat {
    pub fn new(name: String) -&gt; Self {
       Self { 
          name,
          state: CatState::Mischievous, // Our default state
       }
    }
  
    pub fn get_name(&amp;self) -&gt; &amp;str { // ...
<span class="boring">        &amp;self.name
</span><span class="boring">    }
</span>
    pub fn forget_to_feed(&amp;mut self) {
        self.state = CatState::Hangry
    }

    pub fn feed(&amp;mut self) {
        self.state = CatState::Eepy
    }

    pub fn sleep(&amp;mut self) {
        self.state = CatState::Mischievous
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Here we use methods which take a mutable reference to self (<code>&amp;mut self</code>) so that we can modify the state.</p>
<p>But let’s look again at the diagram:</p>
<p><img src="language-basics/./impl/YukiStateMachine.svg" alt="YukiStateMachine.svg" /></p>
<p>A Hangry cat doesn’t become Mischievous because it slept. What should happen if we try to call <code>sleep</code> on a Hangry cat?
Should it do nothing? Should it throw an error? Does it even make sense for this to be an option?</p>
<p>Furthermore, if we look back at the specification, a Hangry cat may choose violence, but Eepy cats and Mischievous cats
won’t.</p>
<p>Instead, we could use a pattern called a State Machine. In a State Machine we transition fully between different states,
and those states have different functionality.</p>
<p>Let’s make our states unit structs instead of an enum</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: cat.rs

pub struct Mischievous;
pub struct Hangry;
pub struct Eepy;
<span class="boring">}</span></code></pre></pre>
<p>We can then apply the functionality to each struct in turn:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: cat.rs

<span class="boring">pub struct Mischievous;
</span><span class="boring">pub struct Hangry;
</span><span class="boring">pub struct Eepy;
</span>impl Mischievous {
    pub fn forget_to_feed(self) -&gt; Hangry {
        Hangry
    }
}

impl Hangry {
    pub fn feed(self) -&gt; Eepy {
        Eepy
    }
}

impl Eepy {
    pub fn sleep(self) -&gt; Mischievous {
        Mischievous
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This is <em>much</em> more ergonomic as <code>Hangry</code> simply does not have the method <code>sleep</code>, meaning you get compile time checking
that your cat states are being used correctly.</p>
<p>At this point, we don’t have any data about our cat though. There are a few ways we could deal with this. We could
extend our states to be the cat like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: cat.rs

pub struct Mischievous {
    name: String,
}

pub struct Hangry {
    name: String,
}

pub struct Eepy {
    name: String,
}

impl Mischievous {
    pub fn new(name: String) -&gt; Self {
        Self { name }
    }
  
    pub fn forget_to_feed(self) -&gt; Hangry {
        Hangry::new(self.name)
    }
}

impl Hangry {
    pub fn new(name: String) -&gt; Self {
        Self { name }
    }
  
    pub fn feed(self) -&gt; Eepy {
        Eepy::new(self.name)
    }
}

impl Eepy {
    pub fn new(name: String) -&gt; Self {
        Self { name }
    }
  
    pub fn sleep(self) -&gt; Mischievous {
        Mischievous::new(self.name)
    }
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Note:</strong> Each state transition consumes itself, and passes its owned data onto the new state. This saves memory
allocations and makes sure that you don’t have an “old” state hanging around.</p>
</blockquote>
<p>This is fine… but it’s not very flexible. Instead, we’re going to put the <em>whole</em> cat inside the state.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: cat.rs

// ---------- Cat ----------
pub struct Cat {
    name: String,
}

// ---------- States ----------
pub struct Mischievous {
    cat: Cat,
}

pub struct Hangry {
    cat: Cat,
}

pub struct Eepy {
    cat: Cat,
}
<span class="boring">}</span></code></pre></pre>
<p>You might think this is no better, and you’d be right! Whether the cat’s information is stored directly in the state or
not we haven’t made this more flexible… but, what if the states were generic?</p>
<h2 id="generics"><a class="header" href="#generics">Generics</a></h2>
<p>Generics are a way that we can create a template where some of the details are filled in later. We’re going to get
deeper into this in the next chapter, but we can use rudimentary generics to manage our states.</p>
<p>Functions, Structs and Enums can all be made generic by adding triangle brackets after their name, containing a list of
generic parameters. Very over you might see a single letter generic name, particularly you might see something like
<code>&lt;T&gt;</code> as you do with <code>Option&lt;T&gt;</code>, however, you might want to hint about the purposed of the type like the Error <code>E</code> in
<code>Result&lt;T, E&gt;</code>.</p>
<p>You can even use whole words, though this is seen less.</p>
<p>For our purposes, we’ll use the letter <code>A</code> to represent “Animal”.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: cat.rs

pub struct Mischievous&lt;A&gt; {
    animal: A,
}

pub struct Hangry&lt;A&gt; {
    animal: A,
}

pub struct Eepy&lt;A&gt; {
    animal: A,
}
<span class="boring">}</span></code></pre></pre>
<p>Later we can fill in the Generic and make it a “concrete” type, in our case this will eventually look like
<code>Mischievous&lt;Cat&gt;</code>.</p>
<p>Next we’ll need to update our implementations. Implementations that involve Generic parts, need to list those
after the <code>impl</code> to save confusing implementations on generic types and implementations on concrete variants of generic
types (don’t worry if that doesn’t quite make sense, just remember to put the generic parameters after the <code>impl</code>).</p>
<p>Once we’ve specified the generic parameters of the impl block, we don’t need to respecify them for each function so long
as the type is being used consistently. So, our <code>new</code> functions can use <code>A</code> for the animal parameter, and that will be
linked to our state’s generic <code>A</code>, and our state changes can use <code>A</code> to show that when the state changes, the generic
type will remain the same.</p>
<p>I’m also going to add a quick extra function, <code>describe</code>, to each implementation for use at the end.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: cat.rs

pub struct Mischievous&lt;A&gt; {
    animal: A,
}

pub struct Hangry&lt;A&gt; {
    animal: A,
}

pub struct Eepy&lt;A&gt; {
    animal: A,
}

impl&lt;A&gt; Mischievous&lt;A&gt; {
    pub fn new(animal: A) -&gt; Self {
        Self { animal }
    }

    pub fn forget_to_feed(self) -&gt; Hangry&lt;A&gt; {
        Hangry::new(self.animal)
    }
    
    pub fn describe(&amp;self) -&gt; String {
        "Trying to break into a wardrobe by pulling on exposed clothing".to_string()
    }
}

impl&lt;A&gt; Hangry&lt;A&gt; {
    pub fn new(animal: A) -&gt; Self {
        Self { animal }
    }

    pub fn feed(self) -&gt; Eepy&lt;A&gt; {
        Eepy::new(self.animal)
    }
    
    pub fn describe(&amp;self) -&gt; String {
        "Being loud doesn't get what they want, they choose violence and attack!".to_string()
    }
}

impl&lt;A&gt; Eepy&lt;A&gt; {
    pub fn new(animal: A) -&gt; Self {
        Self { animal }
    }

    pub fn sleep(self) -&gt; Mischievous&lt;A&gt; {
        Mischievous::new(self.animal)
    }
    
    pub fn describe(&amp;self) -&gt; String {
        "Look at the precious baby sleeping 😍".to_string()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Finally, lets update our cat implementation to return a concrete <code>Mischievous&lt;Cat&gt;</code> type:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: cat.rs

<span class="boring">pub struct Cat {
</span><span class="boring">    name: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Mischievous&lt;A&gt; {
</span><span class="boring">  animal: A,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;A&gt; Mischievous&lt;A&gt; {
</span><span class="boring">    pub fn new(animal: A) -&gt; Self {
</span><span class="boring">        Mischievous { animal }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Cat {
    pub fn new(name: String) -&gt; Mischievous&lt;Cat&gt; {
        Mischievous::new(Self { name })
    }
}
<span class="boring">}</span></code></pre></pre>
<p>We can now play with all of this in our main function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">mod cat { // Everything here should be in `cat.rs`, I can't do that and have runnable code though ;) 
</span><span class="boring">    pub struct Cat {
</span><span class="boring">        name: String,
</span><span class="boring">    }
</span><span class="boring">   
</span><span class="boring">    impl Cat {
</span><span class="boring">      pub fn new(name: String) -&gt; Mischievous&lt;Cat&gt; {
</span><span class="boring">        Mischievous::new(Self { name })
</span><span class="boring">      }
</span><span class="boring">    }
</span><span class="boring">    
</span><span class="boring">    pub struct Mischievous&lt;A&gt; {
</span><span class="boring">        animal: A,
</span><span class="boring">    }
</span><span class="boring">    
</span><span class="boring">    pub struct Hangry&lt;A&gt; {
</span><span class="boring">        animal: A,
</span><span class="boring">    }
</span><span class="boring">    
</span><span class="boring">    pub struct Eepy&lt;A&gt; {
</span><span class="boring">        animal: A,
</span><span class="boring">    }
</span><span class="boring">    
</span><span class="boring">    impl&lt;A&gt; Mischievous&lt;A&gt; {
</span><span class="boring">        pub fn new(animal: A) -&gt; Self {
</span><span class="boring">            Self { animal }
</span><span class="boring">        }
</span><span class="boring">    
</span><span class="boring">        pub fn forget_to_feed(self) -&gt; Hangry&lt;A&gt; {
</span><span class="boring">            Hangry::new(self.animal)
</span><span class="boring">        }
</span><span class="boring">        
</span><span class="boring">        pub fn describe(&amp;self) -&gt; String {
</span><span class="boring">            "Trying to break into a wardrobe by pulling on exposed clothing".to_string()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    
</span><span class="boring">    impl&lt;A&gt; Hangry&lt;A&gt; {
</span><span class="boring">        pub fn new(animal: A) -&gt; Self {
</span><span class="boring">            Self { animal }
</span><span class="boring">        }
</span><span class="boring">    
</span><span class="boring">        pub fn feed(self) -&gt; Eepy&lt;A&gt; {
</span><span class="boring">            Eepy::new(self.animal)
</span><span class="boring">        }
</span><span class="boring">        
</span><span class="boring">        pub fn describe(&amp;self) -&gt; String {
</span><span class="boring">            "Being loud doesn't get what they want, they choose violence and attack!".to_string()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    
</span><span class="boring">    impl&lt;A&gt; Eepy&lt;A&gt; {
</span><span class="boring">        pub fn new(animal: A) -&gt; Self {
</span><span class="boring">            Self { animal }
</span><span class="boring">        }
</span><span class="boring">    
</span><span class="boring">        pub fn sleep(self) -&gt; Mischievous&lt;A&gt; {
</span><span class="boring">            Mischievous::new(self.animal)
</span><span class="boring">        }
</span><span class="boring">        
</span><span class="boring">        pub fn describe(&amp;self) -&gt; String {
</span><span class="boring">            "Look at the precious baby sleeping 😍".to_string()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">use cat::Cat;
</span>// File: main.rs

// ...

fn main() {
  let mischievous_yuki = Cat::new("Yuki".to_string());
  println!("{}", mischievous_yuki.describe());
  println!();
  
  let hangry_yuki = mischievous_yuki.forget_to_feed();
  println!("{}", hangry_yuki.describe());
  println!();
  
  let sleepy_yuki = hangry_yuki.feed();
  println!("{}", sleepy_yuki.describe());
  println!();
  
  let mischievous_yuki = sleepy_yuki.sleep();
  println!("{}", mischievous_yuki.describe());
  println!();
}</code></pre></pre>
<h2 id="tidying-up"><a class="header" href="#tidying-up">Tidying up</a></h2>
<p>Before we finish the chapter, our code has gotten a bit messy, we should clean it up. Now that our states are not
Cat specific, they should be moved out of <code>cat.rs</code>.</p>
<p>I recommend splitting your files like this:</p>
<p><img src="language-basics/./impl/project-layout.png" alt="project-layout.png" /></p>
<p>You will need to <code>use</code> each state in the appropriate file being used, and you need to make your individual state modules
public in your general state <code>mod.rs</code>.</p>
<p>I’d like you to try to organise this project yourself, but if you get stuck, you can see it on our
<a href="https://github.com/Fios-Quest/yuki-state-machine-impl-example" title="" target="_blank">GitHub</a>.</p>
<h2 id="next-chapter-1"><a class="header" href="#next-chapter-1">Next Chapter</a></h2>
<p>This is cool… but we’ve got a slight problem. We can’t get Yuki’s name, and really his actions should belong to him,
not be part of the state (I try not to choose violence when I’m hangry for example).</p>
<p>We should move some of this behaviour to the Cat, but type, but how can we access details on our Cat type, when we
don’t know that our Generic states will contain Cat’s until runtime?</p>
<p>In the next chapter we’ll discuss Traits which provide a way to resolve this, as well as some other cool things they
can do with Generics!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="traits"><a class="header" href="#traits">Traits</a></h1>
<p>In the last chapter we created a state machine for our Cat, but we were left with several problems.</p>
<ol>
<li>We couldn’t access anything about the Cat from inside our State.</li>
<li>The behaviours didn’t seem generally applicable. Would <code>Hangry&lt;Human&gt;</code> make loud noises and bite someone? Mostly,
probably not.</li>
</ol>
<p>Traits can help us solve those problems.</p>
<blockquote>
<p>Note: This chapter uses code from the previous chapter, make sure you have the code from that chapter ready to go.</p>
</blockquote>
<h2 id="example-trait-tostring"><a class="header" href="#example-trait-tostring">Example Trait: <code>ToString</code></a></h2>
<p>Traits describe common behaviour between types that implement (<code>impl</code>) the trait. For example, have you noticed that
lots of types have a method called <code>to_string()</code>, including numbers, string slices (<code>&amp;str</code>) and even strings? This is
because there is a trait called <code>ToString</code> that describes the function header for a method called <code>to_string()</code> and all
of these types implement that trait.</p>
<p>This is what ToString looks like in the Rust standard library (sans comments and annotations):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait ToString {
   fn to_string(&amp;self) -&gt; String;
}
<span class="boring">}</span></code></pre></pre>
<p>Any type can implement this trait to provide the <code>to_string()</code> method.</p>
<p>We can use the <code>ToString</code> trait to create a generic function where we accept data of some type that could be literally
anything, and in the list of generic parameters we use a “Trait Bound” to restrict the types that can be used to only
those that implement the <code>ToString</code> trait.</p>
<p>In the example below, we use the generic <code>S</code> but we use “bounding” to say that whatever <code>S</code> is, it <em>must</em> implement
<code>ToString</code>. We can then be sure that whatever goes into our generic function it <em>must</em> have the <code>to_string()</code> method, so
it’s safe to rely on it being there. If it doesn’t implement <code>ToString</code> you’ll get a compiler error (this should show
up in your IDE before you get as far as compiling though). AS it happens, a <em>lot</em> of built-in types already implement
<code>ToString</code>.</p>
<pre><pre class="playground"><code class="language-rust">fn say_hello&lt;S: ToString&gt;(could_be_anything: S) {
    println!("Hello {}!", could_be_anything.to_string());
}

fn main() {
    say_hello("Yuki");               // &amp;str
    say_hello(String::from("Yuki")); // String
    say_hello(10u8)                  // u8 
    // say_hello(Vec::new());        // Vec doesn't impl ToString, this won't compile 
}</code></pre></pre>
<p>We can also implement <code>ToString</code> on our own types. Imagine we have a <em>*cough*</em>
<a href="https://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/" title="" target="_blank">poorly designed</a> Person type with a
first and last name. We can implement <code>ToString</code> to turn the user into a string which combines their name. You can
run this example to see that it works with our previous function</p>
<pre><pre class="playground"><code class="language-rust">struct User {
   first: String,
   last: String,
}

impl ToString for User {
   fn to_string(&amp;self) -&gt; String {
      // Here we use the format macro to create a combined string from the first
      // and last names. This works almost identically to the various `println!`
      // macros but creates a String on the heap and returns it
      format!("{} {}", &amp;self.first, &amp;self.last)
   }
}
<span class="boring">
</span><span class="boring">fn say_hello&lt;S: ToString&gt;(could_be_anything: S) {
</span><span class="boring">    println!("Hello {}!", could_be_anything.to_string());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let daniel = User { first: "Daniel".to_string(), last: "Mason".to_string() };
</span><span class="boring">    say_hello(daniel); 
</span><span class="boring">}</span></code></pre></pre>
<p>It’s worth noting that in order to use methods associated with a trait, the trait must be in scope. We don’t have to do
this ourselves because <code>ToString</code> is part of the <a href="https://doc.rust-lang.org/std/prelude/" title="" target="_blank">Rust prelude</a>, a collection
of types and traits that are always available in Rust. Often when people create libraries they’ll make their own prelude
module that contains the most commonly used types and traits so that you can import the entire prelude module (eg
<code>use rayon::prelude</code>, which we’ll talk more about in the ecosystem section of the book) rather than having to import a
lot of items individually.</p>
<p><code>ToString</code> is one of many traits that are built into the Rust standard library, and we’ll talk more about some of the
other traits available to you in the future. For now though, we’re going to build our own!</p>
<h2 id="animals"><a class="header" href="#animals"><code>Animal</code>s</a></h2>
<p>Let’s start by tackling the first problem, not having access to the <code>Cat</code>’s data inside the States. We’re going to make
an <code>Animal</code> trait to represent the behaviour of any animal.</p>
<p>We’ll also do a little reorganising while we’re at it.</p>
<p>The idea here is that all animals will implement the Animal trait, then we’ll have some known behaviour.</p>
<p>First lets create an animal module. In <code>main.rs</code> add <code>mod animal</code> and then create the file <code>animal/mod.rs</code>.</p>
<p>Let’s move <code>cat.rs</code> to <code>animal/cat.rs</code> so that it’s a submodule of <code>animal</code>. Finally, don’t forget to add <code>pub mod cat;</code>
to <code>animal/mod.rs</code> and don’t forget to update your use statement in <code>main.rs</code> to <code>animal::cat::Cat</code>.</p>
<p>We’re now ready to make our trait.</p>
<p>In <code>animal/mod.rs</code>, underneath <code>pub mod cat;</code>, let our new <code>Animal</code> trait:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: animal/mod.rs
pub trait Animal {
    fn get_name(&amp;self) -&gt; &amp;str;
}
<span class="boring">}</span></code></pre></pre>
<p>With trait methods, we don’t <em>have</em> to define any behaviour (though we can), we only need to tell Rust how the method
will be used. In this case we define a method called <code>get_name</code> which will take a reference to the data this is
implemented for, and will return a string slice. We also don’t need to specify that the method is public as Traits are
Rust’s equivalent of Interfaces, everything listed is assumed to be public.</p>
<p>So, let’s implement this for <code>Cat</code>.</p>
<p>In <code>cat.rs</code> we’ll add the implementation. As with implementations for types we start with <code>impl &lt;TRAIT_NAME&gt;</code> but with
traits we follow it up with <code>for &lt;TYPE&gt;</code>. So our impl block should look like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">// Prevent mdbook wrapping everything in a main function
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">// This should be in mod/animal.rs
</span><span class="boring">trait Animal {
</span><span class="boring">    fn get_name(&amp;self) -&gt; &amp;str;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod cat {
</span>use super::Animal;
<span class="boring">
</span><span class="boring">pub struct Cat {
</span><span class="boring">    name: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Cat {
</span><span class="boring">    pub fn new(name: String) -&gt; Self { // ...
</span><span class="boring">        Self { name }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn get_name(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.name
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>
impl Animal for Cat {
    fn get_name(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }
}
<span class="boring">}</span></code></pre></pre>
<p>You might have noticed that we now have <em>two</em> functions for Cat called <code>get_name()</code>, one in <code>impl Cat</code>, one in
<code>impl Animal for Cat</code>. That’s ok, we’ll come to that. For now, lets finish off the first task by updating out states.</p>
<p>For each state (<code>Mischievous</code>, <code>Hangry</code>, <code>Eepy</code>), we need to add a Trait Bound so that the generic <code>A</code> can only be of
type <code>Animal</code>. We can do this in the generics list as we did before. For example, <code>Mischievous</code> would look like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">fn main() {}
</span><span class="boring">trait Animal {
</span><span class="boring">    fn get_name(&amp;self) -&gt; &amp;str;
</span><span class="boring">}
</span>pub struct Mischievous&lt;A: Animal&gt; {
    animal: A,
}</code></pre></pre>
<p>Now that we know that whatever is in each state’s <code>animal</code> field must implement the <code>Animal</code> trait, we can treat it as
such in any implementation code for those states. Just remember that for generic <code>impl</code>s, it is the <code>impl</code> that
specifies the generic, so we need to make sure we add the Trait Bound there, then we can update our describe to use the
trait (here I’ve used the <code>format!</code> macro which is like <code>println!</code> but produces a <code>String</code>):</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {}
</span><span class="boring">trait Animal {
</span><span class="boring">    fn get_name(&amp;self) -&gt; &amp;str;
</span><span class="boring">}
</span>pub struct Mischievous&lt;A: Animal&gt; {
    animal: A,
}

impl&lt;A: Animal&gt; Mischievous&lt;A&gt; {
    // Other methods ...

    pub fn describe(&amp;self) -&gt; String {
        format!(
            "{} is trying to break into a wardrobe by pulling on exposed clothing",
            self.animal.get_name()
        )
    }
}</code></pre></pre>
<p>Update all of your States to use <code>self.animal.get_name()</code> and, assuming your <code>main.rs</code> still looks like the below, you
should get your output with your cats name!</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">pub mod animal {
</span><span class="boring">   // animal/mod.rs
</span><span class="boring">   pub trait Animal {
</span><span class="boring">      fn get_name(&amp;self) -&gt; &amp;str;
</span><span class="boring">   }
</span><span class="boring">   pub struct Mischievous&lt;A: Animal&gt; {
</span><span class="boring">      animal: A,
</span><span class="boring">
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   impl&lt;A: Animal&gt; Mischievous&lt;A&gt; {
</span><span class="boring">      // Other methods ...
</span><span class="boring">
</span><span class="boring">      pub fn describe(&amp;self) -&gt; String {
</span><span class="boring">         format!(
</span><span class="boring">            "{} is trying to break into a wardrobe by pulling on exposed clothing",
</span><span class="boring">            self.animal.get_name()
</span><span class="boring">         )
</span><span class="boring">      }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   pub mod cat {
</span><span class="boring">      // animal/cat.rs
</span><span class="boring">      use crate::state::mischievous::Mischievous;
</span><span class="boring">
</span><span class="boring">      use super::Animal;
</span><span class="boring">
</span><span class="boring">      pub struct Cat {
</span><span class="boring">         name: String,
</span><span class="boring">      }
</span><span class="boring">
</span><span class="boring">      impl Cat {
</span><span class="boring">         pub fn new(name: String) -&gt; Mischievous&lt;Self&gt; {
</span><span class="boring">            Mischievous::new(Self { name })
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">         pub fn get_name(&amp;self) -&gt; &amp;str {
</span><span class="boring">            "Cat"
</span><span class="boring">         }
</span><span class="boring">      }
</span><span class="boring">
</span><span class="boring">      impl Animal for Cat {
</span><span class="boring">         fn get_name(&amp;self) -&gt; &amp;str {
</span><span class="boring">            &amp;self.name
</span><span class="boring">         }
</span><span class="boring">      }
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub mod state {
</span><span class="boring">   pub mod eepy {
</span><span class="boring">      // state/eepy.rs
</span><span class="boring">      use crate::animal::Animal;
</span><span class="boring">
</span><span class="boring">      use super::mischievous::Mischievous;
</span><span class="boring">
</span><span class="boring">      pub struct Eepy&lt;A: Animal&gt; {
</span><span class="boring">         animal: A,
</span><span class="boring">      }
</span><span class="boring">
</span><span class="boring">      impl&lt;A: Animal&gt; Eepy&lt;A&gt; {
</span><span class="boring">         pub fn new(animal: A) -&gt; Self {
</span><span class="boring">            Eepy { animal }
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">         pub fn sleep(self) -&gt; Mischievous&lt;A&gt; {
</span><span class="boring">            Mischievous::new(self.animal)
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">         pub fn describe(&amp;self) -&gt; String {
</span><span class="boring">            format!(
</span><span class="boring">               "Look at the precious baby {} sleeping 😍",
</span><span class="boring">               &amp;self.animal.get_name()
</span><span class="boring">            )
</span><span class="boring">         }
</span><span class="boring">      }
</span><span class="boring">
</span><span class="boring">   }
</span><span class="boring">   
</span><span class="boring">   pub mod hangry {
</span><span class="boring">      // state/hangry.rs
</span><span class="boring">      use crate::animal::Animal;
</span><span class="boring">
</span><span class="boring">      use super::eepy::Eepy;
</span><span class="boring">
</span><span class="boring">      pub struct Hangry&lt;A: Animal&gt; {
</span><span class="boring">         animal: A,
</span><span class="boring">      }
</span><span class="boring">
</span><span class="boring">      impl&lt;A: Animal&gt; Hangry&lt;A&gt; {
</span><span class="boring">         pub fn new(animal: A) -&gt; Self {
</span><span class="boring">            Hangry { animal }
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">         pub fn feed(self) -&gt; Eepy&lt;A&gt; {
</span><span class="boring">            Eepy::new(self.animal)
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">         pub fn describe(&amp;self) -&gt; String {
</span><span class="boring">            format!(
</span><span class="boring">               "Being loud doesn't work, {} chooses violence and attacks!",
</span><span class="boring">               &amp;self.animal.get_name()
</span><span class="boring">            )
</span><span class="boring">         }
</span><span class="boring">      }
</span><span class="boring">
</span><span class="boring">   }
</span><span class="boring">   pub mod mischievous {
</span><span class="boring">      // state/mischievous.rs
</span><span class="boring">      use crate::animal::Animal;
</span><span class="boring">
</span><span class="boring">      use super::hangry::Hangry;
</span><span class="boring">
</span><span class="boring">      pub struct Mischievous&lt;A: Animal&gt; {
</span><span class="boring">         animal: A,
</span><span class="boring">      }
</span><span class="boring">
</span><span class="boring">      impl&lt;A: Animal&gt; Mischievous&lt;A&gt; {
</span><span class="boring">         pub fn new(animal: A) -&gt; Self {
</span><span class="boring">            Mischievous { animal }
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">         pub fn forget_to_feed(self) -&gt; Hangry&lt;A&gt; {
</span><span class="boring">            Hangry::new(self.animal)
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">         pub fn describe(&amp;self) -&gt; String {
</span><span class="boring">            format!(
</span><span class="boring">               "{} is trying to break into a wardrobe by pulling on exposed clothing",
</span><span class="boring">               self.animal.get_name()
</span><span class="boring">            )
</span><span class="boring">         }
</span><span class="boring">      }
</span><span class="boring">
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span>// main.rs
use animal::cat::Cat;

fn main() {
  let mischievous_yuki = Cat::new("Yuki".to_string());
  println!("{}", mischievous_yuki.describe());
  println!();
  
  let hangry_yuki = mischievous_yuki.forget_to_feed();
  println!("{}", hangry_yuki.describe());
  println!();
  
  let sleepy_yuki = hangry_yuki.feed();
  println!("{}", sleepy_yuki.describe());
  println!();
  
  let mischievous_yuki = sleepy_yuki.sleep();
  println!("{}", mischievous_yuki.describe());
  println!();
}</code></pre></pre>
<p>So that’s our first problem solved! We can now access the <code>Cat</code>’s data through the <code>Animal</code> trait.</p>
<h2 id="making-more-flexible-animals"><a class="header" href="#making-more-flexible-animals">Making more flexible <code>Animal</code>s</a></h2>
<p>Now that we can read details from the underlying <code>Cat</code> object, lets start to think about how we can expand this
functionality out to other types of animals… starting with the most dangerous of animal.</p>
<p>Start by adding <code>pub mod human;</code> to <code>animal.mod</code>.</p>
<p>Then create <code>animal/human.rs</code> and pop this inside:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: animal/human.rs

pub struct Human {
    name: String
}

impl Human {
    pub fn new(name: String) -&gt; Mischievous&lt;Self&gt; {
       Mischievous::new(Self { name })
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Your <code>animal/mod.rs</code> need to expose both of its submodules publicly.</p>
<pre><code class="language-rust ignore">// File: animal/mod.rs

pub mod cat;
pub mod human;</code></pre>
<p>Finally, lets update our main function, and run the program to make sure everything is working.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>

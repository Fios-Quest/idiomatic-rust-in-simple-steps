<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Traits Intro - Idiomatic Rust in Simple Steps</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Learn idiomatic Rust in simple steps even if you have no former knowledge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Idiomatic Rust in Simple Steps</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction-to-traits"><a class="header" href="#introduction-to-traits">Introduction to Traits</a></h1>
<p>In the last chapter we created a state machine for our Cat, but we were left with several problems.</p>
<ol>
<li>We couldn't access anything about the Cat from inside our State.</li>
<li>The behaviours didn't seem generally applicable. Would <code>Hangry&lt;Human&gt;</code> make loud noises and bite someone? Mostly,
probably not.</li>
</ol>
<p>Traits can help us solve those problems.</p>
<blockquote>
<p>Note: This chapter uses code from the previous chapter, make sure you have the code from that chapter ready to go.</p>
</blockquote>
<h2 id="example-trait-tostring"><a class="header" href="#example-trait-tostring">Example Trait: <code>ToString</code></a></h2>
<p>Traits describe common behaviour between types that implement (<code>impl</code>) the trait. For example, have you noticed that
lots of types have a method called <code>to_string()</code>, including numbers, string slices (<code>&amp;str</code>) and even strings? This is
because there is a trait called <code>ToString</code> that describes the function header for a method called <code>to_string()</code> and all
of these types implement that trait.</p>
<p>This is what ToString looks like in the Rust standard library (sans comments and annotations):</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait ToString {
   fn to_string(&amp;self) -&gt; String;
}
<span class="boring">}</span></code></pre></pre>
<p>Any type can implement this trait to provide the <code>to_string()</code> method.</p>
<p>We can use the <code>ToString</code> trait to create a generic function where we accept data of some type that could be literally
anything, and in the list of generic parameters we use a "Trait Bound" to restrict the types that can be used to only
those that implement the <code>ToString</code> trait.</p>
<p>In the example below, we use the generic <code>S</code> but we use "bounding" to say that whatever <code>S</code> is, it <em>must</em> implement
<code>ToString</code>. We can then be sure that whatever goes into our generic function it <em>must</em> have the <code>to_string()</code> method, so
it's safe to rely on it being there. If it doesn't implement <code>ToString</code> you'll get a compiler error (this should show
up in your IDE before you get as far as compiling though). AS it happens, a <em>lot</em> of built-in types already implement
<code>ToString</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn say_hello&lt;S: ToString&gt;(could_be_anything: S) {
    println!("Hello {}!", could_be_anything.to_string());
}

fn main() {
    say_hello("Yuki");               // &amp;str
    say_hello(String::from("Yuki")); // String
    say_hello(10u8);                 // u8 
    // say_hello(Vec::new());        // Vec doesn't impl ToString, this won't compile 
}</code></pre></pre>
<p>We can also implement <code>ToString</code> on our own types. Imagine we have a <em>*cough*</em>
<a href="https://www.kalzumeus.com/2010/06/17/falsehoods-programmers-believe-about-names/">poorly designed</a> Person type with a
first and last name. We can implement <code>ToString</code> to turn the user into a string which combines their name. You can
run this example to see that it works with our previous function</p>
<pre><pre class="playground"><code class="language-rust edition2024">struct Person {
   first: String,
   last: String,
}

impl ToString for Person {
   fn to_string(&amp;self) -&gt; String {
      // Here we use the format macro to create a combined string from the first
      // and last names. This works almost identically to the various `println!`
      // macros but creates a String on the heap and returns it
      format!("{} {}", &amp;self.first, &amp;self.last)
   }
}
<span class="boring">
</span><span class="boring">fn say_hello&lt;S: ToString&gt;(could_be_anything: S) {
</span><span class="boring">    println!("Hello {}!", could_be_anything.to_string());
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let daniel = Person { first: "Daniel".to_string(), last: "Mason".to_string() };
</span><span class="boring">    say_hello(daniel); 
</span><span class="boring">}</span></code></pre></pre>
<blockquote>
<p>‚ö†Ô∏è <strong>Important:</strong> You actually <em>shouldn't</em> implement <code>ToString</code>. I use it here because it's very slightly easier to
understand that what you <em>should</em> do, which is implement the trait <code>Display</code>. We'll cover this at the end of the
chapter when the reason why is easier to understand.</p>
</blockquote>
<p>It's worth noting that in order to use methods associated with a trait, the trait must be in scope. We don't have to do
this ourselves because <code>ToString</code> is part of the <a href="https://doc.rust-lang.org/std/prelude/">Rust prelude</a>, a collection
of types and traits that are always available in Rust. Often when people create libraries they'll make their own prelude
module that contains the most commonly used types and traits so that you can import the entire prelude module (eg
<code>use rayon::prelude</code>, which we'll talk more about in the ecosystem section of the book) rather than having to import a
lot of items individually.</p>
<p><code>ToString</code> is one of many traits that are built into the Rust standard library, and we'll talk more about some of the
other traits available to you in the future. For now though, we're going to build our own!</p>
<h2 id="animals"><a class="header" href="#animals"><code>Animal</code>s</a></h2>
<p>Let's start by tackling the first problem, not having access to the <code>Cat</code>'s data inside the States.</p>
<p>We're going to make an <code>Animal</code> trait to represent the behaviour of any animal.</p>
<p>We'll also do a little reorganising while we're at it.</p>
<p>The idea here is that all animals will implement the <code>Animal</code> trait, then we'll have some known behaviour.</p>
<p>First lets create an animal module. In <code>main.rs</code> add <code>mod animal</code> and then create the file <code>animal/mod.rs</code>.</p>
<p>Let's move <code>cat.rs</code> to <code>animal/cat.rs</code> so that it's a submodule of <code>animal</code>. Finally, don't forget to add <code>pub mod cat;</code>
to <code>animal/mod.rs</code> and to update your use statement in <code>main.rs</code> to <code>animal::cat::Cat</code>.</p>
<p>We're now ready to make our trait.</p>
<p>In <code>animal/mod.rs</code>, underneath <code>pub mod cat;</code>, let our new <code>Animal</code> trait:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: animal/mod.rs
pub trait Animal {
    fn get_name(&amp;self) -&gt; &amp;str;
}
<span class="boring">}</span></code></pre></pre>
<p>With trait methods, we don't <em>have</em> to define any behaviour (though we can), we only need to tell Rust how the method
will be used. In this case we define a method called <code>get_name</code> which will take a reference to the data this is
implemented for, and will return a string slice. We also don't need to specify that the method is public as Traits are
Rust's equivalent of Interfaces, everything listed is assumed to be public.</p>
<p>So, let's implement this for <code>Cat</code>.</p>
<p>In <code>cat.rs</code> we'll add the implementation. As with implementations for types we start with <code>impl &lt;TRAIT_NAME&gt;</code> but with
traits we follow it up with <code>for &lt;TYPE&gt;</code>. So our impl block should look like this:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">// Prevent mdbook wrapping everything in a main function
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">// This should be in your mod/animal.rs
</span><span class="boring">trait Animal {
</span><span class="boring">    fn get_name(&amp;self) -&gt; &amp;str;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod cat {
</span>use super::Animal;
<span class="boring">
</span><span class="boring">pub struct Cat {
</span><span class="boring">    name: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Cat {
</span><span class="boring">    pub fn new(name: String) -&gt; Self { // ...
</span><span class="boring">        Self { name }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn get_name(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.name
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>
impl Animal for Cat {
    fn get_name(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }
}
<span class="boring">}</span></code></pre></pre>
<p>You might have noticed that we now have <em>two</em> methods for Cat called <code>get_name()</code>, one in <code>impl Cat</code>, and one in
<code>impl Animal for Cat</code>. That's actually ok, but is indicative of a code smell. What happens if we want to add more
functionality to the getter? We'd have to remember to update both. It'd be better to call the underlying
<code>Cat::get_name</code> from <code>Animal::get_name</code>, but how do we do that?</p>
<p>Have you noticed that when calling methods with the dot syntax, eg, <code>yuki.get_name()</code>, even though the methods first
argument is <code>&amp;self</code> (or similar), we don't actually pass anything in here, this argument is skipped when calling. This
is because when we call a method with the dot syntax, we call it on a specific instance, so Rust, like many similar
languages, can infer the value of <code>self</code> (or <code>this</code> in some languages) to be the instance the method was called on.</p>
<p>We can also call the method directly and manually pass in the value of <code>self</code>. For example, in the method
<code>Animal::get_name</code> we could call the <code>Cat</code> method of the same name, manually passing in <code>self</code>. This lets Rust know that
it should call the <code>Cat</code> implementation of <code>get_name</code>. Now the behaviour of <code>Animal::get_name</code> for <code>Cat</code> will always be
the same as <code>Cat::get_name</code> even if we change the later method in the future.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">// Prevent mdbook wrapping everything in a main function
</span><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">// This should be in your mod/animal.rs
</span><span class="boring">trait Animal {
</span><span class="boring">    fn get_name(&amp;self) -&gt; &amp;str;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">mod cat {
</span>use super::Animal;
<span class="boring">
</span><span class="boring">pub struct Cat {
</span><span class="boring">    name: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Cat {
</span><span class="boring">    pub fn new(name: String) -&gt; Self { // ...
</span><span class="boring">        Self { name }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    pub fn get_name(&amp;self) -&gt; &amp;str {
</span><span class="boring">        &amp;self.name
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>
impl Animal for Cat {
    fn get_name(&amp;self) -&gt; &amp;str {
        Cat::get_name(self)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>For each state (<code>Mischievous</code>, <code>Hangry</code>, <code>Eepy</code>), we can add a Trait Bound so that the generic <code>A</code> must be a type that
has implemented the <code>Animal</code> trait. We can do this in the generics list as we did before. For example, <code>Mischievous</code>
would look like this:</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">fn main() {}
</span><span class="boring">trait Animal {
</span><span class="boring">    fn get_name(&amp;self) -&gt; &amp;str;
</span><span class="boring">}
</span>pub struct Mischievous&lt;A: Animal&gt; {
    animal: A,
}</code></pre></pre>
<p>Update all of you other states (<code>Hangry</code>, and <code>Eepy</code>) to match.</p>
<p>Now that we know that whatever is in each state's <code>animal</code> field must implement the <code>Animal</code> trait, we can treat it as
such in any implementation code for those states. Just remember that for generic <code>impl</code>s, it is the <code>impl</code> that
specifies the generic, so we need to make sure we add the Trait Bound there, then we can update our describe to use the
trait (here I've used the <code>format!</code> macro which is like <code>println!</code> but produces a <code>String</code>):</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">fn main() {}
</span><span class="boring">trait Animal {
</span><span class="boring">    fn get_name(&amp;self) -&gt; &amp;str;
</span><span class="boring">}
</span>pub struct Mischievous&lt;A: Animal&gt; {
    animal: A,
}

impl&lt;A: Animal&gt; Mischievous&lt;A&gt; {
    // Other methods ...

    pub fn describe(&amp;self) -&gt; String {
        format!(
            "{} is trying to break into a wardrobe by pulling on exposed clothing",
            self.animal.get_name()
        )
    }
}</code></pre></pre>
<p>Update all of your States to use <code>self.animal.get_name()</code> and, assuming your <code>main.rs</code> still looks like the below, you
should get your output with your cats name!</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">pub mod animal {
</span><span class="boring">   // animal/mod.rs
</span><span class="boring">   pub trait Animal {
</span><span class="boring">      fn get_name(&amp;self) -&gt; &amp;str;
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   pub mod cat {
</span><span class="boring">      // animal/cat.rs
</span><span class="boring">      use crate::state::mischievous::Mischievous;
</span><span class="boring">
</span><span class="boring">      use super::Animal;
</span><span class="boring">
</span><span class="boring">      pub struct Cat {
</span><span class="boring">         name: String,
</span><span class="boring">      }
</span><span class="boring">
</span><span class="boring">      impl Cat {
</span><span class="boring">         pub fn new(name: String) -&gt; Mischievous&lt;Self&gt; {
</span><span class="boring">            Mischievous::new(Self { name })
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">         pub fn get_name(&amp;self) -&gt; &amp;str {
</span><span class="boring">            &amp;self.name
</span><span class="boring">         }
</span><span class="boring">      }
</span><span class="boring">
</span><span class="boring">      impl Animal for Cat {
</span><span class="boring">         fn get_name(&amp;self) -&gt; &amp;str {
</span><span class="boring">            Cat::get_name(self)
</span><span class="boring">         }
</span><span class="boring">      }
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub mod state {
</span><span class="boring">   pub mod eepy {
</span><span class="boring">      // state/eepy.rs
</span><span class="boring">      use crate::animal::Animal;
</span><span class="boring">
</span><span class="boring">      use super::mischievous::Mischievous;
</span><span class="boring">
</span><span class="boring">      pub struct Eepy&lt;A: Animal&gt; {
</span><span class="boring">         animal: A,
</span><span class="boring">      }
</span><span class="boring">
</span><span class="boring">      impl&lt;A: Animal&gt; Eepy&lt;A&gt; {
</span><span class="boring">         pub fn new(animal: A) -&gt; Self {
</span><span class="boring">            Eepy { animal }
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">         pub fn sleep(self) -&gt; Mischievous&lt;A&gt; {
</span><span class="boring">            Mischievous::new(self.animal)
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">         pub fn describe(&amp;self) -&gt; String {
</span><span class="boring">            format!(
</span><span class="boring">               "Look at the precious baby {} sleeping üòç",
</span><span class="boring">               &amp;self.animal.get_name()
</span><span class="boring">            )
</span><span class="boring">         }
</span><span class="boring">      }
</span><span class="boring">
</span><span class="boring">   }
</span><span class="boring">   
</span><span class="boring">   pub mod hangry {
</span><span class="boring">      // state/hangry.rs
</span><span class="boring">      use crate::animal::Animal;
</span><span class="boring">
</span><span class="boring">      use super::eepy::Eepy;
</span><span class="boring">
</span><span class="boring">      pub struct Hangry&lt;A: Animal&gt; {
</span><span class="boring">         animal: A,
</span><span class="boring">      }
</span><span class="boring">
</span><span class="boring">      impl&lt;A: Animal&gt; Hangry&lt;A&gt; {
</span><span class="boring">         pub fn new(animal: A) -&gt; Self {
</span><span class="boring">            Hangry { animal }
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">         pub fn feed(self) -&gt; Eepy&lt;A&gt; {
</span><span class="boring">            Eepy::new(self.animal)
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">         pub fn describe(&amp;self) -&gt; String {
</span><span class="boring">            format!(
</span><span class="boring">               "Being loud doesn't work, {} chooses violence and attacks!",
</span><span class="boring">               &amp;self.animal.get_name()
</span><span class="boring">            )
</span><span class="boring">         }
</span><span class="boring">      }
</span><span class="boring">
</span><span class="boring">   }
</span><span class="boring">   pub mod mischievous {
</span><span class="boring">      // state/mischievous.rs
</span><span class="boring">      use crate::animal::Animal;
</span><span class="boring">
</span><span class="boring">      use super::hangry::Hangry;
</span><span class="boring">
</span><span class="boring">      pub struct Mischievous&lt;A: Animal&gt; {
</span><span class="boring">         animal: A,
</span><span class="boring">      }
</span><span class="boring">
</span><span class="boring">      impl&lt;A: Animal&gt; Mischievous&lt;A&gt; {
</span><span class="boring">         pub fn new(animal: A) -&gt; Self {
</span><span class="boring">            Mischievous { animal }
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">         pub fn forget_to_feed(self) -&gt; Hangry&lt;A&gt; {
</span><span class="boring">            Hangry::new(self.animal)
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">         pub fn describe(&amp;self) -&gt; String {
</span><span class="boring">            format!(
</span><span class="boring">               "{} is trying to break into a wardrobe by pulling on exposed clothing",
</span><span class="boring">               self.animal.get_name()
</span><span class="boring">            )
</span><span class="boring">         }
</span><span class="boring">      }
</span><span class="boring">
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span>// main.rs
use animal::cat::Cat;

fn main() {
  let mischievous_yuki = Cat::new("Yuki".to_string());
  println!("{}", mischievous_yuki.describe());
  println!();
  
  let hangry_yuki = mischievous_yuki.forget_to_feed();
  println!("{}", hangry_yuki.describe());
  println!();
  
  let sleepy_yuki = hangry_yuki.feed();
  println!("{}", sleepy_yuki.describe());
  println!();
  
  let mischievous_yuki = sleepy_yuki.sleep();
  println!("{}", mischievous_yuki.describe());
  println!();
}</code></pre></pre>
<p>So that's our first problem solved! We can now access the <code>Cat</code>'s data through the <code>Animal</code> trait.</p>
<h2 id="making-more-flexible-animals"><a class="header" href="#making-more-flexible-animals">Making more flexible <code>Animal</code>s</a></h2>
<p>Now that we can read details from the underlying <code>Cat</code> object, lets start to think about how we can expand this
functionality out to other types of animals... starting with the most dangerous of animal.</p>
<p>Start by adding <code>pub mod human;</code> to <code>animal.mod</code>.</p>
<p>Then create <code>animal/human.rs</code> and pop this inside:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">// Prevent mdbook wrapping everything in a main function
</span><span class="boring">fn main() {}
</span><span class="boring">pub mod animal {
</span><span class="boring">    // animal/mod.rs
</span><span class="boring">    pub trait Animal {
</span><span class="boring">        fn get_name(&amp;self) -&gt; &amp;str;
</span><span class="boring">    }
</span><span class="boring">}  
</span><span class="boring">pub mod state {
</span><span class="boring">    pub mod mischievous {
</span><span class="boring">    // state/mischievous.rs
</span><span class="boring">        use crate::animal::Animal;
</span><span class="boring">
</span><span class="boring">        pub struct Mischievous&lt;A: Animal&gt; {
</span><span class="boring">            animal: A,
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        impl&lt;A: Animal&gt; Mischievous&lt;A&gt; {
</span><span class="boring">            pub fn new(animal: A) -&gt; Self {
</span><span class="boring">                Mischievous { animal }
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// File: animal/human.rs
use animal::Animal;
use state::mischievous::Mischievous;

pub struct Human {
    name: String
}

impl Human {
    pub fn new(name: String) -&gt; Mischievous&lt;Self&gt; {
       Mischievous::new(Self { name })
    }
}

impl Animal for Human {
    fn get_name(&amp;self) -&gt; &amp;str {
       &amp;self.name
    }
}</code></pre></pre>
<p>Your <code>animal/mod.rs</code> need to expose both of its submodules publicly.</p>
<pre><code class="language-rust ignore">// File: animal/mod.rs

pub mod cat;
pub mod human;</code></pre>
<p>Finally, lets update our main function, and run the program to make sure everything is working.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">pub mod animal {
</span><span class="boring">   // animal/mod.rs
</span><span class="boring">   pub trait Animal {
</span><span class="boring">      fn get_name(&amp;self) -&gt; &amp;str;
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   pub mod cat {
</span><span class="boring">      // animal/cat.rs
</span><span class="boring">      use crate::state::mischievous::Mischievous;
</span><span class="boring">
</span><span class="boring">      use super::Animal;
</span><span class="boring">
</span><span class="boring">      pub struct Cat {
</span><span class="boring">         name: String,
</span><span class="boring">      }
</span><span class="boring">
</span><span class="boring">      impl Cat {
</span><span class="boring">         pub fn new(name: String) -&gt; Mischievous&lt;Self&gt; {
</span><span class="boring">            Mischievous::new(Self { name })
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">         pub fn get_name(&amp;self) -&gt; &amp;str {
</span><span class="boring">            &amp;self.name
</span><span class="boring">         }
</span><span class="boring">      }
</span><span class="boring">
</span><span class="boring">      impl Animal for Cat {
</span><span class="boring">         fn get_name(&amp;self) -&gt; &amp;str {
</span><span class="boring">            Cat::get_name(self)
</span><span class="boring">         }
</span><span class="boring">      }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   pub mod human {
</span><span class="boring">      // animal/human.rs
</span><span class="boring">      use crate::state::mischievous::Mischievous;
</span><span class="boring">
</span><span class="boring">      use super::Animal;
</span><span class="boring">
</span><span class="boring">      pub struct Human {
</span><span class="boring">         name: String,
</span><span class="boring">      }
</span><span class="boring">
</span><span class="boring">      impl Human {
</span><span class="boring">         pub fn new(name: String) -&gt; Mischievous&lt;Self&gt; {
</span><span class="boring">            Mischievous::new(Self { name })
</span><span class="boring">         }
</span><span class="boring">      }
</span><span class="boring">
</span><span class="boring">      impl Animal for Human {
</span><span class="boring">         fn get_name(&amp;self) -&gt; &amp;str {
</span><span class="boring">            &amp;self.name
</span><span class="boring">         }
</span><span class="boring">      }
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub mod state {
</span><span class="boring">   pub mod eepy {
</span><span class="boring">      // state/eepy.rs
</span><span class="boring">      use crate::animal::Animal;
</span><span class="boring">
</span><span class="boring">      use super::mischievous::Mischievous;
</span><span class="boring">
</span><span class="boring">      pub struct Eepy&lt;A: Animal&gt; {
</span><span class="boring">         animal: A,
</span><span class="boring">      }
</span><span class="boring">
</span><span class="boring">      impl&lt;A: Animal&gt; Eepy&lt;A&gt; {
</span><span class="boring">         pub fn new(animal: A) -&gt; Self {
</span><span class="boring">            Eepy { animal }
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">         pub fn sleep(self) -&gt; Mischievous&lt;A&gt; {
</span><span class="boring">            Mischievous::new(self.animal)
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">         pub fn describe(&amp;self) -&gt; String {
</span><span class="boring">            format!(
</span><span class="boring">               "Look at the precious baby {} sleeping üòç",
</span><span class="boring">               &amp;self.animal.get_name()
</span><span class="boring">            )
</span><span class="boring">         }
</span><span class="boring">      }
</span><span class="boring">
</span><span class="boring">   }
</span><span class="boring">   
</span><span class="boring">   pub mod hangry {
</span><span class="boring">      // state/hangry.rs
</span><span class="boring">      use crate::animal::Animal;
</span><span class="boring">
</span><span class="boring">      use super::eepy::Eepy;
</span><span class="boring">
</span><span class="boring">      pub struct Hangry&lt;A: Animal&gt; {
</span><span class="boring">         animal: A,
</span><span class="boring">      }
</span><span class="boring">
</span><span class="boring">      impl&lt;A: Animal&gt; Hangry&lt;A&gt; {
</span><span class="boring">         pub fn new(animal: A) -&gt; Self {
</span><span class="boring">            Hangry { animal }
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">         pub fn feed(self) -&gt; Eepy&lt;A&gt; {
</span><span class="boring">            Eepy::new(self.animal)
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">         pub fn describe(&amp;self) -&gt; String {
</span><span class="boring">            format!(
</span><span class="boring">               "Being loud doesn't work, {} chooses violence and attacks!",
</span><span class="boring">               &amp;self.animal.get_name()
</span><span class="boring">            )
</span><span class="boring">         }
</span><span class="boring">      }
</span><span class="boring">
</span><span class="boring">   }
</span><span class="boring">   pub mod mischievous {
</span><span class="boring">      // state/mischievous.rs
</span><span class="boring">      use crate::animal::Animal;
</span><span class="boring">
</span><span class="boring">      use super::hangry::Hangry;
</span><span class="boring">
</span><span class="boring">      pub struct Mischievous&lt;A: Animal&gt; {
</span><span class="boring">         animal: A,
</span><span class="boring">      }
</span><span class="boring">
</span><span class="boring">      impl&lt;A: Animal&gt; Mischievous&lt;A&gt; {
</span><span class="boring">         pub fn new(animal: A) -&gt; Self {
</span><span class="boring">            Mischievous { animal }
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">         pub fn forget_to_feed(self) -&gt; Hangry&lt;A&gt; {
</span><span class="boring">            Hangry::new(self.animal)
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">         pub fn describe(&amp;self) -&gt; String {
</span><span class="boring">            format!(
</span><span class="boring">               "{} is trying to break into a wardrobe by pulling on exposed clothing",
</span><span class="boring">               self.animal.get_name()
</span><span class="boring">            )
</span><span class="boring">         }
</span><span class="boring">      }
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span>// main.rs
use animal::cat::Cat;
use animal::human::Human;

fn main() {
    let mischievous_yuki = Cat::new("Yuki".to_string());
    println!("{}", mischievous_yuki.describe());
 
    let mischievous_daniel = Human::new("Daniel".to_string());
    println!("{}", mischievous_daniel.describe());
}</code></pre></pre>
<p>Notice that we barely had to change anything to add humans to our code, how cool is that!</p>
<p>But there's still an issue... my mischievous state doesn't tend to have me breaking into wardrobes by pulling on exposed
clothing... I have a opposable thumb.</p>
<p>In fact, when I'm in a mischievous mood, I probably don't behave the same as other humans, I probably don't behave the
same as you when you're feeling mischievous.</p>
<h2 id="optional-homework"><a class="header" href="#optional-homework">Optional Homework</a></h2>
<p>Can you change the code so that each states behaviours are defined when the structs are instantiated? To do this you
will need to:</p>
<ul>
<li>modify the <code>Human</code> and <code>Cat</code> structs</li>
<li>add methods to the <code>Animal</code> trait</li>
<li>and then implement those methods for each struct</li>
</ul>
<p>If you get stuck, I've implemented the code below, just hit the eye icon. Please note that a limitation of this book
means all the code is in one place, you should split your modules into files so that it's easier to manage and work
with.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">pub mod animal {
</span><span class="boring">   // animal/mod.rs
</span><span class="boring">   pub trait Animal {
</span><span class="boring">      fn get_name(&amp;self) -&gt; &amp;str;
</span><span class="boring">      fn get_behaviour_mischievous(&amp;self) -&gt; &amp;str;
</span><span class="boring">      fn get_behaviour_hangry(&amp;self) -&gt; &amp;str;
</span><span class="boring">      fn get_behaviour_eepy(&amp;self) -&gt; &amp;str;
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   pub mod cat {
</span><span class="boring">      // animal/cat.rs
</span><span class="boring">      use crate::state::mischievous::Mischievous;
</span><span class="boring">
</span><span class="boring">      use super::Animal;
</span><span class="boring">
</span><span class="boring">      pub struct Cat {
</span><span class="boring">          name: String,
</span><span class="boring">          behaviour_mischievous: String,
</span><span class="boring">          behaviour_hangry: String,
</span><span class="boring">          behaviour_eepy: String,
</span><span class="boring">      }
</span><span class="boring">
</span><span class="boring">      impl Cat {
</span><span class="boring">         pub fn new(
</span><span class="boring">             name: String,
</span><span class="boring">             behaviour_mischievous: String,
</span><span class="boring">             behaviour_hangry: String,
</span><span class="boring">             behaviour_eepy: String,
</span><span class="boring">         ) -&gt; Mischievous&lt;Self&gt; {
</span><span class="boring">             Mischievous::new(Self { 
</span><span class="boring">                 name,
</span><span class="boring">                 behaviour_mischievous,
</span><span class="boring">                 behaviour_hangry,
</span><span class="boring">                 behaviour_eepy,
</span><span class="boring">             })
</span><span class="boring">         }
</span><span class="boring">      }
</span><span class="boring">
</span><span class="boring">      impl Animal for Cat {
</span><span class="boring">         fn get_name(&amp;self) -&gt; &amp;str {
</span><span class="boring">            &amp;self.name
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">         fn get_behaviour_mischievous(&amp;self) -&gt; &amp;str {
</span><span class="boring">            &amp;self.behaviour_mischievous
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">         fn get_behaviour_hangry(&amp;self) -&gt; &amp;str {
</span><span class="boring">            &amp;self.behaviour_hangry
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">         fn get_behaviour_eepy(&amp;self) -&gt; &amp;str {
</span><span class="boring">            &amp;self.behaviour_eepy
</span><span class="boring">         }
</span><span class="boring">      }
</span><span class="boring">   }
</span><span class="boring">
</span><span class="boring">   pub mod human {
</span><span class="boring">      // animal/human.rs
</span><span class="boring">      use crate::state::mischievous::Mischievous;
</span><span class="boring">
</span><span class="boring">      use super::Animal;
</span><span class="boring">
</span><span class="boring">      pub struct Human {
</span><span class="boring">          name: String,
</span><span class="boring">          behaviour_mischievous: String,
</span><span class="boring">          behaviour_hangry: String,
</span><span class="boring">          behaviour_eepy: String,
</span><span class="boring">      }
</span><span class="boring">
</span><span class="boring">      impl Human {
</span><span class="boring">          pub fn new(
</span><span class="boring">              name: String,
</span><span class="boring">              behaviour_mischievous: String,
</span><span class="boring">              behaviour_hangry: String,
</span><span class="boring">              behaviour_eepy: String,
</span><span class="boring">          ) -&gt; Mischievous&lt;Self&gt; {
</span><span class="boring">              Mischievous::new(Self {
</span><span class="boring">                  name,
</span><span class="boring">                  behaviour_mischievous,
</span><span class="boring">                  behaviour_hangry,
</span><span class="boring">                  behaviour_eepy,
</span><span class="boring">              })
</span><span class="boring">          }
</span><span class="boring">      }
</span><span class="boring">
</span><span class="boring">      impl Animal for Human {
</span><span class="boring">         fn get_name(&amp;self) -&gt; &amp;str {
</span><span class="boring">             &amp;self.name
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">         fn get_behaviour_mischievous(&amp;self) -&gt; &amp;str {
</span><span class="boring">             &amp;self.behaviour_mischievous
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">         fn get_behaviour_hangry(&amp;self) -&gt; &amp;str {
</span><span class="boring">             &amp;self.behaviour_hangry
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">         fn get_behaviour_eepy(&amp;self) -&gt; &amp;str {
</span><span class="boring">             &amp;self.behaviour_eepy
</span><span class="boring">         }
</span><span class="boring">      }
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub mod state {
</span><span class="boring">   pub mod eepy {
</span><span class="boring">      // state/eepy.rs
</span><span class="boring">      use crate::animal::Animal;
</span><span class="boring">
</span><span class="boring">      use super::mischievous::Mischievous;
</span><span class="boring">
</span><span class="boring">      pub struct Eepy&lt;A: Animal&gt; {
</span><span class="boring">          animal: A,
</span><span class="boring">      }
</span><span class="boring">
</span><span class="boring">      impl&lt;A: Animal&gt; Eepy&lt;A&gt; {
</span><span class="boring">         pub fn new(animal: A) -&gt; Self {
</span><span class="boring">             Eepy { animal }
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">         pub fn sleep(self) -&gt; Mischievous&lt;A&gt; {
</span><span class="boring">             Mischievous::new(self.animal)
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">         pub fn describe(&amp;self) -&gt; String {
</span><span class="boring">             format!("{} is {}", self.animal.get_name(), self.animal.get_behaviour_eepy())
</span><span class="boring">         }
</span><span class="boring">      }
</span><span class="boring">
</span><span class="boring">   }
</span><span class="boring">   
</span><span class="boring">   pub mod hangry {
</span><span class="boring">      // state/hangry.rs
</span><span class="boring">      use crate::animal::Animal;
</span><span class="boring">
</span><span class="boring">      use super::eepy::Eepy;
</span><span class="boring">
</span><span class="boring">      pub struct Hangry&lt;A: Animal&gt; {
</span><span class="boring">         animal: A,
</span><span class="boring">      }
</span><span class="boring">
</span><span class="boring">      impl&lt;A: Animal&gt; Hangry&lt;A&gt; {
</span><span class="boring">         pub fn new(animal: A) -&gt; Self {
</span><span class="boring">             Hangry { animal }
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">         pub fn feed(self) -&gt; Eepy&lt;A&gt; {
</span><span class="boring">             Eepy::new(self.animal)
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">         pub fn describe(&amp;self) -&gt; String {
</span><span class="boring">             format!("{} is {}", self.animal.get_name(), self.animal.get_behaviour_hangry())
</span><span class="boring">         }
</span><span class="boring">      }
</span><span class="boring">
</span><span class="boring">   }
</span><span class="boring">   pub mod mischievous {
</span><span class="boring">      // state/mischievous.rs
</span><span class="boring">      use crate::animal::Animal;
</span><span class="boring">
</span><span class="boring">      use super::hangry::Hangry;
</span><span class="boring">
</span><span class="boring">      pub struct Mischievous&lt;A: Animal&gt; {
</span><span class="boring">         animal: A,
</span><span class="boring">      }
</span><span class="boring">
</span><span class="boring">      impl&lt;A: Animal&gt; Mischievous&lt;A&gt; {
</span><span class="boring">         pub fn new(animal: A) -&gt; Self {
</span><span class="boring">            Mischievous { animal }
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">         pub fn forget_to_feed(self) -&gt; Hangry&lt;A&gt; {
</span><span class="boring">            Hangry::new(self.animal)
</span><span class="boring">         }
</span><span class="boring">
</span><span class="boring">         pub fn describe(&amp;self) -&gt; String {
</span><span class="boring">             format!("{} is {}", self.animal.get_name(), self.animal.get_behaviour_mischievous())
</span><span class="boring">         }
</span><span class="boring">      }
</span><span class="boring">   }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">// main.rs
</span><span class="boring">use animal::cat::Cat;
</span><span class="boring">use animal::human::Human;
</span><span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let mischievous_yuki = Cat::new(
</span><span class="boring">        "Yuki".to_string(),
</span><span class="boring">        "trying to break into a wardrobe by pulling on exposed clothing".to_string(),
</span><span class="boring">        "being loud, it doesn't work so he chooses violence".to_string(),
</span><span class="boring">        "half a sleep, look at the precious baby üòª".to_string(),
</span><span class="boring">    );
</span><span class="boring"> 
</span><span class="boring">    let mischievous_daniel = Human::new(
</span><span class="boring">        "Daniel".to_string(),
</span><span class="boring">        r#"pretending to sneak up on his partner for a hug quietly saying "sneak sneak""#.to_string(),
</span><span class="boring">        "looking at food delivery apps".to_string(),
</span><span class="boring">        "watching TV he's seen a million times before to wind down".to_string(),
</span><span class="boring">    );
</span><span class="boring">
</span><span class="boring">    println!("{}", mischievous_yuki.describe());
</span><span class="boring">    println!("{}", mischievous_daniel.describe());
</span><span class="boring">    
</span><span class="boring">    let hangry_yuki = mischievous_yuki.forget_to_feed();
</span><span class="boring">    let hangry_daniel = mischievous_daniel.forget_to_feed();
</span><span class="boring">    println!("{}", hangry_yuki.describe());
</span><span class="boring">    println!("{}", hangry_daniel.describe());
</span><span class="boring">
</span><span class="boring">    let sleepy_yuki = hangry_yuki.feed();
</span><span class="boring">    let sleepy_daniel = hangry_daniel.feed();
</span><span class="boring">    println!("{}", sleepy_yuki.describe());
</span><span class="boring">    println!("{}", sleepy_daniel.describe());
</span><span class="boring">}
</span>// Run me or look at my code using the hover icons</code></pre></pre>
<h2 id="display"><a class="header" href="#display"><code>Display</code></a></h2>
<p>As I mentioned earlier, we shouldn't actually implement <code>ToString</code>, we should implement <code>Display</code>. In fact, none of the
internal types I mentioned (numbers, string slices, strings, etc) implement <code>ToString</code> but do in fact implement
<code>Display</code>.</p>
<p>Let's start looking at the trait itself:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::fmt::{Formatter, Result};
</span><span class="boring">
</span>pub trait Display {
    fn fmt(&amp;self, f: &amp;mut Formatter&lt;'_&gt;) -&gt; Result;
}
<span class="boring">}</span></code></pre></pre>
<p>As you can see, its already more complex than <code>ToString</code>. It takes an additional parameter of type <code>Formatter</code>
(specifically <code>std::fmt::Formatter</code>), and instead of returning a string, it returns a <code>Result</code> (specifically
<code>std::fmt::Result</code>).</p>
<p>Luckily, we don't actually have to worry about any of this ourselves as there is a macro called <code>write!</code> that deals with
it all for us.</p>
<p>To change our <code>ToString</code> implementation for <code>Person</code> to <code>Display</code>, in addition to changing the trait name and method,
we can simply swap the <code>format!</code> macro for <code>write!</code> and pass the formatter as the first part of the macro.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">fn main() {}
</span><span class="boring">
</span><span class="boring">struct Person {
</span><span class="boring">   first: String,
</span><span class="boring">   last: String,
</span><span class="boring">}
</span><span class="boring">
</span>use std::fmt; // Easier to use the fmt module directly due to `Result` already existing in scope

impl fmt::Display for Person {
   fn fmt(&amp;self, f: &amp;mut fmt::Formatter) -&gt; fmt::Result {
      write!(f, "{} {}", &amp;self.first, &amp;self.last)
   }
}</code></pre></pre>
<p>Hang on though, if none of these types are implementing <code>ToString</code>, how did we use them in a function with a <code>ToString</code>
trait bound?</p>
<p>Well, they don't implement <code>ToString</code> directly, there is a
<a href="https://doc.rust-lang.org/1.81.0/src/alloc/string.rs.html#2555">generic implementation of <code>ToString</code></a>
for all types that implement <code>Display</code>.</p>
<p>Over simplified (there's still more to the <code>Display</code> trait I don't want to cover <em>yet</em>, but check the link for the full
code) it looks like this:</p>
<pre><code class="language-rust ignore"><span class="boring">use std::fmt;
</span><span class="boring">
</span>impl&lt;T: fmt::Display&gt; ToString for T {
    fn to_string(&amp;self) -&gt; String {
        let mut buffer = String::new();
        let mut formatter = fmt::Formatter::new(&amp;mut buffer);
        self.fmt(&amp;mut formatter).expect("a Display implementation returned an error unexpectedly");
        buffer
    }
}</code></pre>
<p>Having gone through the rest of the chapter this hopefully makes some sense. We're implementing <code>ToString</code> for the
generic <code>T</code> where <code>T</code> already has <code>Display</code>. We can then create the string using the display method of that type.</p>
<p>Because those built in types already have <code>Display</code>, they get <code>ToString</code> for free. Once you've implemented <code>Display</code> for
<code>Person</code> to, you not only won't need <code>ToString</code> any more, you'll find that <code>ToString</code> if you leave you're <code>ToString</code>
implementation in, you can't compile your code because it now conflicts with this other implementation.</p>
<p>So why do both <code>Display</code> and <code>ToString</code> exist, especially if everything with <code>Display</code> gets a free <code>ToString</code>
implementation? The answer might surprise you! ... But it's non-trivial so I'll save it for much further into the book,
however I will give you a hint, it's <em>something</em> to do with memory.</p>
<h2 id="next-chapter"><a class="header" href="#next-chapter">Next Chapter</a></h2>
<p>In the next chapter we'll continue to explore Traits by looking at some of the more commonly used ones available in the
Rust standard library. This will also allow us to cover some Trait features we haven't seen so far, including associated
types!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../language-basics/impl.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../language-basics/common-traits.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../language-basics/impl.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../language-basics/common-traits.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>

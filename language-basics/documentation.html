<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Documentation - Idiomatic Rust in Simple Steps</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Learn idiomatic Rust in simple steps even if you have no former knowledge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Idiomatic Rust in Simple Steps</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="documentation"><a class="header" href="#documentation">Documentation</a></h1>
<p>Documentation. Is. Awesome… in Rust.</p>
<p>Good documentation is awesome all the time but Rust provides some tools that make documenting your project a truly
magical experience. In Rust good documentation is low effort and high value.</p>
<p>Documentation is important. You’ll hear a lot of things in Software like “the code should document itself” and “the
tests should document the code”, and this is all true, but it’s not a <em>substitute</em> for documentation. Easy to understand
code is incredibly important when you work in a code base so that you can easily understand it and maintain it. And, as
we spoke about in the last chapter, tests are important to show our expectations of what the code will do when used.</p>
<p>But code and tests are not there primarily to teach someone how to use the code. They can do that, but its secondary,
meaning that someone consuming this for the purpose of learning how to use the code, is having to deal with information
they don’t need.</p>
<p>As software engineers, a huge part of our role is communication, and good documentation conveys how to use our work as
quickly, and as painlessly as possible. Rust understands this and provides a full suite of tools that make producing
documentation, not just trivial, but also fun!</p>
<h2 id="libraries"><a class="header" href="#libraries">Libraries</a></h2>
<p>In order to show the value of documentation, we’re going to create our first Rust library.</p>
<p>Up to now, we’ve been building binaries. Rust compiles <code>main.rs</code> into an executable, but our projects can link to and,
use functionality from, libraries. This is particularly helpful when sharing and reusing code. We’ll be talking much
more about how we share code with each other when we cover the Rust ecosystem, but even as we’re just learning the
language, we can leverage the power of libraries for things like code reuse within the same project.</p>
<p>Let’s try it out. First, let’s make a normal program, remember you can do this with something like:
<code>cargo new iriss-documentation</code></p>
<p>In <code>main.rs</code>, we’ll make a single function and our main program will just check it works.</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn add(a: usize, b: usize) -&gt; usize {
    a + b
}

fn main() {
    assert_eq!(add(40, 2), 42);
}</code></pre></pre>
<p>Next, let’s migrate the add function to a library. Create a new file called <code>lib.rs</code>. In the same way that <code>main.rs</code> is
the entry to our binary, <code>lib.rs</code> is the entry point to our library. Our library acts like any other module and the
module is named the same thing as our project (though swap hyphens <code>-</code> for underscores <code>_</code>). Anything public in <code>lib.rs</code>
will be available to anyone using the library.</p>
<p>We’ll move our add function to the <code>lib.rs</code> and make it public so that we can access it from <code>main.rs</code>:</p>
<pre><code class="language-rust noplayground">// lib.rs
pub fn add(a: usize, b: usize) -&gt; usize {
    a + b
}</code></pre>
<p>We can now use this function in our main function via the project module (eg, <code>iriss_documentation</code>).</p>
<pre><code class="language-rust noplayground"><span class="boring">// This is included for `mdbook test` which I'm using to check for obvious mistakes,
</span><span class="boring">// this _should_ be in lib.rs in your project and not in a module
</span><span class="boring">mod iriss_documentation {
</span><span class="boring">    pub fn add(a: usize, b: usize) -&gt; usize {
</span><span class="boring">        a + b
</span><span class="boring">    }
</span><span class="boring">}
</span>// main.rs
use iriss_documentation::add;

fn main() {
    assert_eq!(add(40, 2), 42, "We expect 40 + 2 = 42");
}</code></pre>
<blockquote>
<p>ℹ️ Note: Although our project name  is <code>iriss-documentation</code> with a hyphen, the library name will be
<code>iriss_documentation</code> with an underscore.</p>
</blockquote>
<p>If we run our program right now, you can see that it still works but… we’re not really taking advantage of the library
though, what’s the difference between this and what we had before?</p>
<p>The main way you’re likely to share code is through Rust’s package management system called Crates. Were you to publish
this project right now (please don’t though, <em>this</em> project is obviously pretty useless 😅), then theoretically other
people could use your <code>add()</code> function. But, we aren’t going to cover Crates at all in the language basics portion of
this book.</p>
<p>That doesn’t mean this technique isn’t useful though. To show how it can be useful, let’s make another change to our
project.</p>
<p>Now that we’ve got our <code>lib.rs</code>, let’s move <code>main.rs</code> to <code>bin/main.rs</code>. The program still runs if you use <code>cargo run</code> but
if you look closely there is a difference.</p>
<p>Before:</p>
<p><img src="documentation/bin-before.png" alt="Before we moved to bin" /></p>
<p>After:</p>
<p><img src="documentation/bin-after.png" alt="After we moved to bin" /></p>
<p>In the last line, you’ll see the name of the binary has changed from <code>iriss-documentation.exe</code> to <code>main.exe</code>. This is
because when the project was a single binary file, the executable was simply named after the project. By using the
<code>bin</code> directory, we’re telling Rust we expect to produce multiple binaries from this project, so now it takes the name
from the file name instead of the project.</p>
<p>To fix this, rename <code>bin/main.rs</code> to <code>bin/iriss-documentation.rs</code> and cargo will go back to creating
<code>iriss-documentation.exe</code>.</p>
<p>You can now create more binaries in this directory called different things and all of them will have access to the
library we’ve created!</p>
<p>Feel free to try this out, but bear in mind that once you have more than one file in that directory, you will have to
tell cargo which binary you want it to focus on. For example: <code>cargo run --bin iriss-documentation</code></p>
<h2 id="rustdoc"><a class="header" href="#rustdoc">rustdoc</a></h2>
<p>The Rust toolset includes a program called <code>rustdoc</code> which we can run through Cargo using <code>cargo doc</code>. It builds and
combines the documentation, not only from your code, but from any libraries and crates you’re using.</p>
<p>Let’s jump in and try it out with our code, if you run <code>cargo doc --open</code> it will build the documentation and then open
it in your browser. As you can see, without us doing anything rustdoc has figured out about our add function.</p>
<p><img src="documentation/rustdoc-1.png" alt="Our documentation’s home page" /></p>
<p>You’ll notice that it’s only documented our library. This is because people consuming your code can’t use code in the
binary.</p>
<p>If you click the <code>add</code> function, it’ll take you to the documentation page. Rustdoc has already worked out the header
for the function, but that’s all the information there is for now.</p>
<p><img src="documentation/rustdoc-2.png" alt="Add function documentation, it’s a bit bland" /></p>
<p>So how do we actually give the consumers of our library the information they need? Comments! … kinda.</p>
<h2 id="doc-comments"><a class="header" href="#doc-comments">Doc Comments</a></h2>
<p>Comments are used to communicate information to anyone reading the source code, but are completely ignored by the
compiler. We usually talk about two styles of comments:</p>
<ul>
<li>Line comments: starting at <code>//</code> and ending at the end of the line</li>
<li>Block comments: starting at <code>/*</code> and ending with <code>*/</code></li>
</ul>
<p>Many languages like Java, JavaScript, PHP, and more, also support a special type of comment called a Doc Comment. Like
comments, these are to convey information about nearby code, and are ignored by the compiler, however you can use
documentation tooling to read them and produce the documentation for you.</p>
<p>Rust takes this idea and turbocharges it… but we’ll get to that.</p>
<p>For now, there are two subtypes of Doc Comments:</p>
<ul>
<li>Outer Doc Comments</li>
<li>Inner Doc Comments</li>
</ul>
<p>It’s possible to create these comments as either line comments or block comments <em>however</em>, the convention<sup class="footnote-reference" id="fr-rfc1574-1"><a href="#footnote-rfc1574">1</a></sup> is
to always use line comments, even if the comment spans many lines. The reason for this appears to be ambiguity in
terminating block comments, and the desire for consistency.</p>
<p>Outer Doc Comments are placed before the thing that’s being documented and use <code>///</code> for each line of the comment, and
we’ll use them for most things like modules, types and our <code>add()</code> function.</p>
<pre><code class="language-rust noplayground">/// Adds two numbers together.
pub fn add(a: usize, b: usize) -&gt; usize {
    a + b
}</code></pre>
<p>We can re-run <code>cargo doc</code> and refresh the page in our browser and our <code>add</code> function now has a little explanation.</p>
<p><img src="documentation/rustdoc-3.png" alt="add() description" /></p>
<p>That’s neat, but we could have worked that out from the name. Rust documentation uses markdown, which means we can
use formatting and code snippets, as well as consecutive lines being treated as a single paragraph. Let’s add some more
detail and explain how to use the function using the same technique we learned in the last chapter, assertions.</p>
<p>Doing it this way may seem odd, but all will be explained in a moment.</p>
<pre><code class="language-rust noplayground">/// Adds two numbers together.
///
/// You can use this function to add two `usize` numbers together. It's a little bit pointless, obviously, we're only
/// doing this to demonstrate the benefits of good documentation.
///
/// ```
/// use iriss_documentation::add;
///
/// let a = 40;
/// let b = 2;
/// let c = add(a, b);
///
/// assert_eq!(c, 42, "We expect {a} + {b} = 42");
/// ```
pub fn add(a: usize, b: usize) -&gt; usize {
    a + b
}</code></pre>
<p>Rebuilding our documentation now gives us the code sample too, isn’t that cute!</p>
<p><img src="documentation/rustdoc-4.png" alt="add() with code sample" /></p>
<p>What’s also cool, is that if we go back to the top level of our library where our <code>add</code> function was listed, you can
see that <code>add</code> now has a nice little summary, it’s the first line of our documentation. This is worth bearing in mind
as you write your documentation. Try to keep this line terse but descriptive.</p>
<p><img src="documentation/rustdoc-5.png" alt="Summary of add()" /></p>
<p>Before we move on, we should also provide some documentation for our library. We can’t put Outer Doc Comments before the
library because the library <em>is</em> the file. Instead, we use Inner Doc Comments, which are prefixed with <code>//!</code>. We do this
at the top of the file. Let’s provide a little</p>
<pre><code class="language-rust ignore">//! This library does little more than provide us a way of playing with documentation
//!
//! We can use all kinds of markdown in Doc Comments, including:
//!
//! Various
//! =======
//!
//! Heading
//! -------
//!
//! ### Styles
//!
//! Horizontal lines
//!
//! ---
//!
//! And even code!
//!
//! ```
//! println!("Hello, world!");
//! ```

/// ...
pub fn add(a: usize, b: usize) -&gt; usize { /* ... */ }</code></pre>
<p>And all of this will render nicely into our documentation.</p>
<p><img src="documentation/rustdoc-6.png" alt="Top level documentation" /></p>
<blockquote>
<p>ℹ️ Note: You can use Inner Doc Comments for all sorts of things, like modules that are in curly brackets. But, again,
the convention<sup class="footnote-reference" id="fr-rfc1574-2"><a href="#footnote-rfc1574">1</a></sup> is to only use Inner Doc Comments for files, whether thats your main library file, or module
files (eg, <code>my_module/mod.rs</code>, or <code>./my_module.rs</code>).</p>
</blockquote>
<h2 id="doc-tests"><a class="header" href="#doc-tests">Doc-Tests</a></h2>
<p>Some people say tests should be the documentation, but here we say the documentation should be the tests!</p>
<p>Well, ok, not <em>the</em> test, you absolutely should still write your unit tests, etc. 😅</p>
<p>But without doing anything else to our project, try running <code>cargo test</code>.</p>
<p><img src="documentation/doc-tests.png" alt="Doc-Tests" /></p>
<p>There’s a few things to notice here.</p>
<p>First, we seem to be getting three sets of tests. Second, we have two passing tests… but we didn’t write any tests,
did we?</p>
<p>The order of test suites, and individual tests you see may differ from the above, but you should have one test suite
for our library (<code>lib.rs</code>), one test suite for our binary (<code>iriss-documentation.rs</code>), and one for Doc-tests. The first
two have no tests, but Doc-tests have two tests.</p>
<p>What’s happened here is that <code>cargo test</code> is treating any code samples as tests (unless we ask it not to).</p>
<p>Let’s quickly add a test to <code>lib.rs</code> to look more closely at the difference.</p>
<pre><code class="language-rust ignore">//! ...

/// ...
pub fn add(a: usize, b: usize) -&gt; usize { /* ... */ }

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_add() {
        let a = 40;
        let b = 2;
        let c = add(a, b);

        assert_eq!(c, 42, "We expect {a} + {b} = 42");
    }
}
</code></pre>
<p>Now when we run again we get some interesting comparison.</p>
<p>Unit Tests:</p>
<p><img src="documentation/doc-tests-comparison-unit.png" alt="Unit Tests" /></p>
<p>Doc Tests:</p>
<p><img src="documentation/doc-tests-comparison-doc.png" alt="Doc Tests" /></p>
<p>In the unit test, the test name is the fully qualified path to the test function (<code>test::test_add</code>)</p>
<p>In the doc tests, it’s the file, the name of the thing being documented (unless it <em>is</em> the file) and the line of the
start of the code block.</p>
<p>This makes them slightly less useful <em>as</em> tests. So why would we do it?</p>
<p>Well, the leading cause of bad documentation, and the reason why people so often don’t bother writing it to start with
is that it needs to be maintained. One of the worst things we can do in documentation is tell someone they can achieve
an outcome in a particular way, then change the code so that particular way no longer works as expected.</p>
<p>Writing our documentation as a test ensures that our documentation is correct, and keeping our documentation right next
to the thing being documented makes it trivial to update. Rust guarantees that if you said the code works in a
particular way, so long as you also wrote an example with assertions, then the documentation is correct!</p>
<h2 id="sharing-documentation"><a class="header" href="#sharing-documentation">Sharing Documentation</a></h2>
<p>To paraphrase Dr Strangelove: Of course, the whole point of <strong>documentation</strong> is lost, if you keep it a secret!</p>
<p>How do we tell people about our documentation?</p>
<p>There’s two ways documentation gets shared and neither of them require any work on your behalf.</p>
<p>We’ll go into this a further in the ecosystem section of the book, however when you’re ready to share your code, we
use cargo to “publish” the code to <a href="https://crates.io" title="" target="_blank">crates.io</a>. When someone downloads your code from there, they
get the source code which includes your documentation. This means when they build their documentation, they can also
build your documentation.</p>
<p>The second way our documentation is shared is that when we publish to crates.io, our documentation is compiled and
uploaded to another service, <a href="https://docs.rs" title="" target="_blank">docs.rs</a>. On this service you can find every version of API documentation
for every crate (library) ever published!</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>So Rust documentation has some really compelling things going on:</p>
<ol>
<li>Documentation tooling comes with the rust tool suite</li>
<li>Documentation is written with code, not separately from it</li>
<li>Code examples are run with tests, meaning it’s very hard to produce documentation that’s wrong</li>
</ol>
<p>Because the prescribed method of writing documentation is so good, everyone ends up using the same tools and the same
conventions, which means Rust documentation will always feel somewhat familiar, significantly reducing the burden of
learning.</p>
<p>It’s one of the many examples of how the Rust community feeds into itself, helping us all be better software engineers.</p>
<h2 id="homework"><a class="header" href="#homework">Homework</a></h2>
<p>In the last chapter, we asked you to do three things, one at a time, starting with the test and then writing the
implementation.</p>
<ol>
<li>Create a function that will reverse the words in an English sentence.</li>
<li>If the string starts or ends with whitespace, it should be removed (trimmed) from the returned String.</li>
<li>If the string contains more than one sentence, the function should return an error (though for now, that error can
be the unit type <code>()</code>).</li>
</ol>
<blockquote>
<p>Please note an earlier version of this book had 4 requirements, the second one has been removed. See the
<a href="https://www.youtube.com/watch?v=MLTy-UmLCnk?t=856" title="" target="_blank">homework section of this chapter’s video</a> to see how it can be
solved, and why I chose to remove it.</p>
</blockquote>
<p>We want to start with the test, but we can’t create the test without the function existing, so the easiest way to
proceed is to design the interface of the function and use the <code>todo!</code> macro so that we can integrate it into a test.
We know later we’ll want to return an Error, so we’ve got a string slice input, and a Result output where the Ok variant
is a <code>String</code>.</p>
<pre><code class="language-rust noplayground">fn reverse_sentence(_input: &amp;str) -&gt; Result&lt;String, ()&gt; {
    todo!("Write the reverse_sentence function")
}</code></pre>
<p>We then create our first test, but because our first requirement doesn’t tell us too much, we’ll keep it simple; all
lowercase, no punctuation.</p>
<pre><code class="language-rust noplayground"><span class="boring">fn reverse_sentence(_input: &amp;str) -&gt; Result&lt;String, ()&gt; {
</span><span class="boring">    todo!("Write the reverse_sentence function")
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_reverse_words() {
        let input = "this is my test input";
        let output = reverse_sentence(input);
        assert_eq!(output, Ok("input test my is this".to_string()));
    }
}</code></pre>
<p>Now that we have a failing test, let’s fix the code. I’m going to use our split_around_many function but if you used the
built-in split function instead, well done, bonus points to you! It’s actually more efficient that way, and you can in
fact reduce the memory allocations down to just one.</p>
<p>I decided to stick with our existing functions for simplicity. We can split the string around spaces to get a vector of
words, then we can call reverse on the vector to get the words in the opposite order. Finally, we can join the vector of
strings with spaces to create our output string.</p>
<pre><code class="language-rust noplayground"><span class="boring">fn split_around_many_recurse&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str, collection: &amp;mut Vec&lt;&amp;'a str&gt;) {
</span><span class="boring">    if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">        let end_pos = found_at + sub_string.len();
</span><span class="boring">        collection.push(&amp;input[..found_at]);
</span><span class="boring">        split_around_many_recurse(&amp;input[end_pos..], sub_string, collection);
</span><span class="boring">    } else {
</span><span class="boring">        collection.push(&amp;input);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn split_around_many&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut output = Vec::with_capacity(input.matches(sub_string).count());
</span><span class="boring">    split_around_many_recurse(input, sub_string, &amp;mut output);
</span><span class="boring">    output
</span><span class="boring">}
</span><span class="boring">
</span>fn reverse_sentence(input: &amp;str) -&gt; Result&lt;String, ()&gt; {
    let mut words: Vec&lt;&amp;str&gt; = split_around_many(input, " ");
    words.reverse();
    Ok(words.join(" "))
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">    
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_reverse_words() {
</span><span class="boring">        let input = "this is my test input";
</span><span class="boring">        let output = reverse_sentence(input);
</span><span class="boring">        assert_eq!(output, Ok("input test my is this".to_string()));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Now the test passes.</p>
<p>Next let’s look at trimming the string.</p>
<p>In the requirements I did say “any whitespace” so let’s test with a space on one end and a tab on the other.</p>
<pre><code class="language-rust noplayground"><span class="boring">fn split_around_many_recurse&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str, collection: &amp;mut Vec&lt;&amp;'a str&gt;) {
</span><span class="boring">    if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">        let end_pos = found_at + sub_string.len();
</span><span class="boring">        collection.push(&amp;input[..found_at]);
</span><span class="boring">        split_around_many_recurse(&amp;input[end_pos..], sub_string, collection);
</span><span class="boring">    } else {
</span><span class="boring">        collection.push(&amp;input);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn split_around_many&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut output = Vec::with_capacity(input.matches(sub_string).count());
</span><span class="boring">    split_around_many_recurse(input, sub_string, &amp;mut output);
</span><span class="boring">    output
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn reverse_sentence(input: &amp;str) -&gt; Result&lt;String, ()&gt; {
</span><span class="boring">    let mut words: Vec&lt;&amp;str&gt; = split_around_many(input, " ");
</span><span class="boring">    words.reverse();
</span><span class="boring">    Ok(words.join(" "))
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    // ...
<span class="boring">    #[test]
</span><span class="boring">    fn test_reverse_words() {
</span><span class="boring">        let input = "this is my test input";
</span><span class="boring">        let output = reverse_sentence(input);
</span><span class="boring">        assert_eq!(output, Ok("input test my is this".to_string()));
</span><span class="boring">    }
</span>
    #[test]
    fn test_reverse_words_trims_string() {
        let input = " this string has weird whitespace\t";
        let output = reverse_sentence(input);
        assert_eq!(output, Ok("whitespace weird has string this".to_string()));
    }
}</code></pre>
<p>Again, this test won’t pass when we run it, so let’s implement the feature.</p>
<p>String slices have a <a href="https://doc.rust-lang.org/std/primitive.str.html#method.trim" title="" target="_blank">method called <code>.trim()</code></a>, which will
return a string slice that points to the characters inside the original string slice without surrounding whitespace.
This is really cool because it means we didn’t need to allocate any more memory. We can also shadow the <code>input</code>
variable, so we only need to add one line to the function!</p>
<pre><code class="language-rust noplayground"><span class="boring">fn split_around_many_recurse&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str, collection: &amp;mut Vec&lt;&amp;'a str&gt;) {
</span><span class="boring">    if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">        let end_pos = found_at + sub_string.len();
</span><span class="boring">        collection.push(&amp;input[..found_at]);
</span><span class="boring">        split_around_many_recurse(&amp;input[end_pos..], sub_string, collection);
</span><span class="boring">    } else {
</span><span class="boring">        collection.push(&amp;input);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn split_around_many&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut output = Vec::with_capacity(input.matches(sub_string).count());
</span><span class="boring">    split_around_many_recurse(input, sub_string, &amp;mut output);
</span><span class="boring">    output
</span><span class="boring">}
</span><span class="boring">
</span>fn reverse_sentence(input: &amp;str) -&gt; Result&lt;String, ()&gt; {
    let input = input.trim();
    let mut words: Vec&lt;&amp;str&gt; = split_around_many(input, " ");
    words.reverse();
    Ok(words.join(" "))
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_reverse_words() {
</span><span class="boring">        let input = "this is my test input";
</span><span class="boring">        let output = reverse_sentence(input);
</span><span class="boring">        assert_eq!(output, Ok("input test my is this".to_string()));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_reverse_words_trims_string() {
</span><span class="boring">        let input = " this string has weird whitespace\t";
</span><span class="boring">        let output = reverse_sentence(input);
</span><span class="boring">        assert_eq!(output, Ok("whitespace weird has string this".to_string()));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>The final requirement is to return an error if there is more than one sentence. We haven’t dealt with punctuation yet
so let’s create an assertion that an ending dot is fine, and a second assertion that one in the middle of a sentence
causes an error. The first assertion should pass without any changes, but helps make sure we don’t break this as we
implement feature.</p>
<pre><code class="language-rust noplayground"><span class="boring">fn split_around_many_recurse&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str, collection: &amp;mut Vec&lt;&amp;'a str&gt;) {
</span><span class="boring">    if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">        let end_pos = found_at + sub_string.len();
</span><span class="boring">        collection.push(&amp;input[..found_at]);
</span><span class="boring">        split_around_many_recurse(&amp;input[end_pos..], sub_string, collection);
</span><span class="boring">    } else {
</span><span class="boring">        collection.push(&amp;input);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn split_around_many&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut output = Vec::with_capacity(input.matches(sub_string).count());
</span><span class="boring">    split_around_many_recurse(input, sub_string, &amp;mut output);
</span><span class="boring">    output
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn reverse_sentence(input: &amp;str) -&gt; Result&lt;String, ()&gt; {
</span><span class="boring">    let input = input.trim();
</span><span class="boring">    let mut words: Vec&lt;&amp;str&gt; = split_around_many(input, " ");
</span><span class="boring">    words.reverse();
</span><span class="boring">    Ok(words.join(" "))
</span><span class="boring">}
</span><span class="boring">
</span>#[cfg(test)]
mod tests {
    use super::*;

    // ...
<span class="boring">    #[test]
</span><span class="boring">    fn test_reverse_words() {
</span><span class="boring">        let input = "this is my test input";
</span><span class="boring">        let output = reverse_sentence(input);
</span><span class="boring">        assert_eq!(output, Ok("input test my is this".to_string()));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_reverse_words_trims_string() {
</span><span class="boring">        let input = " this string has weird whitespace\t";
</span><span class="boring">        let output = reverse_sentence(input);
</span><span class="boring">        assert_eq!(output, Ok("whitespace weird has string this".to_string()));
</span><span class="boring">    }
</span>
    #[test]
    fn test_reverse_words_reject_multiple_sentances() {
        let input = "sentance one.";
        let output = reverse_sentence(input);
        assert_eq!(output, Ok("one. sentance".to_string()));

        let input = "sentance one. sentance two";
        let output = reverse_sentence(input);
        assert_eq!(output, Err(()));
    }
}</code></pre>
<p>To implement this feature, we can check the words iterator after the split, but before the reverse, for any full
stops that occur before the final word. To do this we’ll iterate over the vector, taking all but the last element, and
if any word ends with a <code>.</code> we can assume it’s a sentence break.</p>
<pre><code class="language-rust noplayground"><span class="boring">fn split_around_many_recurse&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str, collection: &amp;mut Vec&lt;&amp;'a str&gt;) {
</span><span class="boring">    if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">        let end_pos = found_at + sub_string.len();
</span><span class="boring">        collection.push(&amp;input[..found_at]);
</span><span class="boring">        split_around_many_recurse(&amp;input[end_pos..], sub_string, collection);
</span><span class="boring">    } else {
</span><span class="boring">        collection.push(&amp;input);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub fn split_around_many&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str) -&gt; Vec&lt;&amp;'a str&gt; {
</span><span class="boring">    let mut output = Vec::with_capacity(input.matches(sub_string).count());
</span><span class="boring">    split_around_many_recurse(input, sub_string, &amp;mut output);
</span><span class="boring">    output
</span><span class="boring">}
</span><span class="boring">
</span>fn reverse_sentence(input: &amp;str) -&gt; Result&lt;String, ()&gt; {
    let input = input.trim();
    let mut words: Vec&lt;&amp;str&gt; = split_around_many(input, " ");
    
    if words
        .iter()
        .take(words.len() - 1)
        .any(|word| word.ends_with('.'))
    {
        return Err(());
    }
    
    words.reverse();
    Ok(words.join(" "))
}
<span class="boring">
</span><span class="boring">#[cfg(test)]
</span><span class="boring">mod tests {
</span><span class="boring">    use super::*;
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_reverse_words() {
</span><span class="boring">        let input = "this is my test input";
</span><span class="boring">        let output = reverse_sentence(input);
</span><span class="boring">        assert_eq!(output, Ok("input test my is this".to_string()));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_reverse_words_trims_string() {
</span><span class="boring">        let input = " this string has weird whitespace\t";
</span><span class="boring">        let output = reverse_sentence(input);
</span><span class="boring">        assert_eq!(output, Ok("whitespace weird has string this".to_string()));
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    #[test]
</span><span class="boring">    fn test_reverse_words_reject_multiple_sentances() {
</span><span class="boring">        let input = "sentance one.";
</span><span class="boring">        let output = reverse_sentence(input);
</span><span class="boring">        assert_eq!(output, Ok("one. sentance".to_string()));
</span><span class="boring">
</span><span class="boring">        let input = "sentance one. sentance two";
</span><span class="boring">        let output = reverse_sentence(input);
</span><span class="boring">        assert_eq!(output, Err(()));
</span><span class="boring">    }
</span><span class="boring">}</span></code></pre>
<p>Were we doing this properly, of course we’d use proper errors… but proper errors are for another time 😉</p>
<p>This time for the homework, I’d like you to create a library that contains our three split functions from the last few
chapters (I’ve rewritten them below, use the 👁️ icon to show hidden lines).</p>
<pre><code class="language-rust noplayground">pub fn split_at(input: &amp;str, at: usize) -&gt; (&amp;str, &amp;str) {
<span class="boring">    let up_to = std::cmp::min(at, input.len()); // Prevent out of bounds
</span><span class="boring">    (&amp;input[..up_to], &amp;input[up_to..])
</span>}

pub fn split_around&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str) -&gt; (&amp;'a str, &amp;'a str) {
<span class="boring">    if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">      (&amp;input[..found_at], &amp;input[found_at + sub_string.len()..])
</span><span class="boring">    } else {
</span><span class="boring">      (&amp;input[..], &amp;input[input.len()..])
</span><span class="boring">    }
</span>}

<span class="boring">fn split_around_many_recurse&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str, collection: &amp;mut Vec&lt;&amp;'a str&gt;) {
</span><span class="boring">    if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">        let end_pos = found_at + sub_string.len();
</span><span class="boring">        collection.push(&amp;input[..found_at]);
</span><span class="boring">        split_around_many_recurse(&amp;input[end_pos..], sub_string, collection);
</span><span class="boring">    } else {
</span><span class="boring">        collection.push(&amp;input);
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>pub fn split_around_many&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str) -&gt; Vec&lt;&amp;'a str&gt; {
<span class="boring">    let mut output = Vec::with_capacity(input.matches(sub_string).count());
</span><span class="boring">    split_around_many_recurse(input, sub_string, &amp;mut output);
</span><span class="boring">    output
</span>}</code></pre>
<p>You can make a library directly with no executable with <code>cargo new --lib &lt;name&gt;</code> where <code>&lt;name&gt;</code> is whatever you want to
call it, this saves you moving things around too much.</p>
<p>Write documentation for the functions that explains how they work with code samples and assertions. Note that the
<code>split_around_many_recurse</code> function probably shouldn’t be public, so you won’t see it in your library documentation.</p>
<hr>
<ol class="footnote-definition"><li id="footnote-rfc1574">
<p>https://rust-lang.github.io/rfcs/1574-more-api-documentation-conventions.html <a href="#fr-rfc1574-1">↩</a> <a href="#fr-rfc1574-2">↩2</a></p>
</li>
</ol>
                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../language-basics/tests.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../language-basics/clippy-and-fmt.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../language-basics/tests.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../language-basics/clippy-and-fmt.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>

<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Collections - Idiomatic Rust in Simple Steps</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Learn idiomatic Rust in simple steps even if you have no former knowledge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Idiomatic Rust in Simple Steps</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="collections"><a class="header" href="#collections">Collections</a></h1>
<p>The Rust standard library gives you several ways to store a collection of items that are all the same type. Some of them
you'll use quite a lot, like <code>Vec</code> and <code>HashMap</code>, but there's a few more that have interesting features that can be
useful in specific circumstances.</p>
<p>This chapter will mostly focus on the collections you'll use the most, but we'll cover all the other collections
provided by the Rust standard library. Collections are commonly used with iterators, which allow you to step though
lists one item at a time, but we'll cover those in the next chapter.</p>
<h2 id="arrays"><a class="header" href="#arrays">Arrays</a></h2>
<p>Arrays are... technically not collections. Or at least, they are quite different to the other collections in one key
way.</p>
<p>They're <code>Sized</code>!</p>
<p>While other collections can have elements added to or removed from them, Arrays are always the same size. This means
that they can exist on the stack, which further means they can be <code>Copy</code> (so long as the type stored in the array is
also <code>Copy</code>).</p>
<p>We can create arrays in two ways, either by defining a list of expressions, or by using an expression and a length:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let a1 = [0, 1, 2, 3, 4, 5]; // A list of values
let a2 = [1 - 1, 1 * 1, 1 + 1, 9 / 3]; // A list of expressions
let a3 = [1 + 2; 5]; // Fill an array with the result of a single expression, evaluated once

assert_eq!(a1, [0, 1, 2, 3, 4, 5]);
assert_eq!(a2, [0, 1, 2, 3]);
assert_eq!(a3, [3, 3, 3, 3, 3]);
<span class="boring">}</span></code></pre></pre>
<p>You can access arrays using square brackets and the index of the entry you want to edit, however, if the index doesn't
exist, your code will panic.</p>
<pre><pre class="playground"><code class="language-rust should_panic"><span class="boring">fn main() {
</span>let arr = [0, 1, 2, 3, 4];
for i in 0..=5 {
    println!("{}", arr[i]);
}
<span class="boring">}</span></code></pre></pre>
<p>That said, because Arrays are sized, Rust is smart enough to know that you've hardcoded an index out of bounds, so this
won't even compile!</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">fn main() {
</span>let arr = [0, 1, 2, 3, 4];
let _ = arr[5];
<span class="boring">}</span></code></pre></pre>
<p>You can pass arrays into functions so long as you know the exact length of the array. If the contents of the array is
<code>Copy</code> then the array will also be <code>Copy</code> and will be passed with Copy Semantics instead of Move Semantics.</p>
<pre><pre class="playground"><code class="language-rust">fn demonstrate_some_mutation(mut arr: [usize; 5]) {
    // Because the array is passed using copy semantics, it doesn't matter if the original variable was mutable.
    // Also, because we know the array _must_ have five elements, it's safe to directly access elements we know exist
    arr[0] = 100;
    assert_eq!(arr, [100, 1, 1, 1, 1]);
}

<span class="boring">fn main() {
</span>// Reminder: Simply passing a1 to a function that takes an array of `usize`s is enough to infer the type 
let a1 = [1; 5];
assert_eq!(a1, [1, 1, 1, 1, 1]);

// Because the contents of the array is `Copy`, the array is `Copy`.
// This means it will use copy semantics when passed to the function
demonstrate_some_mutation(a1);

// So we can still use the original variable, _and_ it hasn't been mutated.
assert_eq!(a1, [1, 1, 1, 1, 1]);
<span class="boring">}</span></code></pre></pre>
<p>Note: This won't compile because the a2 is the wrong size</p>
<pre><pre class="playground"><code class="language-rust compile_fail">fn demonstrate_some_mutation(mut arr: [usize; 5]) {
    // ...
<span class="boring">    arr[0] = 100;
</span><span class="boring">    assert_eq!(arr, [100, 1, 1, 1, 1]);
</span>}
<span class="boring">fn main() {
</span>let a2 = [1; 4];
demonstrate_some_mutation(a1);
<span class="boring">}</span></code></pre></pre>
<h2 id="slices"><a class="header" href="#slices">Slices</a></h2>
<p>Obviously, passing exactly sized arrays around isn't particularly useful in most real world circumstances. So the first
dynamically sized collection we should talk about is the "slice".</p>
<p>You can think of a slice as a view or window into a series of contiguous data. The fact that it's a view of some
other type hopefully indicates to you that this is a reference type, i.e. <code>&amp;[T]</code> or <code>&amp;mut [T]</code> for mutable slices.</p>
<p>The simplest way to get a slice is to reference an array (though some other collections also allow you to take a slice).</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let arr: [u32; 5] = [0, 1, 2, 3, 4];
let slice: &amp;[u32] = &amp;arr;

assert_eq!(slice, &amp;[0, 1, 2, 3, 4]);
<span class="boring">}</span></code></pre></pre>
<p>You can also use range notation, <a href="./control-flow.html#range">which we've discussed before</a>, including open ranges, which
we didn't discuss at the time. The way to think about this is, where <code>X..Y</code>:</p>
<ul>
<li>if X is specified, the slice begins before the <code>X</code>th element</li>
<li>if X is not specified, the slice begins at the start of the collection being sliced</li>
<li>if Y is specified, the slice ends before the <code>Y</code>th element</li>
<li>if Y is preceded by an equals, the slice ends after the <code>Y</code>th element</li>
<li>if Y is not specified, the slice ends at the end of the collection being sliced</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let array: [u32; 5] = [0, 1, 2, 3, 4];

assert_eq!(&amp;array[1..3],  &amp;[1, 2]);       // X is specified, slice begins before the `X`
assert_eq!(&amp;array[..3],   &amp;[0, 1, 2]);    // no X, slice begins at the start
assert_eq!(&amp;array[1..3],  &amp;[1, 2]);       // Y is specified, slice ends before the `Y`
assert_eq!(&amp;array[1..=3], &amp;[1, 2, 3]);    // =Y , slice ends after the `Y`
assert_eq!(&amp;array[1..],   &amp;[1, 2, 3, 4]); // no Y, slice ends at the end
<span class="boring">}</span></code></pre></pre>
<p>When using slices, you don't need ot specify their size, that information is encoded into the data at runtime, meaning
you can work with slices of arbitrary size. Bear in mind though that they are references, so you <em>may</em> need to use
lifetimes to keep track. We discussed <a href="./functions.html#lifetimes">lifetimes in the functions chapter</a>, however as a quick
reminder, if the reference is a kite, lifetimes are the string that tie it back to the owning data.</p>
<p>In the functions chapter we discussed a function for splitting a <code>String</code> which returned two <code>&amp;str</code> or "string slice
references". That's right, <code>str</code> is another, special, kind of slice. Below is that code again, and here's some things to
note that will hopefully make a lot more sense after the last few chapters:</p>
<ul>
<li><code>String</code> implements <code>Deref</code> targeting <code>str</code> so we can get a string slice just by referencing <code>String</code></li>
<li>The lifetime <code>'a</code> (attached to <code>yuki</code>) enters <code>split()</code> through <code>input</code> and is tied to the return parameters <code>left</code>
and <code>right</code>.</li>
<li>The same range notation is used to create the slices as above</li>
<li>In the "<code>found_at</code>" branch, open ranges are used to capture the beginning and end for <code>left</code> and <code>right</code> respectively</li>
<li>In the "<code>else</code>" branch, the completely open range creates a slice the full length of the collection, while the slice
that starts at <code>input.len()</code> is a zero length slice that starts before the element that <em>would</em> be after the final
element (i.e. it starts after the final element) and runs to the end (i.e. the same place as it starts).</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn split&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str) -&gt; (&amp;'a str, &amp;'a str) {
    if let Some(found_at) = input.find(sub_string) {
      (&amp;input[..found_at], &amp;input[found_at + sub_string.len()..])
    } else {
      (&amp;input[..], &amp;input[input.len()..])
    }
}

<span class="boring">fn main() {
</span>let yuki = "yuki".to_string();
let sub_string = "uk".to_string();

let (left, right) = split(&amp;yuki, &amp;sub_string);

assert_eq!(yuki, "yuki");
assert_eq!(left, "y");
assert_eq!(right, "i");
<span class="boring">
</span><span class="boring">// Here's some test code to make sure I'm telling you the right think
</span><span class="boring">let yuki = "yuki".to_string();
</span><span class="boring">let sub_string = "daniel".to_string();
</span><span class="boring">
</span><span class="boring">let (left, right) = split(&amp;yuki, &amp;sub_string);
</span><span class="boring">
</span><span class="boring">assert_eq!(yuki, "yuki");
</span><span class="boring">assert_eq!(left, "yuki");
</span><span class="boring">assert_eq!(right, "");
</span><span class="boring">}</span></code></pre></pre>
<p>Hopefully code like this is starting to make a lot more sense!</p>
<h2 id="vectors"><a class="header" href="#vectors">Vectors</a></h2>
<p><code>Vec</code> (short for Vector) is similar to an array (and can be dereferenced as an array slice), but unlike array, <code>Vec</code> can
grow in size. <code>Vec</code> is a generic type (<code>Vec&lt;T&gt;</code>) with no trait bound, meaning you use them with any type.</p>
<p>There are several ways to instantiate <code>Vec</code>s, and which way is best can vary depending on how you're going to use them.</p>
<p>The fact that <code>Vec</code>s are dynamically sized means they need to exist on the Heap, and so, your program, under the hood,
will request an amount of heap memory. If your vector exceeds the amount of memory that is currently available to it,
code inside the <code>Vec</code> type will automatically request a new, larger, portion of memory from the operating system, copy
the current data into that new location, then free the memory it used to hold, all automatically without you needing to
do anything. This process however is expensive, and you should do what you can to avoid it.</p>
<p>With that in mind, you should try to start with a vector large enough to contain as much as you think is reasonable,
using the <code>::with_capacity(capacity: usize)</code> constructor. This will construct an empty <code>Vec</code> with at least (but possibly
not exactly) the capacity you requested. Note that capacity and length are not the same thing in Rust. You can get the
number of items of data currently in the vector with <code>.len()</code> and its capacity with <code>.capacity()</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let example: Vec&lt;i32&gt; = Vec::with_capacity(10);
assert_eq!(example.len(), 0);
assert!(example.capacity() &gt;= 10);
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Note: There is no guarantee that capacity will be exactly what you asked for, only that it will be <em>at least</em> what you
asked for. Additionally, if you start with a smaller <code>Vec</code> and need to add a lot of items to it, you can preempt
thrashing the heap with the <code>.reserve()</code> method which works similarly to <code>::with_capacity()</code> but can be used to
increase the capacity after the <code>Vec</code> has been instantiated with minimal reallocations.</p>
</blockquote>
<p>If you're not worried about the potential costs of resizing your vector, and you already have some data that you want to
instantiate, you can use the <code>vec!</code> macro.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let example = vec![0, 1, 2, 3];
assert_eq!(example.len(), 4);
<span class="boring">}</span></code></pre></pre>
<p>Usually you'll make Vectors mutable, and they provide a huge array of useful methods (pun intended), but here are some
of the basics.</p>
<p>To add elements to the end of a vector we use the <code>.push(t: T)</code> method, and to remove them from the end of the vector
we use the <code>.pop()</code> method which returns an <code>Option&lt;T&gt;</code>, since the vector may be empty.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let mut v = Vec::with_capacity(2);
v.push("Hello");
v.push("World!");

// v as it is now
assert_eq!(v, vec!["Hello", "World!"]);

// popping returns an option containing the last element of the vector (if there are no items the Option will be None)
assert_eq!(v.pop(), Some("World!"));

// popping an item from the vector modifies the vector so it no longer contains the last item
assert_eq!(v, vec!["Hello"]);
<span class="boring">}</span></code></pre></pre>
<p>If you're used to arrays and vectors in other languages, you <em>can</em> index directly into an array in Rust in the same way
that you can in other languages <em>but</em> you generally shouldn't. If you try to access an element out of bounds (eg, if you
have 3 items in your vector, and try to access the fifth), your program will panic.</p>
<pre><pre class="playground"><code class="language-rust should_panic"><span class="boring">fn main() {
</span>let v = vec!["Hello", "World!"];
assert_eq!(v[0], "Hello");
assert_eq!(v[1], "World!");
let _ = v[2]; // ❗️Panics❗️
<span class="boring">}</span></code></pre></pre>
<p>Instead, Vec provides <code>.get()</code> and <code>.get_mut()</code> which allow return an <code>Option</code> containing either an immutable or mutable
reference to an item inside the vector. This is much safer as the program will not halt if there is no item at the given
index, you'll simply get a <code>None</code>.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let v = vec!["Hello", "World!"];
assert_eq!(v.get(0), Some(&amp;"Hello"));
assert_eq!(v.get(1), Some(&amp;"World!"));
assert_eq!(v.get(2), None);
<span class="boring">}</span></code></pre></pre>
<p><code>.get_mut()</code> will return a mutable reference to the element inside the Vec, <em>but</em> the way we use it... is a little
weird:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let mut v = vec!["Hello".to_string()];
if let Some(hello) = v.get_mut(0) {
    assert_eq!(hello, &amp;mut "Hello".to_string());
    hello.push_str(", World!");
}
assert_eq!(v, vec!["Hello, World!".to_string()]);
<span class="boring">}</span></code></pre></pre>
<p><code>.get()</code> and <code>.get_mut()</code> will also allow you to create an array slice if you give it a <code>Range</code> instead.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let mut v = vec![0, 1, 2, 3, 4, 5];

// Note the weird syntax as `get` returns an array slice, not an array
assert_eq!(v.get(2..), Some(&amp;[2, 3, 4, 5][..])); 
assert_eq!(v.get(..2), Some(&amp;[0, 1][..]));
assert_eq!(v.get(6..), Some(&amp;[][..]));

// You can even edit values inside the returned slice
if let Some(mut inner) = v.get_mut(2..) {
    inner[0] += 10; // Be careful, this is actually element 2!
};

assert_eq!(v, vec![0, 1, 12, 3, 4, 5]);
<span class="boring">}</span></code></pre></pre>
<p>Finally, we can also create slice using square brackets and this actually works without panicking:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let v = vec![0, 1, 2, 3, 4, 5];

// This would panic:
// assert_eq!(v[6], 0);
// But this doesn't:
assert_eq!(v[6..], []);
<span class="boring">}</span></code></pre></pre>
<h4 id="a-note-on-ownership"><a class="header" href="#a-note-on-ownership">A note on ownership</a></h4>
<p>When you put a variable into a <code>Vec</code>, or any other collection, unless that variable is copy you are moving ownership
into the collection. Using methods like <code>get</code> will give you a reference to the data, but the only way to get ownership
back is to either clone in (and take the potential memory and runtime hit), or to remove to use a method that removes
the element from the collection, like <code>pop</code> in <code>Vec</code>. We'll discuss similar methods for other collections as we go.</p>
<h3 id="vecdequeue"><a class="header" href="#vecdequeue">VecDequeue</a></h3>
<p><code>VecDeque</code> is very similar to <code>Vec</code> however, where in <code>Vec</code> you can only add and remove items from the end, <code>VecDeque</code>
also allows you to add and remove items to and from the front!</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::VecDeque;

<span class="boring">fn main() {
</span>let mut v = VecDeque::from([0, 1, 2, 3, 4, 5]);

v.push_back(6);
v.push_front(-1);

assert_eq!(v, [-1, 0, 1, 2, 3, 4, 5, 6]);
assert_eq!(v.pop_front(), Some(-1));
assert_eq!(v.pop_front(), Some(0));
assert_eq!(v.pop_back(), Some(6));
assert_eq!(v, [1, 2, 3, 4, 5]);
<span class="boring">}</span></code></pre></pre>
<h3 id="linked-lists"><a class="header" href="#linked-lists">Linked Lists</a></h3>
<p>It's very rare to actually need a full <code>LinkedList</code>, and for performance reasons, you should try to avoid them where
possible. <code>Vec</code> and <code>VecDeque</code> will almost always beat <code>LinkedList</code> in both speed and memory efficiency if all you want
to do is add items to the end of a list (or, in the case of <code>VecDeque</code> to the front).</p>
<p>Where <code>LinkedList</code>s are useful though, is when splitting and merging your collection is a core feature you will be
heavily reliant on.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>use std::collections::LinkedList;

let mut list = LinkedList::new();
list.push_back(1);
list.push_back(3); // ohps! forgot 2!
list.push_back(4);
list.push_back(5);

// This gets us a vec use for comparison.
// Don't worry about this syntax yet, we'll explain it in the next chapter!
let v: Vec&lt;_&gt; = list.iter().copied().collect();
assert_eq!(v, &amp;[1, 3, 4, 5]);

// We can inject the missing number like this
let mut right = list.split_off(1);
list.push_back(2);
list.append(&amp;mut right);

let v: Vec&lt;_&gt; = list.iter().copied().collect();
assert_eq!(v, &amp;[1, 2, 3, 4, 5]);
<span class="boring">
</span><span class="boring">// Weirdly, the append method doesn't consume the other linked list but it does empty it
</span><span class="boring">// This might be useful if you are juggling values linked lists that you want to keep ownership of 
</span><span class="boring">assert_eq!(right.iter().copied().collect::&lt;Vec&lt;_&gt;&gt;(), &amp;[]);
</span><span class="boring">}</span></code></pre></pre>
<h3 id="binaryheap"><a class="header" href="#binaryheap">BinaryHeap</a></h3>
<p><code>BinaryHeap</code>s allow you to add items to a heap in any order, but the first item off the heap is always the largest item
according to <code>Ord</code>.</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::BinaryHeap;

<span class="boring">fn main() {
</span>let mut heap = BinaryHeap::new();

heap.push("A".to_string());
heap.push("C".to_string());
heap.push("B".to_string());

assert_eq!(heap.pop(), Some("C".to_string()));
assert_eq!(heap.pop(), Some("B".to_string()));
assert_eq!(heap.pop(), Some("A".to_string()));
assert_eq!(heap.pop(), None);
<span class="boring">}</span></code></pre></pre>
<p>The obvious limitation here though is, what do you do if you need to know the smallest value in the stack?</p>
<p>In the standard library there's a cool little newtype that can wrap other types and inverts their ordering:</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::BinaryHeap;
use std::cmp::Reverse;

<span class="boring">fn main() {
</span>let mut heap = BinaryHeap::new();

heap.push(Reverse("A".to_string()));
heap.push(Reverse("C".to_string()));
heap.push(Reverse("B".to_string()));

// Bear in mind that the Reverse type is part of what is stored
assert_eq!(heap.pop(), Some(Reverse("A".to_string())));
// Though the inner field is public
assert_eq!(heap.pop().expect("heap was empty").0, "B".to_string());
<span class="boring">}</span></code></pre></pre>
<h2 id="hashmap"><a class="header" href="#hashmap">HashMap</a></h2>
<p>A <code>HashMap</code> is a key value lookup table. The key can be a value of any type, so long as that type implements the
<code>Hash</code> trait (see the <a href="./common-traits.html#hash">previous chapter</a>).  Hashing the key results in a <code>u64</code> that is used to
create the lookup table. There's more details on how hashing works in the
<a href="https://doc.rust-lang.org/std/collections/struct.HashMap.html">official book</a>, including how to create a <code>HashMap</code>
with a different hashing algorithm, but that's beyond the scope of IRISS.</p>
<p>Similar to <code>Vec</code>s, <code>HashMap</code>s can be initialised in a few ways, the main three you're likely to use are:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>use std::collections::HashMap;

// Create an empty hashmap with some arbitrary capacity
let mut hashmap: HashMap&lt;String, String&gt; = HashMap::new();

// Create a hashmap with _at least_ this capacity (helps prevent reallocation if you
// know the largest your hashmap will likely be)
let mut hashmap_with_capcity = HashMap::with_capacity(1);

// You usually won't have to specifically type the HashMap so long as Rust can infer
// the types by what you're inserting into it.
hashmap_with_capcity.insert(
    "Key".to_string(), // Can be anything that implements Hash
    "Value".to_string(), // Can be anything
);

// Create a hashmap with initial values from an array of tuples (K, V) where K: Hash
let mut hashmap_from_array = HashMap::from([
    ("String is Hash".to_string(), "First value".to_string()),
    ("Another Key".to_string(), "Another value".to_string()),
]);
<span class="boring">}</span></code></pre></pre>
<p>To access data you've stored in your hashmap, there's a few handy methods:</p>
<ol>
<li>
<p><code>.get(key: &amp;K)</code> and <code>.get_mut(key: &amp;K)</code> will get references to data if it exists using <code>Option</code>s</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

<span class="boring">fn main() {
</span>let mut map = HashMap::from([
    ("Key".to_string(), "Value".to_string()),
]);

assert_eq!(map.get("Key"), Some(&amp;"Value".to_string()));
assert_eq!(map.get("Not a Key"), None);

if let Some(mut value) = map.get_mut("Key") {
    value.push_str(" Changed");
}

assert_eq!(map.get("Key"), Some(&amp;"Value Changed".to_string()));
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><code>.entry(key: &amp;K)</code> returns a special <a href="https://doc.rust-lang.org/std/collections/hash_map/enum.Entry.html"><code>Entry</code></a>
enum that allows you to modify and existing value if it exists, or insert a value if it doesn't</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

<span class="boring">fn main() {
</span>let mut map = HashMap::from([
    ("Existing Key".to_string(), "Value".to_string()),
]);

map.entry("Existing Key".to_string())
    .and_modify(|value| value.push_str(" Changed"))
    .or_insert("Inserted Value".to_string());

map.entry("Nonexistent Key".to_string())
    .and_modify(|value| value.push_str(" Changed"))
    .or_insert("Inserted Value".to_string());

assert_eq!(map.get("Existing Key"), Some(&amp;"Value Changed".to_string()));
assert_eq!(map.get("Nonexistent Key"), Some(&amp;"Inserted Value".to_string()));
<span class="boring">}</span></code></pre></pre>
</li>
<li>
<p><code>.remove(key: &amp;K)</code> takes a value out of the HashMap (if it exists), allowing you to take ownership of it, and
<code>.remove_entry(key: &amp;K)</code> can be used to gain ownership of both the value <em>and</em> the key as you remove it from the map</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::HashMap;

<span class="boring">fn main() {
</span>let key = "Key".to_string();
let value = "Value".to_string();
// At this point we own these 👆🏻values
 
let mut map = HashMap::with_capacity(1);

map.insert(key, value);
// Here 👆🏻we move ownership into the hashmap
// So this will no longer work:
// println!("{key}, {value}");

// We can recover both the key and the value using `.remove_entry()`
let (recovered_key, recovered_value) = map.remove_entry("Key")
    .expect("key not found");

assert_eq!(&amp;recovered_key, "Key");
assert_eq!(&amp;recovered_value, "Value");
println!("Found {recovered_key}, {recovered_value}");

// Obviously the key abd value will no longer be part of the HashMap
assert_eq!(map.get("Key"), None);
<span class="boring">}</span></code></pre></pre>
</li>
</ol>
<h3 id="btreemap"><a class="header" href="#btreemap">BTreeMap</a></h3>
<p><code>BTreeMap</code> is a Binary Search Tree version of <code>HashMap</code>. For storing arbitrary data it's a touch slower than <code>HashMap</code>,
but it internally sorts keys so that you can easily get the values at the largest and smallest keys, a little bit like a
<code>VecDeque</code>:</p>
<pre><pre class="playground"><code class="language-rust">use std::collections::BTreeMap;

<span class="boring">fn main() {
</span>let mut map = BTreeMap::from([
    ("C Key".to_string(), "Value 1".to_string()),   
    ("A Key".to_string(), "Value 2".to_string()),   
    ("D Key".to_string(), "Value 3".to_string()),   
    ("B Key".to_string(), "Value 4".to_string()),   
]);

// Get references to the first or last key/values according to Ord
assert_eq!(map.first_key_value(), Some((&amp;"A Key".to_string(), &amp;"Value 2".to_string())));
assert_eq!(map.last_key_value(), Some((&amp;"D Key".to_string(), &amp;"Value 3".to_string())));

// There are also methods that return `Entry`s so you can insert of modify as necessary.
map.first_entry().expect("Map had no entries").into_mut().push_str(" Modified First");
map.last_entry().expect("Map had no entries").into_mut().push_str(" Modified Last");

// Finally you can pop from the "front" (first) and "back" (last) of a BTreeMap
assert_eq!(map.pop_first(), Some(("A Key".to_string(), "Value 2 Modified First".to_string())));
assert_eq!(map.pop_last(), Some(("D Key".to_string(), "Value 3 Modified Last".to_string())));
assert_eq!(map.pop_first(), Some(("B Key".to_string(), "Value 4".to_string())));
assert_eq!(map.pop_last(), Some(("C Key".to_string(), "Value 1".to_string())));
<span class="boring">}</span></code></pre></pre>
<h2 id="sets"><a class="header" href="#sets">Sets</a></h2>
<p>There are two Set types in Rust that allow you to store values with no duplicates, <code>HashSet</code> and <code>BTreeSet</code>. These are
implemented using <code>HashMap&lt;K, ()&gt;</code> and <code>BTreeMap&lt;K, ()&gt;</code>, though they "fix" some of the issues you might run in to if
you were to naively do this yourself.</p>
<p>For example, <code>.insert(T)</code> only takes a single value, and methods like <code>.get(K)</code> return an Option with only one value.</p>
<p>The differences between <code>HashSet</code> and <code>BTreeSet</code> are the same as between <code>HashMap</code> and <code>BTreeMap</code>, including <code>BTreeSet</code>
allowing easy access to the "first" and "last". Furthermore, when you turn <code>BTreeSet</code> into an Iterator, it will be in
order!</p>
<p>We'll talk more about Iterators in the next chapter.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../language-basics/common-traits.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../language-basics/iterators.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../language-basics/common-traits.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../language-basics/iterators.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>

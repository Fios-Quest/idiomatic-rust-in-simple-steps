<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Threads - Idiomatic Rust in Simple Steps</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Learn idiomatic Rust in simple steps even if you have no former knowledge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Idiomatic Rust in Simple Steps</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="threads"><a class="header" href="#threads">Threads</a></h1>
<p>Threads allow us to build programs where parts of the program can run independently of one another.</p>
<p>Threads <em>can</em> (big emphasis on "can") help you make faster and more responsive programs.</p>
<p>For example:</p>
<ul>
<li>As a web developer, I would like the server framework I'm using to start responding to the next request before it's
finished responding to the previous request</li>
<li>As a game developer, I would like my game engine to capture player inputs without being blocked by the renderer</li>
<li>As a data engineer, I would like to process large sets of data in parallel</li>
</ul>
<p>We'll step through:</p>
<ul>
<li>how we can run code in a thread, including sending data before it starts</li>
<li>how we can wait for a thread to end, including receiving data when it ends</li>
<li>how we can communicate with running threads</li>
<li>how we can share state between threads</li>
</ul>
<p>We'll also be touching again on our marker traits Send and Sync</p>
<h2 id="what-is-a-thread"><a class="header" href="#what-is-a-thread">What is a thread?</a></h2>
<p>Before we get into the Rust, it's worth discussing what a thread is.</p>
<p>When you run a program, that specific instance of the program is called a Process. The process incorporates not just the
instructions to be run but is an abstraction around various resources that the program has access to, such as memory.</p>
<p>You can run multiple processes which the operating system will schedule separate which could allow you to do more things
at once, however, those processes won't (or at least, shouldn't) have access to the same memory. There are ways to
communicate between processes, but they can be slower and more restrictive than if we could share memory.</p>
<p>The part of the process responsible for executing your code is called a thread, and a single process can have multiple
threads. Threads are scheduled by the operating system independently, allowing one process to do multiple things
effectively concurrently.</p>
<h2 id="starting-a-thread"><a class="header" href="#starting-a-thread">Starting a thread</a></h2>
<p>Your program always has at least one thread, even your basic hello-world program runs in a thread.</p>
<pre><pre class="playground"><code class="language-rust">fn main() {
    println!("Hello, I am in a thread!")
}</code></pre></pre>
<p>What we're interested in today is how we start more threads. This is a process called Spawning.</p>
<p>To spawn a thread, we use <code>std::thread::spawn</code>... but, this will do little on its own. Run the code below, see what's
missing in the output?</p>
<pre><pre class="playground"><code class="language-rust">use std::thread::spawn;

fn main() {
    println!("This is the main thread");
    spawn(|| {
        println!("This is a child thread");
    });
    println!("This is the end of the main thread");
}</code></pre></pre>
<p>Spawning a thread returns a join handler. The join handler is what ties the spawned thread to the thread that spawned
it. When the join handler is dropped, the thread is orphaned. It may still run but, in this case, the process ends at
the end of main, so our spawned thread never got a chance to do anything.</p>
<p>We can tell our main thread to pause and wait for a running thread to end by using the join handler.</p>
<pre><pre class="playground"><code class="language-rust">use std::thread::spawn;

fn main() {
    println!("This is the main thread");
    let handler = spawn(|| {
        println!("This is a child thread");
    });
    handler.join().expect("Child thread panicked");
    println!("This is the end of the main thread");
}</code></pre></pre>
<p>Note, we're using closures here, but functions work just as well and can be better for more complex programs. The only
restriction is: it needs to be <code>FnOnce() -&gt; T + Send + 'static</code>. See
<a href="https://doc.rust-lang.org/std/thread/fn.spawn.html">the documentation</a> for more details.</p>
<pre><pre class="playground"><code class="language-rust">use std::thread::spawn;

fn child() {
    println!("This is also a child thread");
}

fn main() {
    println!("This is the main thread");
    let handler = spawn(child);
    handler.join().expect("Child thread panicked");
    println!("This is the end of the main thread");
}</code></pre></pre>
<p>Exactly <em>when</em> threads are allowed to execute code is controlled by a scheduler which we can't directly manage
ourselves, but we can influence it. Putting one thread to sleep can allow another thread to run. Run this code, then
uncomment the commented lines and run it again.</p>
<pre><pre class="playground"><code class="language-rust editable">use std::thread::{sleep, spawn};
use std::time::Duration;

fn main() {
    let handler = spawn(|| {
        for i in 0..10 {
            println!("Child iteration: {i}");
            // sleep(Duration::from_millis(1));
        }
    });

    for i in 0..10 {
        println!("Main iteration: {i}");
        // sleep(Duration::from_millis(1));
    }

    handler.join().expect("Child thread panicked");
}</code></pre></pre>
<p>So now we can run threads, let's start looking at how to send data back and forth between them.</p>
<p>We can pass data into a thread before it starts so long as the data is <code>Send</code>. We previously talked about this trait in
the <a href="./traits.html">Traits</a> chapter, but to recap, data is <code>Send</code> so long as it can be safely sent between threads, and
this trait is auto-implemented for all types that can be <code>Send</code> (though it is also possible to opt out of it).</p>
<p>We can move data into the closure that will be sent to the thread using the <code>move</code> keyword.</p>
<p>For example:</p>
<pre><pre class="playground"><code class="language-rust">use std::thread::spawn;

fn main() {
    let data = vec![1, 2, 3, 4, 5];

    let handler = spawn(move || {
        data
            .into_iter()
            .for_each(|i| println!("Processing item {i} from the main thread"));
    });

    handler.join().expect("Child thread panicked");
}</code></pre></pre>
<p>You can also return data via the join handler. This means you could pass hard work to a thread and do other work, coming
back to check on the thread at a later time. We can check if the thread is finished with <code>.is_finished()</code>;</p>
<pre><pre class="playground"><code class="language-rust">use std::thread::{sleep, spawn};
use std::time::Duration;

fn main() {
    let data = u16::MIN..u16::MAX;

    let handler = spawn(move || {
        data.map(|i| i as u32).sum::&lt;u32&gt;()
    });

    while !handler.is_finished() {
        println!("Still working!");
        sleep(Duration::from_nanos(100));
    }

    let answer = handler.join().expect("Child thread panicked");

    assert_eq!(answer, 2147385345);
}</code></pre></pre>
<h2 id="sending-messages"><a class="header" href="#sending-messages">Sending messages</a></h2>
<p>Now we can start one thread, there's no stopping us!</p>
<p>Modern schedulers can manage a <em>lot</em> of threads at once, however, so far we can only send data between a child thread
and the parent that started it. What if we want to communicate across multiple threads, or send data to a thread after
we already started it?</p>
<p>Multi-producer, single-consumer (MPSC) is a queue pattern that allows us to create channels with multiple <code>Sender</code>s that
can send messages, and a single <code>Reciever</code> that can receive them. As per the name, Multi-producer, you can clone
<code>Sender</code>s but each of those clones can only send to a single <code>Reciever</code>. The <code>Sender</code> and <code>Receiver</code> types are <code>Send</code>
meaning that you can create them in one thread and send them to another.</p>
<p>Let's create a bunch of threads and give each of them a <code>Sender</code> that points back to a single <code>Reciever</code>, we'll send
that <code>Reciever</code> to a final thread that will collect the data from the other threads.</p>
<pre><pre class="playground"><code class="language-rust">use std::sync::mpsc::channel;
use std::thread::spawn;

fn main() {
    let (sender, receiver) = channel();

    let thread_ids = 0..10;

    // move sender into the closure
    let sending_handlers = thread_ids.map(move |id| {
        // sender is owned by this closure, we want to pass a copy to each
        // child thread so we'll clone it on each iteration
        let cloned_sender = sender.clone();
        // move the cloned sender to the next thread
        spawn(move || {
            cloned_sender.send(format!("Reporting in from thread {id}"))
                .expect("The Receiver was dropped");
        })
    });

    let receiving_handler = spawn(move || {
        while let Ok(message) = receiver.recv() {
            println!("Received message: {message}");
        }
    });


    sending_handlers.for_each(|h| h.join().expect("A sending thread panicked"));

    receiving_handler.join().expect("receiving thread panicked");
}
</code></pre></pre>
<p>For what its worth, there's no built-in way to create a channel with multiple receivers (<code>Receiver</code> is not <code>Clone</code>),
however, there's nothing stopping you building your own type for that, or there are crates that support it like
<a href="https://docs.rs/crossbeam/latest/crossbeam/">Crossbeam</a>.</p>
<h2 id="sharing-state"><a class="header" href="#sharing-state">Sharing State</a></h2>
<p>So now we can send messages across threads, but what if we need multiple threads to have access to the <em>same</em> data,
maybe even able to edit that data. To do this, we need to use types that implement the <code>Sync</code> trait.</p>
<p>Something is <code>Send</code> if it can be sent between threads, but doing this moves ownership from one thread to another.</p>
<p>Something is <code>Sync</code> if a reference to it can be sent between threads, i.e. <code>T</code> is <code>Sync</code> if <code>&amp;T</code> is <code>Send</code>.</p>
<p>Most things are <code>Sync</code>, but we still have to abide the rules of references in that we can have as many immutable
references as we like, but we can only have one mutable reference. Furthermore, references cannot outlive the data they
reference... which is a little harder to confirm with threads. How do you know the thread referencing your data doesn't
exist for longer than the data it's referenced?</p>
<p>This is where <code>std::thread::scope</code> can help us, by providing scoped threads.</p>
<pre><pre class="playground"><code class="language-rust">// We will create a scope and use that to spawn threads instead of spawning 
// them directly.
use std::thread::scope;

fn main() {
    let mut data = String::from("This data is owned by the main thread");

    // The scope function takes a closure with a single parameter that contains
    // the scope context. You use the context to spawn threads
    scope(|s| {
        (0..10).for_each(|_| {
            // We don't _need_ to track the join handler this time, all scoped
            // threads are joined at the end of the scope closure, but if you
            // want to handle a potential thread panic, you can still do that
            // in a scoped thread, by joining the join_handle you get from
            // the `.spawn` method like you would with an unscoped thread from
            // the `spawn` function.
            s.spawn(|| {
                println!("Thread accessing data {}", &amp;data)
            });
        });
    });

    // All scoped threads are joined before the scope function ends, so we are
    // safe to modify the original data.
    data.push_str(" still");

    assert_eq!(&amp;data, "This data is owned by the main thread still");
}</code></pre></pre>
<p>This also works with mutable references but, bear in mind, only one thread can access the mutable reference, and it must
end before we can access our data again.</p>
<pre><pre class="playground"><code class="language-rust">use std::thread::scope;

fn main() {
    let mut data = String::from("This is owned by the main thread");

    scope(|s| {
        s.spawn(|| {
            data.push_str(" but can be modified by a child thread");
        });
    });

    assert_eq!(
        &amp;data,
        "This is owned by the main thread but can be modified by a child thread"
    );
}</code></pre></pre>
<p>So we can share readable data across multiple threads with immutable references, or share writable data temporarily with
a single thread, but what if we want to share read/write access to data across multiple threads.</p>
<p>Let's start by thinking why we can't do this with just references. When we're using threads, multiple parts of our
program can be executed at the same time. Imagine we have two threads that want to change the data behind a reference
based on what is currently stored there, something simple like each thread wants to multiply the data.</p>
<ol>
<li>Thread 1 reads the value from memory into a register</li>
<li>Thread 2 reads the value from memory into a register</li>
<li>Thread 1 multiplies the data and stores it back in memory</li>
<li>Thread 2 multiplies the data and stores it back in memory</li>
</ol>
<p>In this situation, we've lost the effect of Thread 1, which <em>could</em> be a bug.</p>
<p>Let's consider a more serious version of this. Imagine the data rather than just being a single value, is an image
stored in an array like structure, and you're applying multiple processes to the image at the same time. This time, if
one thread were to override another's work, we have a much more obvious problem.</p>
<p>To get around this, we need to prevent two threads accessing the same piece of data at the same time. There is a general
software abstraction concept called a "mutex" that makes access to the data MUTually EXclusive. Rust provides it's mutex
through <code>std::sync::Mutex</code>.</p>
<p>Once you place data inside a Mutex, to access it again, you need to "lock" the Mutex. If the Mutex is already locked,
then the thread currently trying to access the data needs to wait for the existing lock to be released.</p>
<pre><pre class="playground"><code class="language-rust">use std::thread::scope;
use std::sync::Mutex;

fn main() {
    let mut data = Mutex::new(Vec::with_capacity(10));

    scope(|s| {
        (0..10).for_each(|_| {
            s.spawn(|| {
                // .lock() returns a MutexGuard. When it goes out of scope,
                // the lock is dropped. MutexGuard implements Deref and
                // DerefMut for the type inside the Mutex
                let mut guard = data.lock()
                    .expect("another thread with the lock panicked");
                guard.push("Thread reporting in!".to_string());
                // The MutexGuard is dropped after this line
            });
        });
    });

    let guard = data.lock().unwrap();
    assert_eq!(guard.len(), 10);
    guard
        .iter()
        .for_each(|s| assert_eq!(s, &amp;"Thread reporting in!".to_string()));
}</code></pre></pre>
<p>However, there's still a slight problem here. We're currently very dependent on using scoped threads because we need our
references to point back to the owned data, but scoped threads aren't the norm. In fact, most of the time you use
threads in Rust, they will probably be abstracted behind some other framework (for example, a web server, a game engine,
or data processing tools).</p>
<p>The problem, of course, is that we don't know when the owned data will go out of scope and no longer be accessible.</p>
<p>We can solve this problem using an Atomic Reference Count. We haven't discussed reference counting yet as it's usually
fairly niche, however, reference counting allows you to share data around an application without needing to clone it and
side stepping complex reference rules. It works by moving the data you want to share onto the heap, and allowing access
through a reference count type. When you clone the reference count value, instead of the data being cloned, it modifies
its internal count of how many clones currently exist. Every time a reference count type goes out of scope, the count is
decreased. Once the count hits zero, there are no further references to the data and so it can be cleaned up.</p>
<p>Now, if you've paid attention as to why we need a Mutex for modifying data across threads, you'll see that using a
normal reference count won't work. If the reference counter is cloned or dropped while also being cloned or dropped in
another thread, you could end up with an inconsistent number count of references, meaning data gets dropped at the wrong
time. This is why we need a special reference count type, <code>std::sync::Arc</code>, an Atomic Reference Count.</p>
<p>Atomic data types guarantee atomic changes. Atomic changes are guaranteed to appear to be instantaneous to all external
observers, meaning that two threads can change the value, but that this change cannot overlap. <code>Arc</code> is a little slower
than Rusts built in basic reference counting type <code>std::rc::Rc</code>, but prevents corruption across threads.</p>
<blockquote>
<p>Authors note: I don't think I've <em>ever</em> used <code>Rc</code>, but I use <code>Arc</code> all the time, so don't worry that we didn't
cover it in this book. If you need to pass data around wrapped in its own container its there to use</p>
</blockquote>
<p>So, armed with this knowledge, we can go back to unscoped threads!</p>
<pre><pre class="playground"><code class="language-rust">use std::thread::spawn;
use std::sync::{Arc, Mutex};

fn main() {
    let mut data = Arc::new(Mutex::new(Vec::with_capacity(10)));

    let handles = (0..10).map(|_| {
        // We'll clone the arc and move it into the thread
        let cloned_arc = data.clone();
        spawn(move || {
            // Arc also impls Deref for its containing type so we can call lock
            // on the Mutex from the Arc
            let mut guard = cloned_arc
                .lock()
                .expect("another thread with the lock panicked");
            guard.push("Thread reporting in!".to_string());
        })
    });

    handles.for_each(|handle| handle.join().expect("thread panicked"));

    let guard = data.lock().unwrap();
    assert_eq!(guard.len(), 10);
    guard
        .iter()
        .for_each(|s| assert_eq!(s, &amp;"Thread reporting in!".to_string()));
}</code></pre></pre>
<h2 id="next-chapter"><a class="header" href="#next-chapter">Next Chapter</a></h2>
<p>Macros! We'll be looking at the <code>macro_rules!</code> macro that lets you make more macros. We'll learn how <code>macro_rules!</code>
is used, how we can use it to remove repetitive code or even write our own domain-specific language (DSL!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../language-basics/iterators.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../language-basics/macros.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../language-basics/iterators.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../language-basics/macros.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>

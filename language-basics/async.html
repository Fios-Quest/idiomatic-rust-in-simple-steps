<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Async - Idiomatic Rust in Simple Steps</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Learn idiomatic Rust in simple steps even if you have no former knowledge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Idiomatic Rust in Simple Steps</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="async-rust"><a class="header" href="#async-rust">Async Rust</a></h1>
<p>Often times, when we write code, we have to wait on certain “things that take time” to happen. “Things that take time”
are usually things like IO, such as reading or writing to a disk, getting data from a database, downloading a file, etc.
Sometimes “things that take time” could just be computationally expensive, such as processing large amounts of data.</p>
<p>Our programs are typically complex with multiple parts to them. For example, applications often have a user interface,
whether that’s via a terminal, a web page, or a full desktop GUI. If our application has to wait on something happening,
we don’t want other aspects (like the UI) to freeze up, unable to do anything while we wait.</p>
<p>Asynchronous programming is a way to structure our code so that we can continue to do work while waiting on other
things, and it doesn’t depend on any specific way to get the work done. Under the hood, we might use threads, or we may
depend on Operating System hooks or even, for embedded programming, hardware interrupts, and exceptions.</p>
<p>In this chapter we’re going to explain the modular design of async programming in Rust. Our aim is to get a solid(ish)
understanding of the concepts involved, even though, in the real world, you’re likely to depend on others to design and
build the more complex parts of the system.</p>
<h2 id="move-and-pin"><a class="header" href="#move-and-pin">Move and Pin</a></h2>
<p>Before we go further into the chapter, we once again need to talk about memory, specifically: moving and pinning.</p>
<p>All data in our running program exists somewhere in memory, whether it’s the stack, the heap, or static memory. That
means that everything has a pointer address in memory.</p>
<p>When we pass a variable to another function, ownership of that variable “moves” to the other function. When we add a
variable to a <code>Vec</code> then ownership of that variable “moves” to the heap. Any time data “moves” ownership, it also
physically moves in memory.</p>
<p>Run this and look closely at the returned addresses. They’re similar, but they are different.</p>
<pre><pre class="playground"><code class="language-rust edition2024">fn main() {
    let hello = "Hello".to_string();
    
    let hello_ptr = &amp;raw const hello;
    println!("Hello is stored at {hello_ptr:p}");
    
    example_move(hello);
}

fn example_move(hello: String) {
    let hello_ptr = &amp;raw const hello;
    println!("Hello is stored at {hello_ptr:p}");
}</code></pre></pre>
<p>Because <code>example_move()</code> takes ownership of the <code>String</code>, and as we learned in the <a href="./unsafe.html">unsafe</a> chapter, the
metadata for <code>String</code> is stored on the stack, meaning that <em>that</em> portion of the data is copied to the memory for the
new function (often called a stack frame).</p>
<p>This is usually fine, but <em>occasionally</em> things might need to know where they themselves are in memory. This is called
self-referencing. If something references itself, and we move it, where does that reference now point?</p>
<p>In the below example we create a self-referential struct and pass it to a function up the stack. When you run the code,
you’ll see our last assertion fails.</p>
<pre><pre class="playground"><code class="language-rust should_panic edition2024">// --- Self Referencing Data Type

struct ExampleOfSelfReference {
    value: usize,
    reference_to_value: Option&lt;*const usize&gt;,
}

impl ExampleOfSelfReference {
    fn new(value: usize) -&gt; Self {
        Self {
            value,
            reference_to_value: None,
        }
    }
    
    fn set_reference(&amp;mut self) {
        self.reference_to_value = Some(&amp;raw const self.value);
    }
    
    fn get_value(&amp;self) -&gt; usize {
        // SAFETY: This is intentionally NOT safe, don't try this at home!
        unsafe { *self.reference_to_value.expect("Did not set_reference") }
    }
}

// --- Usage ---

<span class="boring">fn main() {
</span>let mut example = ExampleOfSelfReference::new(1);

// We need to set the reference now as the constructor moves the data too!
example.set_reference();

// Check the value was initialised correctly
assert_eq!(example.get_value(), 1);

// Update the value and check it was updated
example.value = 2;
assert_eq!(example.get_value(), 2);

// This causes a move in the same stack frame
let mut example = example;

// Update the value again and check it was updated
example.value = 3;
assert_eq!(example.get_value(), 3);
<span class="boring">}</span></code></pre></pre>
<p><code>reference_to_value</code> is just a number pointing at a location in memory. We moved the data, but the pointer is still
pointing at the old location.</p>
<p>Self-referential data is dangerous… but it can also be useful in certain circumstances. For this reason, some Generic
types occasionally need to take it into consideration. To keep ourselves safe, we can “pin” arbitrary data to memory,
preventing it from being moved. We use the <code>Pin</code> type to express this behavior, though the type itself is just a
container for a mutable reference, so the Pin itself is safe to move around. Through the magic of the borrow checker,
holding that single mutable reference is enough to lock the data in place.</p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::pin::Pin;

<span class="boring">struct ExampleOfSelfReference {
</span><span class="boring">    value: usize,
</span><span class="boring">    reference_to_value: Option&lt;*const usize&gt;,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ExampleOfSelfReference {
</span><span class="boring">    fn new(value: usize) -&gt; Self {
</span><span class="boring">        Self {
</span><span class="boring">            value,
</span><span class="boring">            reference_to_value: None,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn set_reference(&amp;mut self) {
</span><span class="boring">        self.reference_to_value = Some(&amp;raw const self.value);
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn get_value(&amp;self) -&gt; usize {
</span><span class="boring">        // SAFETY: This is intentionally NOT safe, don't try this at home!
</span><span class="boring">        unsafe { *self.reference_to_value.expect("Did not set_reference") }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>let mut example = ExampleOfSelfReference::new(1);
example.set_reference();
    
// Pin doesn't take ownership of the data, it takes a mutable reference to it
let mut pinned_example = Pin::new(&amp;mut example);

// We can no longer mutate or move the data because the pin holds the mutable reference
// example.value = 2;
// let example = example;
    
// We can read the data via the Pin thanks to Deref
assert_eq!(pinned_example.get_value(), 1);

// And we can mutate the data via the Pin thanks to DerefMut
pinned_example.value = 2;
assert_eq!(pinned_example.get_value(), 2);

// We can even safely move the pin, since it just contains a reference
let mut pinned_example = pinned_example;
pinned_example.value = 3;
assert_eq!(pinned_example.get_value(), 3);
<span class="boring">}</span></code></pre></pre>
<p>There’s a lot to <code>Pin</code> so and if you’re curious about it, the <a href="https://doc.rust-lang.org/std/pin/" title="" target="_blank">std documentation</a>
has a lot more information. For this chapter its enough to know that, in specific circumstances, like in modular
asynchronous architecture where we don’t necessarily control everything, we need to be certain data won’t move
unexpectedly, and this is achieved through the <code>Pin</code> type.</p>
<blockquote>
<p>Note: There are other ways to pin data including <code>Box::pin(T)</code> and the <code>pin!</code> macro which have their utility but,
crucially, do move the data you’re trying to prevent moving, so watch out for that! 😅</p>
</blockquote>
<h2 id="breaking-down-work"><a class="header" href="#breaking-down-work">Breaking Down Work</a></h2>
<p>When we build software, we can compartmentalize different parts of our program into tasks.</p>
<p>Imagine we want to download two websites and compare the contents. We download website A, then download website B, then
compare the contents of the two sites. If we break that down into tasks, it might look like this.</p>
<pre class="mermaid">flowchart LR
    A[Get website A]
    B[Get website B]
    C[Compare contents]

    A --&gt; B
    B --&gt; C
</pre>
<p>However, now that we’ve broken it down into tasks, we can see the tasks for getting the websites don’t depend on each
other and could be performed at the same time.</p>
<pre class="mermaid">flowchart LR
    A[Start other tasks]
    B[Get website A]
    C[Get website B]
    D[Compare contents]

    A --&gt; B
    A --&gt; C
    B --&gt; D
    C --&gt; D
</pre>
<p>Asynchronous design allows us to reason about our code at the task level. It doesn’t specifically tell us how that work
will get done, though. In C# the default way async tasks are run is using multiple threads in a thread pool. Node.js is
a single threaded runtime, though, so async code uses operating system callbacks to let your program know when a task is
complete.</p>
<p>Rust provides ways to structure asynchronous code out of the box but doesn’t have a default way of making sure
Asynchronous work is performed. This allows software engineers to choose the method that will work best for their
application.</p>
<p>In the following sections we’ll go over the Rust way of thinking about asynchronous tasks and create our own way of
getting the work described by those asynchronous tasks to run.</p>
<h2 id="tasks-schedulers-futures-and-executors"><a class="header" href="#tasks-schedulers-futures-and-executors">Tasks, Schedulers, Futures, and Executors</a></h2>
<p>Asynchronous architectures allow us to break our work up so that we can process different bits of that work while
waiting on other bits. Conceptually, we break the work into tasks and then have some sort of scheduler that decides
which task gets run when.</p>
<p>In Rust, we represent tasks with the <code>Future</code> trait, which can be applied to any type. We manage task scheduling through
what are usually called executors (sometimes called runtimes), which themselves use <code>Waker</code>s to decide when to run
different tasks.</p>
<p>This sounds complicated, but by the end of this chapter, you’ll hopefully have a reasonable idea of how <code>Future</code>s,
executors, and <code>Waker</code>s work together, and if you don’t… that’s actually ok. Most of the time you won’t need to write
any of these things yourself, but having even a vague understanding of them will help you write better async code, as
well as spot and fix common issues you might run across.</p>
<p>Let’s get started by building up our understanding step by step.</p>
<h3 id="futures"><a class="header" href="#futures">Futures</a></h3>
<p>The <code>Future</code> trait represents a task that may or may not be complete (something that will be completed in the future,
but not necessarily now).</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::pin::Pin;
</span><span class="boring">use std::task::{Context, Poll};
</span><span class="boring">
</span><span class="boring">fn main() {}
</span><span class="boring">
</span>pub trait Future {
    type Output;

    // Required method
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}</code></pre></pre>
<p>It has an associated type, <code>Output</code> and a single method, <code>.poll()</code>.</p>
<p><code>Output</code> represents the type of the data eventually returned by the <code>Future</code>. Usually this type will actually be a
<code>Result&lt;T, E&gt;</code> because if we’re waiting on something happening, there’s a chance that it might not.</p>
<p>The <code>.poll()</code> method is a lot more interesting though. Firstly, you’ll notice that <code>self</code> is typed, which we haven’t
seen in this book before. In <code>Future</code>s, <code>self</code> is a Pinned mutable reference to data of the type the <code>Future</code> is
applied to. The reason for this is <em>where</em> the Future executes might change, but because you might want to apply a
<code>Future</code> to a self-referential type, we need to know the data the <code>Future</code> represents won’t itself move.</p>
<p><code>.poll()</code> also takes a mutable reference to some sort of <code>Context</code> type. For now, the only thing <code>Context</code> contains is
a <code>Waker</code> which we’ll talk about later. The reason we don’t pass the <code>Waker</code> directly though is that in the future we
might want to add more data to a <code>Context</code> (this can be done in <code>nightly</code> Rust but this is outside the scope of this
book).</p>
<p>Finally, the return type of the <code>.poll()</code> method is a <code>Poll</code> enum. <code>.poll()</code> should be called any time we want to make
progress on a task. The return type tells us whether that call has resulted in an <code>Output</code>, represented by
<code>Poll::Ready(Self::Output)</code>, or if the poll is not currently complete and needs to be called again, represented by
<code>Poll::Pending</code>.</p>
<blockquote>
<p>Note: Once a Future has returned Ready, you <em>shouldn’t</em> call it again… we will be breaking this rule later but,
we’ll be very cautious when we do 😉.</p>
</blockquote>
<p>Let’s create a simple <code>ExampleFuture</code> and apply the <code>Future</code> trait to it:</p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::pin::Pin;
use std::task::{Context, Poll, Waker};

// --- Implementing Future on Example Type ---

struct ExampleFuture;

impl Future for ExampleFuture {
    type Output = &amp;'static str;

    fn poll(self: Pin&lt;&amp;mut Self&gt;, _cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        Poll::Ready("The future ran")
    }
}

// --- Usage ---

<span class="boring">fn main() {
</span>// We'll instantiate our future and pin it
let mut example = ExampleFuture;
let example = Pin::new(&amp;mut example);

// Don't worry about context yet, it has no effect in this example
let mut context = Context::from_waker(Waker::noop());

// Nothing happens until we poll the future
let result = example.poll(&amp;mut context);
<span class="boring">assert_eq!(result, Poll::Ready("The future ran"));
</span>
// The .poll() method returns a Poll enum we need to resolve 
match result {
    Poll::Ready(output) =&gt; println!("{output}"),
    Poll::Pending =&gt; panic!("This shouldn't happen!"),
}
<span class="boring">}</span></code></pre></pre>
<p>In this example we create <code>ExampleFuture</code> in the <code>example</code> variable, and then shadow the <code>example</code> variable with a <code>Pin</code>
that references the original <code>example</code> data. I think this is quite tidy as we no longer need access to the original
data, arguably it’s better not to have it, but it’s still right where it was in the stack frame.</p>
<p>As previously mentioned, there are several ways to pin data depending on what you specifically want to do. In this case
we’re pinning <code>example</code> to the stack, though this isn’t always the best place to put it. For example, if you need to
return the data down the stack, it would be better to put it on the heap with <code>Box::pin</code>.</p>
<p>We then create a <code>Context</code> that contains a <code>Waker</code>. In this case we’ll use a <code>Waker</code> that doesn’t do anything, because
we aren’t using the <code>Waker</code> for now. Normally you’ll only use a <code>Waker::noop</code> for testing or examples, as it prevents
the Future from controlling its own execution (we’ll get into how this works later).</p>
<p>When we call <code>.poll</code> on the Future, it instantly responds with a <code>Poll::Ready</code> containing a statically referenced string
slice.</p>
<p>Normally, <code>Future</code>s won’t be “ready” immediately, and will need to be polled again. Let’s create a <code>Future</code> that doesn’t
complete the first time you poll it, using a simple counter.</p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::pin::{pin, Pin};
use std::task::{Context, Poll, Waker};

// --- Future ---

struct FakeWorker {
    work_remaining: u8,
}

impl Future for FakeWorker {
    type Output = &amp;'static str;

    fn poll(self: Pin&lt;&amp;mut Self&gt;, _cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        match self.work_remaining {
            0 =&gt; Poll::Ready("All done!"),
            _ =&gt; {
                // .get_mut() turns `Pin&lt;&amp;mut T&gt;` into `&amp;mut T`, but consumes the pin.
<span class="boring">                // Hello person revealing the hidden code! 👋🏻 Just a thought here...
</span><span class="boring">                // why isn't `self` mutable? If it was we could use `as_mut`
</span><span class="boring">                // without consuming the pin. If you need multiple mutations in a
</span><span class="boring">                // `Future`, you need to unwrap the pin early.
</span><span class="boring">                // 
</span><span class="boring">                // Furthermore, .get_mut() only works on types that are `Unpin` meaning
</span><span class="boring">                // it won't work on self-referential types that actually do need to be
</span><span class="boring">                // pinned.
</span>                self.get_mut().work_remaining -= 1;
                Poll::Pending
            }
        }
    }
}

// --- Usage ---

<span class="boring">fn main() {
</span>let mut example = FakeWorker { work_remaining: 3 };
let mut example = Pin::new(&amp;mut example);

let mut context = Context::from_waker(Waker::noop());

// Pins are consumed when the Future is called but as_mut will effectively
// duplicate the Pin... it's weird, but useful.
assert_eq!(example.as_mut().poll(&amp;mut context), Poll::Pending);
assert_eq!(example.as_mut().poll(&amp;mut context), Poll::Pending);
assert_eq!(example.as_mut().poll(&amp;mut context), Poll::Pending);
assert_eq!(example.as_mut().poll(&amp;mut context), Poll::Ready("All done!"));
<span class="boring">}</span></code></pre></pre>
<p>Each time we call <code>.poll()</code>, our <code>FakeWorker</code> pretends to do some work, after which it may be <code>Ready</code> or it may still
be <code>Pending</code>.</p>
<p>So managing futures is just about repeatedly calling <code>.poll()</code> right? Well… no, not quite.</p>
<h3 id="executors"><a class="header" href="#executors">Executors</a></h3>
<p>Let’s create a simple executor that <em>will</em> just poll <code>Future</code>s until they’re <code>Ready</code>. This executor takes a single
generic <code>Future</code> and loops over the poll method</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::task::{Context, Poll, Waker};
use std::pin::pin;

fn loop_executor&lt;F: Future&gt;(future: F) -&gt; F::Output {
    let mut pinned_future = pin!(future);
    let mut context = Context::from_waker(Waker::noop());

    let mut loop_counter = 1;

    let result = loop {
        match pinned_future.as_mut().poll(&amp;mut context) {
            Poll::Ready(r) =&gt; break r,
            Poll::Pending =&gt; loop_counter += 1,
        }
    };

    println!("All done!");
    println!("We called .poll() {loop_counter} times!");

    result
}
<span class="boring">}</span></code></pre></pre>
<p>In this example our executor takes an arbitrary <code>Future</code>, pins it with the <code>pin!</code> macro.</p>
<p><code>Pin::new()</code> only works for types that are <code>Unpin</code>, and we don’t want to restrict our executor to <code>F: Future + Unpin</code>,
so instead we’ll use the <code>pin!</code> macro. However, one thing to watch out for is that this macro will itself cause whatever
you put in it to move! It only prevents moves after that.</p>
<p>You’ll notice the executor also returns <code>Future::Output</code>. We won’t use that much to begin with, it’ll be useful as we
move onto more advanced use cases.</p>
<p>We poll the future in a loop until it’s Ready. For now, we’ll keep count of how many times we called <code>.poll()</code> with
<code>loop_counter</code>. This is for demonstrative purposes, and we’ll change and eventually remove this in later examples.</p>
<p>Passing our previous example in, this seems to work quite well:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::task::{Context, Poll, Waker};
</span><span class="boring">use std::pin::{pin, Pin};
</span><span class="boring">
</span><span class="boring">struct FakeWorker {
</span><span class="boring">    work_remaining: u8,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Future for FakeWorker {
</span><span class="boring">    type Output = &amp;'static str;
</span><span class="boring">
</span><span class="boring">    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
</span><span class="boring">        match self.work_remaining {
</span><span class="boring">            0 =&gt; Poll::Ready("All done!"),
</span><span class="boring">            _ =&gt; {
</span><span class="boring">                self.get_mut().work_remaining -= 1;
</span><span class="boring">                Poll::Pending
</span><span class="boring">            }
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn loop_executor&lt;F: Future&gt;(future: F) -&gt; F::Output {
</span><span class="boring">    let mut pinned_future = pin!(future);
</span><span class="boring">    let mut context = Context::from_waker(Waker::noop());
</span><span class="boring">
</span><span class="boring">    let mut loop_counter = 1;
</span><span class="boring">
</span><span class="boring">    let result = loop {
</span><span class="boring">        match pinned_future.as_mut().poll(&amp;mut context) {
</span><span class="boring">            Poll::Ready(r) =&gt; break r,
</span><span class="boring">            Poll::Pending =&gt; loop_counter += 1,
</span><span class="boring">        }
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("All done!");
</span><span class="boring">    println!("We called .poll() {loop_counter} times!");
</span><span class="boring">
</span><span class="boring">    result
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>let future = FakeWorker { work_remaining: 3 };
let _ = loop_executor(future);
<span class="boring">}</span></code></pre></pre>
<p><code>.poll()</code> is called exactly the number of times it takes to get all the work in <code>FakeWorker</code> done.</p>
<p>But <code>Future</code>s usually wait on things like IO or heavy compute tasks which won’t nicely finish after a set number of
calls. Let’s try mimicking that with a simple timer:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::task::{Context, Poll, Waker};
</span><span class="boring">use std::pin::{pin, Pin};
</span>use std::time::{SystemTime, Duration};
use std::ops::Add;

// --- Example of a future that is time-based --- 

struct Timer {
    time_to_end: SystemTime,
}

impl Timer {
    fn new(duration: Duration) -&gt; Timer {
        Self {
            time_to_end: SystemTime::now().add(duration),
        }
    }
}

impl Future for Timer {
    type Output = ();

    fn poll(self: Pin&lt;&amp;mut Self&gt;, _cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        if self.time_to_end &lt;= SystemTime::now() {
            Poll::Ready(())
        } else {
            Poll::Pending
        }
    }
}

<span class="boring">fn loop_executor&lt;F: Future&gt;(future: F) -&gt; F::Output {
</span><span class="boring">    let mut pinned_future = pin!(future);
</span><span class="boring">    let mut context = Context::from_waker(Waker::noop());
</span><span class="boring">   
</span><span class="boring">    let mut loop_counter = 1;
</span><span class="boring">   
</span><span class="boring">    let result = loop {
</span><span class="boring">        match pinned_future.as_mut().poll(&amp;mut context) {
</span><span class="boring">            Poll::Ready(r) =&gt; break r,
</span><span class="boring">            Poll::Pending =&gt; loop_counter += 1,
</span><span class="boring">        }
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("All done!");
</span><span class="boring">    println!("But this time we called .poll() {loop_counter} times, yikes!");
</span><span class="boring">
</span><span class="boring">    result
</span><span class="boring">}
</span><span class="boring">
</span>// --- Usage ---

<span class="boring">fn main() {
</span>let future = Timer::new(Duration::from_secs(1));
let _ = loop_executor(future);
<span class="boring">}</span></code></pre></pre>
<p>When you run this code here, it’s sent to Rust Playground and executed in a sandbox in debug mode, so <code>.poll()</code> is
likely called hundreds of thousands of times. In release mode on a good computer, it might call <code>.poll()</code> hundreds of
millions of times. Each time we call <code>.poll()</code> we’re making a system call to get the time, then doing a comparison with
the stored time. We’re doing that millions of times… what a massive waste of compute power.</p>
<p>If only there was a way for the <code>Future</code> to let us know when it was ready to be polled again.</p>
<h3 id="waking"><a class="header" href="#waking">Waking</a></h3>
<p>A <code>Waker</code> is a struct the <code>Future</code> can use to inform the executor it’s ready to have its <code>.poll()</code> method called again.</p>
<p>Before we get to that, though, we’re going to update our program to use threads for both tasks and scheduling. It’s
important to note, however, that threads are not a necessary element of asynchronous Rust, there are other ways to
achieve Waking, but for now, this is the approach we’ll take.</p>
<pre><pre class="playground"><code class="language-rust edition2024">use std::task::{Context, Poll, Waker};
use std::pin::{pin, Pin};
use std::time::Duration;
use std::thread::{sleep, spawn, JoinHandle};
use std::sync::{Arc, Mutex};

// --- New Timer using threads ---

pub struct ThreadTimer {
    duration: Duration,
    join_handle: Option&lt;JoinHandle&lt;()&gt;&gt;,
    waker: Arc&lt;Mutex&lt;Waker&gt;&gt;,
    is_complete: Arc&lt;Mutex&lt;bool&gt;&gt;
}

impl ThreadTimer {
    pub fn new(duration: Duration) -&gt; ThreadTimer {
        Self {
            duration,
            join_handle: None,
            is_complete: Arc::new(Mutex::new(false)),
            waker: Arc::new(Mutex::new(Waker::noop().clone())),
        }
    }
}

impl Future for ThreadTimer {
    type Output = ();

    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        let fut = self.get_mut();
        
        // We always need to update the waker whenever we're polled
        *fut.waker.lock().expect("Thread crashed with mutex lock") = cx.waker().clone();
        
        // If we haven't started the thread, do so now
        if fut.join_handle.is_none() {
            let duration = fut.duration;
            let waker = fut.waker.clone();
            let is_complete = fut.is_complete.clone();
            fut.join_handle = Some(spawn(move || {
                sleep(duration);
                *is_complete.lock().expect("Thread crashed with mutex lock") = true;
                waker
                    .lock()
                    .expect("Thread crashed with mutex lock")
                    .wake_by_ref();
            }));
        }
        
        match *fut.is_complete.lock().expect("Thread crashed with mutex lock") {
            true =&gt; Poll::Ready(()),
            false =&gt; Poll::Pending,
        }
    }
}

<span class="boring">fn loop_executor&lt;F: Future&gt;(future: F) -&gt; F::Output {
</span><span class="boring">    let mut pinned_future = pin!(future);
</span><span class="boring">    let mut context = Context::from_waker(Waker::noop());
</span><span class="boring">   
</span><span class="boring">    let mut loop_counter = 1;
</span><span class="boring">   
</span><span class="boring">    let result = loop {
</span><span class="boring">        match pinned_future.as_mut().poll(&amp;mut context) {
</span><span class="boring">            Poll::Ready(r) =&gt; break r,
</span><span class="boring">            Poll::Pending =&gt; loop_counter += 1,
</span><span class="boring">        }
</span><span class="boring">    };
</span><span class="boring">
</span><span class="boring">    println!("All done!");
</span><span class="boring">    println!("But we called .poll() {loop_counter} times, yikes!");
</span><span class="boring">
</span><span class="boring">    result
</span><span class="boring">}
</span><span class="boring">
</span>// --- Usage ---

<span class="boring">fn main() {
</span>let future = ThreadTimer::new(Duration::from_secs(1));
let _ = loop_executor(future);
<span class="boring">}</span></code></pre></pre>
<p>Our timer now has a <code>Duration</code>, an optional <code>JoinHandle</code>, a <code>is_complete</code> boolean wrapped in an <code>Arc&lt;Mutex&lt;_&gt;&gt;</code> and
<code>Waker</code> also wrapped in an <code>Arc&lt;Mutex&lt;_&gt;&gt;</code>. When we create a new instance of it, we store the Duration, set the
<code>JoinHandle</code> to <code>None</code>, <code>is_complete</code> to <code>false</code>, and storing a No-Op waker in the waker field.</p>
<p>When <code>.poll()</code> is called, we replace the <code>Waker</code> with the one given to us by the executor. We do this <em>every</em> time
<code>.poll()</code> is called because it could be that the responsibility for keeping track of our future might move and a
different executor needs to be woken when the future is ready to do more work.</p>
<p>Next we look to see if the thread has been started.</p>
<p>If we don’t currently have a join handle, then we start a new thread, passing in the duration and our Arc’d Waker and
<code>is_complete</code>. Using the <code>Arc&lt;Mutex&lt;_&gt;&gt;</code> allows us to make these values accessible from both threads. The thread we’re
starting sleeps itself for the duration, updates <code>is_complete</code>, and finally calls the <code>Waker</code> by using the
<code>.wake_by_ref()</code> method which avoids consuming the <code>Waker</code> which is owned by the Future.</p>
<blockquote>
<p>Note: Thread sleeps are not accurate, the only thing that can be guaranteed is that the thread will sleep for
<em>at least</em> the given Duration… unless the Duration is zero, in which case even sleeping isn’t guaranteed. It’s fine
for this demonstration, though.</p>
</blockquote>
<p>If the thread has been started, check the value of <code>is_complete</code> for which variant of Poll should be returned.</p>
<p>We’re still using the old executor, so if you run this, you’ll see we poll hundreds of thousands of times.</p>
<p>Let’s fix that next. First, we need a <code>Waker</code>. The <code>Waker</code> type itself is a concrete type, but when it’s created we can
give it any type that implements the <code>Wake</code> trait.</p>
<pre><pre class="playground"><code class="language-rust no_run edition2024"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::thread::{self, Thread};
use std::task::Wake;
use std::sync::Arc;

pub struct ThreadWaker {
    thread: Thread,
}

impl ThreadWaker {
    pub fn current_thread() -&gt; Self {
        ThreadWaker {
            thread: thread::current(),
        }
    }
}

impl Wake for ThreadWaker {
    fn wake(self: Arc&lt;Self&gt;) {
        self.thread.unpark();
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Our <code>ThreadWaker</code> is fairly straightforward. We can create it with the <code>current_thread()</code> static method in which it
takes a note of whatever thread it was created on. We implement the <code>Wake</code> trait for it, and when we call <code>wake</code>, all we
do is “unpark” that thread.</p>
<p>Parking and Unparking is akin to pausing and unpausing threads. In Rust, a thread can only park itself, and only a
different thread can unpark it.</p>
<p>We use this to create an executor that parks the thread it’s on while waiting for <code>Future</code>s to request being polled by
calling the <code>Waker</code> that will unpark the executor’s thread.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::task::{Context, Poll, Waker, Wake};
</span><span class="boring">use std::pin::{pin, Pin};
</span><span class="boring">use std::time::Duration;
</span><span class="boring">use std::thread::{self, Thread, sleep, spawn, JoinHandle};
</span><span class="boring">use std::sync::{Arc, Mutex};
</span><span class="boring">
</span><span class="boring">pub struct ThreadWaker {
</span><span class="boring">    thread: Thread,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ThreadWaker {
</span><span class="boring">    pub fn current_thread() -&gt; Self {
</span><span class="boring">        ThreadWaker {
</span><span class="boring">            thread: thread::current(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wake for ThreadWaker {
</span><span class="boring">    fn wake(self: Arc&lt;Self&gt;) {
</span><span class="boring">        self.thread.unpark();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct ThreadTimer {
</span><span class="boring">    duration: Duration,
</span><span class="boring">    join_handle: Option&lt;JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">    waker: Arc&lt;Mutex&lt;Waker&gt;&gt;,
</span><span class="boring">    is_complete: Arc&lt;Mutex&lt;bool&gt;&gt;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ThreadTimer {
</span><span class="boring">    pub fn new(duration: Duration) -&gt; ThreadTimer {
</span><span class="boring">        Self {
</span><span class="boring">            duration,
</span><span class="boring">            join_handle: None,
</span><span class="boring">            is_complete: Arc::new(Mutex::new(false)),
</span><span class="boring">            waker: Arc::new(Mutex::new(Waker::noop().clone())),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Future for ThreadTimer {
</span><span class="boring">    type Output = ();
</span><span class="boring">
</span><span class="boring">    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
</span><span class="boring">        let fut = self.get_mut();
</span><span class="boring">
</span><span class="boring">        // We always need to update the waker whenever we're polled
</span><span class="boring">        *fut.waker.lock().expect("Thread crashed with mutex lock") = cx.waker().clone();
</span><span class="boring">
</span><span class="boring">        // If we haven't started the thread, do so now
</span><span class="boring">        if fut.join_handle.is_none() {
</span><span class="boring">            let duration = fut.duration;
</span><span class="boring">            let waker = fut.waker.clone();
</span><span class="boring">            let is_complete = fut.is_complete.clone();
</span><span class="boring">            fut.join_handle = Some(spawn(move || {
</span><span class="boring">                sleep(duration);
</span><span class="boring">                *is_complete.lock().expect("Thread crashed with mutex lock") = true;
</span><span class="boring">                waker
</span><span class="boring">                    .lock()
</span><span class="boring">                    .expect("Thread crashed with mutex lock")
</span><span class="boring">                    .wake_by_ref();
</span><span class="boring">            }));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        match *fut.is_complete.lock().expect("Thread crashed with mutex lock") {
</span><span class="boring">            true =&gt; Poll::Ready(()),
</span><span class="boring">            false =&gt; Poll::Pending,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// --- Executor ---

fn block_thread_on&lt;F: Future&gt;(future: F) -&gt; F::Output {
    let mut example = pin!(future);

    // This is how we turn ThreadWaker into Waker
    let waker = Arc::new(ThreadWaker::current_thread()).into();
    let mut context = Context::from_waker(&amp;waker);
    
    let mut loop_counter = 1;
    let output = loop {
        match example.as_mut().poll(&amp;mut context) {
            Poll::Ready(output) =&gt; break output,
            Poll::Pending =&gt; {
                loop_counter += 1;
                std::thread::park();
            },
        }
    };
<span class="boring">
</span><span class="boring">    assert_eq!(loop_counter, 2);
</span>    
    println!("All done!");
    println!("This time .poll() was only called {loop_counter} times, yay!");
    
    output
}

// --- Usage ---

<span class="boring">fn main() {
</span>let future = ThreadTimer::new(Duration::from_secs(1));
let _ = block_thread_on(future);
<span class="boring">}</span></code></pre></pre>
<p>Our new executor has the same signature as the old one, but this time it creates a <code>Waker</code> based on our <code>ThreadWaker</code>.
Because the <code>ThreadWaker</code> is created on the same thread that the executor runs on, it keeps a note of that thread before
being passed to our <code>Future</code>. After polling the <code>Future</code>, if the <code>Future</code> isn’t ready, then the executor parks its own
thread and waits for the <code>Waker</code> to unpark it.</p>
<p>When you run this, you can see that our code is much more efficient with our poll method only being called twice, once
to start progressing the future, and once more to complete the future after the <code>Waker</code> is called.</p>
<p>This means the program spends most of its one(ish) second runtime asleep, leaving resources like the CPU free to use.</p>
<h2 id="async--await"><a class="header" href="#async--await">Async / Await</a></h2>
<p>The whole point of asynchronous code architectures is that we break our code down into small tasks. Implementing our
own Futures is great for the very edge of our Rust code where we’re waiting on some sort of I/O from outside our
program, or something like a compute heavy task we control.</p>
<p>Most of the time we won’t necessarily even be doing that, though, as there are lots of crates for dealing with common
I/O tasks, like reading files, accessing databases, or downloading files. Most of the time, we just need to glue those
bits together.</p>
<p>This is where async/await comes in. We can make any block of code or any function a Future with the async keyword. Let’s
try that out with our existing <code>block_thread_on</code> executor:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::task::{Context, Poll, Waker, Wake};
</span><span class="boring">use std::pin::{pin, Pin};
</span><span class="boring">use std::time::Duration;
</span><span class="boring">use std::thread::{self, Thread, sleep, spawn, JoinHandle};
</span><span class="boring">use std::sync::{Arc, Mutex};
</span><span class="boring">
</span><span class="boring">pub struct ThreadWaker {
</span><span class="boring">    thread: Thread,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ThreadWaker {
</span><span class="boring">    pub fn current_thread() -&gt; Self {
</span><span class="boring">        ThreadWaker {
</span><span class="boring">            thread: thread::current(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wake for ThreadWaker {
</span><span class="boring">    fn wake(self: Arc&lt;Self&gt;) {
</span><span class="boring">        self.thread.unpark();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn block_thread_on&lt;F: Future&gt;(future: F) -&gt; F::Output {
</span><span class="boring">    let mut example = pin!(future);
</span><span class="boring">
</span><span class="boring">    let waker = Arc::new(ThreadWaker::current_thread()).into();
</span><span class="boring">    let mut context = Context::from_waker(&amp;waker);
</span><span class="boring">
</span><span class="boring">    loop {
</span><span class="boring">        match example.as_mut().poll(&amp;mut context) {
</span><span class="boring">            Poll::Ready(output) =&gt; break output,
</span><span class="boring">            Poll::Pending =&gt; std::thread::park(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>async fn calling_this_function_returns_a_future() -&gt; String {
    String::from("Inside an async function")
}

fn main() {
    let this_block_is_a_future = async {
        String::from("Inside an async block")
    };
    println!("{}", block_thread_on(this_block_is_a_future));
    println!("{}", block_thread_on(calling_this_function_returns_a_future()));
}</code></pre></pre>
<p>But async code does something a little bit special. It can work up to another future and then pause until that future
is ready to continue by using the <code>.await</code> postfix on a <code>Future</code>. What’s rather brilliant in async code, though, is that
when woken, the code resumes from where it got to. Furthermore, <code>.await</code> will automatically unwrap the <code>Poll</code> enum for
you, giving you the <code>Poll::Ready</code> value.</p>
<p>Let’s use <code>async</code> to create one future that returns a value after a time, and a second that awaits that future, receives
the value, and does something with it:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::task::{Context, Poll, Waker, Wake};
</span><span class="boring">use std::pin::{pin, Pin};
</span><span class="boring">use std::time::Duration;
</span><span class="boring">use std::thread::{self, Thread, sleep, spawn, JoinHandle};
</span><span class="boring">use std::sync::{Arc, Mutex};
</span><span class="boring">
</span><span class="boring">pub struct ThreadWaker {
</span><span class="boring">    thread: Thread,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ThreadWaker {
</span><span class="boring">    pub fn current_thread() -&gt; Self {
</span><span class="boring">        ThreadWaker {
</span><span class="boring">            thread: thread::current(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wake for ThreadWaker {
</span><span class="boring">    fn wake(self: Arc&lt;Self&gt;) {
</span><span class="boring">        self.thread.unpark();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct ThreadTimer {
</span><span class="boring">    duration: Duration,
</span><span class="boring">    join_handle: Option&lt;JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">    waker: Arc&lt;Mutex&lt;Waker&gt;&gt;,
</span><span class="boring">    is_complete: Arc&lt;Mutex&lt;bool&gt;&gt;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ThreadTimer {
</span><span class="boring">    pub fn new(duration: Duration) -&gt; ThreadTimer {
</span><span class="boring">        Self {
</span><span class="boring">            duration,
</span><span class="boring">            join_handle: None,
</span><span class="boring">            is_complete: Arc::new(Mutex::new(false)),
</span><span class="boring">            waker: Arc::new(Mutex::new(Waker::noop().clone())),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Future for ThreadTimer {
</span><span class="boring">    type Output = ();
</span><span class="boring">
</span><span class="boring">    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
</span><span class="boring">        let fut = self.get_mut();
</span><span class="boring">
</span><span class="boring">        // We always need to update the waker whenever we're polled
</span><span class="boring">        *fut.waker.lock().expect("Thread crashed with mutex lock") = cx.waker().clone();
</span><span class="boring">
</span><span class="boring">        // If we haven't started the thread, do so now
</span><span class="boring">        if fut.join_handle.is_none() {
</span><span class="boring">            let duration = fut.duration;
</span><span class="boring">            let waker = fut.waker.clone();
</span><span class="boring">            let is_complete = fut.is_complete.clone();
</span><span class="boring">            fut.join_handle = Some(spawn(move || {
</span><span class="boring">                sleep(duration);
</span><span class="boring">                *is_complete.lock().expect("Thread crashed with mutex lock") = true;
</span><span class="boring">                waker
</span><span class="boring">                    .lock()
</span><span class="boring">                    .expect("Thread crashed with mutex lock")
</span><span class="boring">                    .wake_by_ref();
</span><span class="boring">            }));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        match *fut.is_complete.lock().expect("Thread crashed with mutex lock") {
</span><span class="boring">            true =&gt; Poll::Ready(()),
</span><span class="boring">            false =&gt; Poll::Pending,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn block_thread_on&lt;F: Future&gt;(future: F) -&gt; F::Output {
</span><span class="boring">    let mut example = pin!(future);
</span><span class="boring">
</span><span class="boring">    let waker = Arc::new(ThreadWaker::current_thread()).into();
</span><span class="boring">    let mut context = Context::from_waker(&amp;waker);
</span><span class="boring">    
</span><span class="boring">    let mut loop_counter = 1;
</span><span class="boring">    loop {
</span><span class="boring">        match example.as_mut().poll(&amp;mut context) {
</span><span class="boring">            Poll::Ready(output) =&gt; break output,
</span><span class="boring">            Poll::Pending =&gt; {
</span><span class="boring">                loop_counter += 1;
</span><span class="boring">                std::thread::park();
</span><span class="boring">            },
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>// This async block is Future&lt;Output = &amp;'static str&gt;
let future_with_value = async {
    ThreadTimer::new(Duration::from_secs(1)).await;
    "This future returns a static string reference"
};
    
// This async block is Future&lt;Output = ()&gt;
let future_that_uses_the_value_from_the_other_future = async { 
    let value = future_with_value.await;
    println!("Received: {value}");
};

// Running the second future so we can see the output
block_thread_on(future_that_uses_the_value_from_the_other_future);
<span class="boring">}</span></code></pre></pre>
<p>More importantly, because the value is considered to be instantly available after awaiting it, and because most of the
time when waiting on something we have to assume that thing might fail… we arrive at the most sublime pairing of Rust
syntax, <code>.await?</code>.</p>
<p>Functions that can fail should return a <code>Result</code>. <code>Future</code>’s always return <code>Poll</code> but <code>Future::Output</code> will <em>regularly</em>
be a Result.</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::task::{Context, Poll, Waker, Wake};
</span><span class="boring">use std::pin::{pin, Pin};
</span><span class="boring">use std::time::{Duration, SystemTime, UNIX_EPOCH};
</span><span class="boring">use std::thread::{self, Thread, sleep, spawn, JoinHandle};
</span><span class="boring">use std::sync::{Arc, Mutex};
</span><span class="boring">
</span><span class="boring">struct ThreadWaker {
</span><span class="boring">    thread: Thread,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ThreadWaker {
</span><span class="boring">    fn current_thread() -&gt; Self {
</span><span class="boring">        ThreadWaker {
</span><span class="boring">            thread: thread::current(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wake for ThreadWaker {
</span><span class="boring">    fn wake(self: Arc&lt;Self&gt;) {
</span><span class="boring">        self.thread.unpark();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct ThreadTimer {
</span><span class="boring">    duration: Duration,
</span><span class="boring">    join_handle: Option&lt;JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">    waker: Arc&lt;Mutex&lt;Waker&gt;&gt;,
</span><span class="boring">    is_complete: Arc&lt;Mutex&lt;bool&gt;&gt;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ThreadTimer {
</span><span class="boring">    fn new(duration: Duration) -&gt; ThreadTimer {
</span><span class="boring">        Self {
</span><span class="boring">            duration,
</span><span class="boring">            join_handle: None,
</span><span class="boring">            is_complete: Arc::new(Mutex::new(false)),
</span><span class="boring">            waker: Arc::new(Mutex::new(Waker::noop().clone())),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Future for ThreadTimer {
</span><span class="boring">    type Output = ();
</span><span class="boring">
</span><span class="boring">    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
</span><span class="boring">        let fut = self.get_mut();
</span><span class="boring">
</span><span class="boring">        // We always need to update the waker whenever we're polled
</span><span class="boring">        *fut.waker.lock().expect("Thread crashed with mutex lock") = cx.waker().clone();
</span><span class="boring">
</span><span class="boring">        // If we haven't started the thread, do so now
</span><span class="boring">        if fut.join_handle.is_none() {
</span><span class="boring">            let duration = fut.duration;
</span><span class="boring">            let waker = fut.waker.clone();
</span><span class="boring">            let is_complete = fut.is_complete.clone();
</span><span class="boring">            fut.join_handle = Some(spawn(move || {
</span><span class="boring">                sleep(duration);
</span><span class="boring">                *is_complete.lock().expect("Thread crashed with mutex lock") = true;
</span><span class="boring">                waker
</span><span class="boring">                    .lock()
</span><span class="boring">                    .expect("Thread crashed with mutex lock")
</span><span class="boring">                    .wake_by_ref();
</span><span class="boring">            }));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        match *fut.is_complete.lock().expect("Thread crashed with mutex lock") {
</span><span class="boring">            true =&gt; Poll::Ready(()),
</span><span class="boring">            false =&gt; Poll::Pending,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn block_thread_on&lt;F: Future&gt;(future: F) -&gt; F::Output {
</span><span class="boring">    let mut example = pin!(future);
</span><span class="boring">
</span><span class="boring">    let waker = Arc::new(ThreadWaker::current_thread()).into();
</span><span class="boring">    let mut context = Context::from_waker(&amp;waker);
</span><span class="boring">    
</span><span class="boring">    let mut loop_counter = 1;
</span><span class="boring">    loop {
</span><span class="boring">        match example.as_mut().poll(&amp;mut context) {
</span><span class="boring">            Poll::Ready(output) =&gt; break output,
</span><span class="boring">            Poll::Pending =&gt; {
</span><span class="boring">                loop_counter += 1;
</span><span class="boring">                std::thread::park();
</span><span class="boring">            },
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>async fn this_future_could_fail() -&gt; Result&lt;u64, String&gt; {
    let time = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .map_err(|_| "Time went backwards... a lot!".to_string())?
        .as_secs();
    // Check if the seconds are a multiple of 2 and convert to Result
    time.is_multiple_of(2)
        .then_some(time)
        .ok_or_else(|| "A completely unforeseen thing happened!".to_string())
    
}

async fn use_fallible_future() -&gt; Result&lt;(), String&gt; {
    let time = this_future_could_fail().await?; // &lt;- gorgeous!
    println!("{time} secs have passed since the Unix Epoch");
    Ok(())
}

<span class="boring">fn main() {
</span>match  block_thread_on(use_fallible_future()) {
    Ok(()) =&gt; {},
<span class="boring">    // Fun fact, this ought to be eprintln! but Rust Playground / mdbook won't show it!
</span>    Err(message) =&gt; println!("Error: {message}"),
}
<span class="boring">}</span></code></pre></pre>
<p>In fact, because <code>.await</code> is automatically unwrapping the <code>Poll</code>, and <code>?</code> is automatically unwrapping the <code>Result</code>, you
can further chain to the inner types. Imagine getting a <code>Poll&lt;Result&lt;Vec&lt;T&gt;, E&gt;&gt;</code> back from a <code>Future</code>, you could
<code>.await?.into_iter().map(|t: T| /* do some work */)...</code> etc.</p>
<p>This is another one of those Rust features that makes the language really sublime to use!</p>
<p>Anyway, because the <code>.await</code> postfix works on any future, and async code will resume from where it left off, we can
<code>.await</code> several futures one after the other</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::task::{Context, Poll, Waker, Wake};
</span><span class="boring">use std::pin::{pin, Pin};
</span><span class="boring">use std::time::{Duration, Instant};
</span><span class="boring">use std::thread::{self, Thread, sleep, spawn, JoinHandle};
</span><span class="boring">use std::sync::{Arc, Mutex};
</span><span class="boring">
</span><span class="boring">struct ThreadWaker {
</span><span class="boring">    thread: Thread,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ThreadWaker {
</span><span class="boring">    fn current_thread() -&gt; Self {
</span><span class="boring">        ThreadWaker {
</span><span class="boring">            thread: thread::current(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wake for ThreadWaker {
</span><span class="boring">    fn wake(self: Arc&lt;Self&gt;) {
</span><span class="boring">        self.thread.unpark();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct ThreadTimer {
</span><span class="boring">    duration: Duration,
</span><span class="boring">    join_handle: Option&lt;JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">    waker: Arc&lt;Mutex&lt;Waker&gt;&gt;,
</span><span class="boring">    is_complete: Arc&lt;Mutex&lt;bool&gt;&gt;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ThreadTimer {
</span><span class="boring">    fn new(duration: Duration) -&gt; ThreadTimer {
</span><span class="boring">        Self {
</span><span class="boring">            duration,
</span><span class="boring">            join_handle: None,
</span><span class="boring">            is_complete: Arc::new(Mutex::new(false)),
</span><span class="boring">            waker: Arc::new(Mutex::new(Waker::noop().clone())),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Future for ThreadTimer {
</span><span class="boring">    type Output = ();
</span><span class="boring">
</span><span class="boring">    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
</span><span class="boring">        let fut = self.get_mut();
</span><span class="boring">
</span><span class="boring">        // We always need to update the waker whenever we're polled
</span><span class="boring">        *fut.waker.lock().expect("Thread crashed with mutex lock") = cx.waker().clone();
</span><span class="boring">
</span><span class="boring">        // If we haven't started the thread, do so now
</span><span class="boring">        if fut.join_handle.is_none() {
</span><span class="boring">            let duration = fut.duration;
</span><span class="boring">            let waker = fut.waker.clone();
</span><span class="boring">            let is_complete = fut.is_complete.clone();
</span><span class="boring">            fut.join_handle = Some(spawn(move || {
</span><span class="boring">                sleep(duration);
</span><span class="boring">                *is_complete.lock().expect("Thread crashed with mutex lock") = true;
</span><span class="boring">                waker
</span><span class="boring">                    .lock()
</span><span class="boring">                    .expect("Thread crashed with mutex lock")
</span><span class="boring">                    .wake_by_ref();
</span><span class="boring">            }));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        match *fut.is_complete.lock().expect("Thread crashed with mutex lock") {
</span><span class="boring">            true =&gt; Poll::Ready(()),
</span><span class="boring">            false =&gt; Poll::Pending,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn block_thread_on&lt;F: Future&gt;(future: F) -&gt; F::Output {
</span><span class="boring">    let mut example = pin!(future);
</span><span class="boring">
</span><span class="boring">    let waker = Arc::new(ThreadWaker::current_thread()).into();
</span><span class="boring">    let mut context = Context::from_waker(&amp;waker);
</span><span class="boring">    
</span><span class="boring">    let mut loop_counter = 1;
</span><span class="boring">    loop {
</span><span class="boring">        match example.as_mut().poll(&amp;mut context) {
</span><span class="boring">            Poll::Ready(output) =&gt; break output,
</span><span class="boring">            Poll::Pending =&gt; {
</span><span class="boring">                loop_counter += 1;
</span><span class="boring">                std::thread::park();
</span><span class="boring">            },
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>let future = async {
    println!("Starting future"); // Only prints once
    ThreadTimer::new(Duration::from_secs(2)).await;
    ThreadTimer::new(Duration::from_secs(1)).await;
    println!("Ending future"); // Only prints once
};

block_thread_on(future);
<span class="boring">}</span></code></pre></pre>
<p><code>.await</code> essentially pauses the execution of the code until the ThreadTimer future is ready, then continues on from that
point. So this code is amazing, right? … Right?</p>
<p>No! This code is bad, actually, but the reason may not be immediately obvious.</p>
<p>This version might help you see why the code is bad:</p>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::task::{Context, Poll, Waker, Wake};
</span><span class="boring">use std::pin::{pin, Pin};
</span><span class="boring">use std::time::{Duration, Instant};
</span><span class="boring">use std::thread::{self, Thread, sleep, spawn, JoinHandle};
</span><span class="boring">use std::sync::{Arc, Mutex};
</span><span class="boring">
</span><span class="boring">struct ThreadWaker {
</span><span class="boring">    thread: Thread,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ThreadWaker {
</span><span class="boring">    fn current_thread() -&gt; Self {
</span><span class="boring">        ThreadWaker {
</span><span class="boring">            thread: thread::current(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wake for ThreadWaker {
</span><span class="boring">    fn wake(self: Arc&lt;Self&gt;) {
</span><span class="boring">        self.thread.unpark();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct ThreadTimer {
</span><span class="boring">    duration: Duration,
</span><span class="boring">    join_handle: Option&lt;JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">    waker: Arc&lt;Mutex&lt;Waker&gt;&gt;,
</span><span class="boring">    is_complete: Arc&lt;Mutex&lt;bool&gt;&gt;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ThreadTimer {
</span><span class="boring">    fn new(duration: Duration) -&gt; ThreadTimer {
</span><span class="boring">        Self {
</span><span class="boring">            duration,
</span><span class="boring">            join_handle: None,
</span><span class="boring">            is_complete: Arc::new(Mutex::new(false)),
</span><span class="boring">            waker: Arc::new(Mutex::new(Waker::noop().clone())),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Future for ThreadTimer {
</span><span class="boring">    type Output = ();
</span><span class="boring">
</span><span class="boring">    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
</span><span class="boring">        let fut = self.get_mut();
</span><span class="boring">
</span><span class="boring">        // We always need to update the waker whenever we're polled
</span><span class="boring">        *fut.waker.lock().expect("Thread crashed with mutex lock") = cx.waker().clone();
</span><span class="boring">
</span><span class="boring">        // If we haven't started the thread, do so now
</span><span class="boring">        if fut.join_handle.is_none() {
</span><span class="boring">            let duration = fut.duration;
</span><span class="boring">            let waker = fut.waker.clone();
</span><span class="boring">            let is_complete = fut.is_complete.clone();
</span><span class="boring">            fut.join_handle = Some(spawn(move || {
</span><span class="boring">                sleep(duration);
</span><span class="boring">                *is_complete.lock().expect("Thread crashed with mutex lock") = true;
</span><span class="boring">                waker
</span><span class="boring">                    .lock()
</span><span class="boring">                    .expect("Thread crashed with mutex lock")
</span><span class="boring">                    .wake_by_ref();
</span><span class="boring">            }));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        match *fut.is_complete.lock().expect("Thread crashed with mutex lock") {
</span><span class="boring">            true =&gt; Poll::Ready(()),
</span><span class="boring">            false =&gt; Poll::Pending,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn block_thread_on&lt;F: Future&gt;(future: F) -&gt; F::Output {
</span><span class="boring">    let mut example = pin!(future);
</span><span class="boring">
</span><span class="boring">    let waker = Arc::new(ThreadWaker::current_thread()).into();
</span><span class="boring">    let mut context = Context::from_waker(&amp;waker);
</span><span class="boring">    
</span><span class="boring">    let mut loop_counter = 1;
</span><span class="boring">    loop {
</span><span class="boring">        match example.as_mut().poll(&amp;mut context) {
</span><span class="boring">            Poll::Ready(output) =&gt; break output,
</span><span class="boring">            Poll::Pending =&gt; {
</span><span class="boring">                loop_counter += 1;
</span><span class="boring">                std::thread::park();
</span><span class="boring">            },
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>let future = async {
    let now = Instant::now();
    ThreadTimer::new(Duration::from_secs(2)).await;
    ThreadTimer::new(Duration::from_secs(1)).await;
    now.elapsed().as_secs()
};

let time_taken = block_thread_on(future);
println!("Time taken {time_taken} seconds");
<span class="boring">assert_eq!(time_taken, 3);
</span><span class="boring">}</span></code></pre></pre>
<p>The total time taken to run the timers is 3 seconds, which makes sense right? We have a two-second timer and a
one-second timer, combined, that’s three seconds… but that’s the problem…</p>
<h3 id="join"><a class="header" href="#join">Join</a></h3>
<p>The two timers in the previous examples are completely independent of each other. We should <strong>not</strong> be waiting for the
first timer to complete before working on the second timer, that defeats the benefits of asynchronous programming.</p>
<p>What would be more useful is if we do both bits of “work” at the same time. What we need to happen is for both Futures
to be polled at the same time. This is often called “joining”.</p>
<p>We can (although we shouldn’t, we’ll come on to that in a bit) create a Join Future something like this.</p>
<blockquote>
<p>I’ve hidden code concerning the MemoFuture as it’s less relevant, but you can see it with the eye button.</p>
</blockquote>
<pre><pre class="playground"><code class="language-rust edition2024"><span class="boring">use std::cell::RefCell;
</span><span class="boring">use std::task::{Context, Poll, Waker, Wake};
</span><span class="boring">use std::pin::{pin, Pin};
</span><span class="boring">use std::time::{Duration, Instant};
</span><span class="boring">use std::ops::DerefMut;
</span><span class="boring">use std::thread::{self, Thread, sleep, spawn, JoinHandle};
</span><span class="boring">use std::sync::{Arc, Mutex};
</span><span class="boring">
</span><span class="boring">struct ThreadWaker {
</span><span class="boring">    thread: Thread,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ThreadWaker {
</span><span class="boring">    fn current_thread() -&gt; Self {
</span><span class="boring">        ThreadWaker {
</span><span class="boring">            thread: thread::current(),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Wake for ThreadWaker {
</span><span class="boring">    fn wake(self: Arc&lt;Self&gt;) {
</span><span class="boring">        self.thread.unpark();
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct ThreadTimer {
</span><span class="boring">    duration: Duration,
</span><span class="boring">    join_handle: Option&lt;JoinHandle&lt;()&gt;&gt;,
</span><span class="boring">    waker: Arc&lt;Mutex&lt;Waker&gt;&gt;,
</span><span class="boring">    is_complete: Arc&lt;Mutex&lt;bool&gt;&gt;
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl ThreadTimer {
</span><span class="boring">    fn new(duration: Duration) -&gt; ThreadTimer {
</span><span class="boring">        Self {
</span><span class="boring">            duration,
</span><span class="boring">            join_handle: None,
</span><span class="boring">            is_complete: Arc::new(Mutex::new(false)),
</span><span class="boring">            waker: Arc::new(Mutex::new(Waker::noop().clone())),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl Future for ThreadTimer {
</span><span class="boring">    type Output = ();
</span><span class="boring">
</span><span class="boring">    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
</span><span class="boring">        let fut = self.get_mut();
</span><span class="boring">
</span><span class="boring">        // We always need to update the waker whenever we're polled
</span><span class="boring">        *fut.waker.lock().expect("Thread crashed with mutex lock") = cx.waker().clone();
</span><span class="boring">
</span><span class="boring">        // If we haven't started the thread, do so now
</span><span class="boring">        if fut.join_handle.is_none() {
</span><span class="boring">            let duration = fut.duration;
</span><span class="boring">            let waker = fut.waker.clone();
</span><span class="boring">            let is_complete = fut.is_complete.clone();
</span><span class="boring">            fut.join_handle = Some(spawn(move || {
</span><span class="boring">                sleep(duration);
</span><span class="boring">                *is_complete.lock().expect("Thread crashed with mutex lock") = true;
</span><span class="boring">                waker
</span><span class="boring">                    .lock()
</span><span class="boring">                    .expect("Thread crashed with mutex lock")
</span><span class="boring">                    .wake_by_ref();
</span><span class="boring">            }));
</span><span class="boring">        }
</span><span class="boring">
</span><span class="boring">        match *fut.is_complete.lock().expect("Thread crashed with mutex lock") {
</span><span class="boring">            true =&gt; Poll::Ready(()),
</span><span class="boring">            false =&gt; Poll::Pending,
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn block_thread_on&lt;F: Future&gt;(future: F) -&gt; F::Output {
</span><span class="boring">    let mut example = pin!(future);
</span><span class="boring">
</span><span class="boring">    let waker = Arc::new(ThreadWaker::current_thread()).into();
</span><span class="boring">    let mut context = Context::from_waker(&amp;waker);
</span><span class="boring">    
</span><span class="boring">    let mut loop_counter = 1;
</span><span class="boring">    loop {
</span><span class="boring">        match example.as_mut().poll(&amp;mut context) {
</span><span class="boring">            Poll::Ready(output) =&gt; break output,
</span><span class="boring">            Poll::Pending =&gt; {
</span><span class="boring">                loop_counter += 1;
</span><span class="boring">                std::thread::park();
</span><span class="boring">            },
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">enum InnerMemoFuture&lt;F: Future&gt; {
</span><span class="boring">    Pending(F),
</span><span class="boring">    Ready(F::Output),
</span><span class="boring">    Spent,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;F: Future&gt; InnerMemoFuture&lt;F&gt; {
</span><span class="boring">    fn new(future: F) -&gt; Self {
</span><span class="boring">        Self::Pending(future)
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    fn extract(self) -&gt; Option&lt;F::Output&gt; {
</span><span class="boring">        match self {
</span><span class="boring">            InnerMemoFuture::Pending(_) =&gt; None,
</span><span class="boring">            InnerMemoFuture::Ready(output) =&gt; Some(output),
</span><span class="boring">            InnerMemoFuture::Spent =&gt; panic!("Attempted to extract a spent future"),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">#[derive(Debug)]
</span><span class="boring">struct InnerFutureSpentError;
</span><span class="boring">
</span><span class="boring">impl std::error::Error for InnerFutureSpentError {}
</span><span class="boring">
</span><span class="boring">impl std::fmt::Display for InnerFutureSpentError {
</span><span class="boring">    fn fmt(&amp;self, f: &amp;mut std::fmt::Formatter&lt;'_&gt;) -&gt; std::fmt::Result {
</span><span class="boring">        write!(f, "Tried to extract output from spent future")
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">struct MemoFuture&lt;F: Future&gt;(RefCell&lt;InnerMemoFuture&lt;F&gt;&gt;);
</span><span class="boring">
</span><span class="boring">impl&lt;F: Future&gt; MemoFuture&lt;F&gt; {
</span><span class="boring">    fn new(future: F) -&gt; Self {
</span><span class="boring">        Self(RefCell::new(InnerMemoFuture::new(future)))
</span><span class="boring">    }
</span><span class="boring">
</span><span class="boring">    /// Warning: This will drop the future if the future is not Ready
</span><span class="boring">    fn extract(&amp;self) -&gt; Option&lt;F::Output&gt; {
</span><span class="boring">        let old_value = self.0.replace(InnerMemoFuture::Spent);
</span><span class="boring">        old_value.extract()
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;F: Future&gt; Future for MemoFuture&lt;F&gt; {
</span><span class="boring">    type Output = Result&lt;(), InnerFutureSpentError&gt;;
</span><span class="boring">
</span><span class="boring">    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
</span><span class="boring">        let mut mutable_self = self.0.borrow_mut();
</span><span class="boring">        let inner_future = mutable_self.deref_mut();
</span><span class="boring">
</span><span class="boring">        match inner_future {
</span><span class="boring">            InnerMemoFuture::Pending(future) =&gt; {
</span><span class="boring">                // SAFETY: We own the future and are not moving it
</span><span class="boring">                let pinned_future = unsafe { Pin::new_unchecked(future) };
</span><span class="boring">                match pinned_future.poll(cx) {
</span><span class="boring">                    Poll::Ready(output) =&gt; {
</span><span class="boring">                        drop(mutable_self);
</span><span class="boring">                        self.0.replace(InnerMemoFuture::Ready(output));
</span><span class="boring">                        Poll::Ready(Ok(()))
</span><span class="boring">                    }
</span><span class="boring">                    Poll::Pending =&gt; Poll::Pending,
</span><span class="boring">                }
</span><span class="boring">            }
</span><span class="boring">            InnerMemoFuture::Ready(_) =&gt; Poll::Ready(Ok(())),
</span><span class="boring">            InnerMemoFuture::Spent =&gt; Poll::Ready(Err(InnerFutureSpentError)),
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// --- Join ---

struct Join&lt;F1: Future, F2: Future&gt;(
    Pin&lt;Box&lt;MemoFuture&lt;F1&gt;&gt;&gt;,
    Pin&lt;Box&lt;MemoFuture&lt;F2&gt;&gt;&gt;,
);

impl&lt;F1: Future, F2: Future&gt; Join&lt;F1, F2&gt; {
    fn new(future1: F1, future2: F2) -&gt; Self {
        Self(
            Box::pin(MemoFuture::new(future1)),
            Box::pin(MemoFuture::new(future2)),
        )
    }
}

impl&lt;F1: Future, F2: Future&gt; Future for Join&lt;F1, F2&gt; {
    type Output = Result&lt;(F1::Output, F2::Output), InnerFutureSpentError&gt;;

    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt; {
        let inner = self.get_mut();

        let r1 = inner.0.as_mut().poll(cx);
        let r2 = inner.1.as_mut().poll(cx);

        match (r1, r2) {
            (Poll::Ready(r1), Poll::Ready(r2)) =&gt; {
                if r1.is_err() || r2.is_err() {
                    // This _shouldn't_ happen
                    Poll::Ready(Err(InnerFutureSpentError))
                } else {
                    Poll::Ready(Ok((inner.0.extract().unwrap(), inner.1.extract().unwrap())))
                }
            }
            _ =&gt; Poll::Pending,
        }
    }
}

// --- await Join futures in a future ---

async fn run_both_timers() -&gt; Result&lt;u64, InnerFutureSpentError&gt; {
    let now = Instant::now();
    Join::new(
        ThreadTimer::new(Duration::from_secs(2)),
        ThreadTimer::new(Duration::from_secs(1)),
    ).await?;
    Ok(now.elapsed().as_secs())
}

// --- Usage ---

<span class="boring">fn main() -&gt; Result&lt;(), Box&lt;dyn std::error::Error&gt;&gt; {
</span>let time_taken = block_thread_on(run_both_timers())?;
println!("Time taken {time_taken} seconds");
<span class="boring">    assert_eq!(time_taken, 2);
</span><span class="boring">    Ok(())
</span><span class="boring">}</span></code></pre></pre>
<p>The <code>Join</code> future uses another future I’ve created called the <code>MemoFuture</code> which simply allows me to poll it even
after it’s Ready but only returns the data when I extract it. When you poll <code>Join</code>, it polls the inner <code>Future</code>s, if they
both report they’re ready, then <code>Join</code> extracts the data and returns Ready with the results.</p>
<p>Ideally, you won’t be writing inefficient Joins like this one yourself. Most async crates provide their own version of
join, such as <a href="https://docs.rs/tokio/latest/tokio/macro.join.html" title="" target="_blank">Tokio’s <code>join!</code></a> macro, and
<a href="https://docs.rs/smol/latest/smol/future/fn.zip.html" title="" target="_blank">Smol’s <code>.zip()</code></a> function. Even the Rust standard library has
<a href="https://doc.rust-lang.org/std/future/macro.join.html" title="" target="_blank">std::future::join</a> which they’re trying to stabilize.</p>
<h2 id="over-in-the-real-world"><a class="header" href="#over-in-the-real-world">Over in the Real World</a></h2>
<p>Rust doesn’t come with its own Executors, or much in the way of Future utilities (other than what we’ve covered here),
as the implementation details can vary significantly depending on what you’re doing.</p>
<p>For example, while our examples here have used Threads, Threads aren’t necessary, aren’t always available, and aren’t
particularly efficient in some situations.</p>
<p>If you’re working on an embedded microcontroller, for example, rather than parking and unparking threads, you might use
interrupts and exceptions to wake futures. If you’re running code inside an operating system, it might be more efficient
to wait on callbacks from the OS to know when to wake a given future.</p>
<p>Rather than writing your own executors, though, you’ll find that other people have provided executors for common use
cases such as <a href="https://docs.rs/tokio/latest/tokio/" title="" target="_blank">Tokio</a> and <a href="https://docs.rs/smol/latest/smol/" title="" target="_blank">Smol</a>. These crates
also come with a lot of utility types, functions, and macros, including substantially more efficient and ergonomic ways
to join futures. They also usually have code for common futures such as working with the file system or network traffic
asynchronously, either via libraries or optional crate features.</p>
<p>Beyond this there are also executor agnostic libraries that provide futures for more specific needs like
<a href="https://docs.rs/reqwest/latest/reqwest/" title="" target="_blank">reqwest</a> which provides HTTP specific futures, or
<a href="https://docs.rs/sqlx/latest/sqlx/" title="" target="_blank">sqlx</a> which provides connectivity to a variety of different database flavours.</p>
<p>So, most of the time when you work with async Rust in the real world, you won’t need to write executors, and you won’t
need to implement the Future trait yourself. You’ll use third party libraries for futures at the outer bounds of your
software, join futures with third party utilities, and you’ll glue it all together with futures created with <code>async</code>
blocks and functions.</p>
<p>Returning to our rather silly example from the very beginning of this chapter, your <code>async</code> code is less likely to
look like what we’ve seen so far and much more likely to look like this:</p>
<pre><code class="language-rust ignore">use std::error::Error;

const FIOS_QUEST_URL: &amp;str = "https://fios-quest.com";
const IRISS_URL: &amp;str = "https://fios-quest.com/idiomatic-rust-in-simple-steps/";

/// Get the body of a document at a given URL as a string
async fn get_url(url: &amp;str) -&gt; Result&lt;String, Box&lt;dyn Error&gt;&gt; {
    // Note that both `.get()` and `.text()` return Futures that can be awaited
    // and those futures return Results that can be shortcut
    Ok(reqwest::get(url).await?.text().await?)
}

// Tokio provides an attribute macro that can turn main itself into an async fn though
// it also provides things like blocking "runtimes" (executors) similar in usage to 
// what we create above
#[tokio::main]
async fn main() -&gt; Result&lt;(), Box&lt;dyn Error&gt;&gt; {
    // Join two get_url Futures as they're independent of each other
    let (fios_quest, iriss) = tokio::join!(get_url(FIOS_QUEST_URL), get_url(IRISS_URL));

    // I couldn't think of anything useful to do so lets just see how many 
    // chars are in the html returned :)
    let fq_chars_chars = fios_quest?.chars().count();
    let iriss_chars = iriss?.chars().count();

    println!("Fio's Quest's body contains {fq_chars_chars} characters");
    println!("IRISS's body contains {iriss_chars} characters");

    Ok(())
}</code></pre>
<p>Not a <code>Future</code> trait or <code>Pin</code> in sight!</p>
<p>So why did I just try to explain all of this? Because my hope is that, when you understand what’s happening under the
hood, it will help you make the best use of async and avoid…</p>
<h2 id="common-gotchas"><a class="header" href="#common-gotchas">Common Gotchas</a></h2>
<p>Other than blocking unrelated work while awaiting a future, see the earlier Join section, there are two fairly common
gotchas in async code. Luckily, they’re much easier to spot when you have a fair understanding of what’s going on
underneath.</p>
<p>The first is blocking. We used threads in our examples, but you may not end up using a threaded executor, and even when
you do, some executors allow multiple futures to run on a single thread. This means using any blocking code could
prevent a thread from continuing until it’s complete, which could impact the execution of some or all of your other
futures.</p>
<p>This is an easier mistake to make than you might think. For example,
<a href="https://doc.rust-lang.org/std/fs/struct.File.html" title="" target="_blank">opening a file and reading it</a> are both blocking functions. The same
goes for <a href="https://doc.rust-lang.org/std/net/struct.TcpStream.html" title="" target="_blank">TcpStream</a> and other standard library implementations
of IO functionality. Luckily, async alternatives to the standard library are readily available.</p>
<p>Worse still is <code>Mutex</code> which will block a thread until the lock becomes available. If there are two futures on the same
thread, and one has a guard when the other requests it, the second future will block the thread preventing the first
thread from dropping the guard. This causes a bug called “Deadlock”.</p>
<blockquote>
<p>If you cleverly noticed that I used unsafe Mutexes earlier, good catch! Luckily, the specific way they’re being
used is safe as the locks are guaranteed to be on different threads. :)</p>
</blockquote>
<p>Libraries like Tokio and Smol either come with (or provide separately) their own interpretations of typically blocking
behaviors that use Futures instead.</p>
<p>The second gotcha is with borrowing and ownership. As we’ve seen, there’s complexity around Futures that requires
Pinning to be a thing. This is because a Future might be moved by its executor, and if it is, self-referential data
would point at old (or worse, freed) memory. But it can get even more complex than that.</p>
<p>Rusts ownership model means that the lifetime of a reference must be trackable to make sure it does not outlive its
owned data. This gets a lot more challenging with futures as the compiler needs to track references through deferred
work. Thinking even more carefully about owned data, references, and the memory and CPU tradeoffs of cloning data can
make async code harder to reason about.</p>
<p>It’s worth remembering that, particularly for smaller projects, you don’t <em>have</em> to use async if it’s causing your code
to be more complicated than it would otherwise be.</p>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Hopefully, after this chapter, you have a bit more of an understanding about what’s going on when you use async in Rust.
Various crates that help provide utilities for async implement the specifics in their own way, so before you choose
executor crates and <code>Future</code> supporting libraries, it’s worth reading crate documentation to understand the options
available and the choices made.</p>
<p>This is the end of the “Language Basics” section of Idiomatic Rust in Simple Steps. While there are many more language
features available to you, I hope I’ve left you in a strong place to continue your journey.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../language-basics/unsafe.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../what-next/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../language-basics/unsafe.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../what-next/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->
        <script src="../mermaid.min.js"></script>
        <script src="../mermaid-init.js"></script>



    </div>
    </body>
</html>

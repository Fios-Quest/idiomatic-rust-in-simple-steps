<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Functions - Idiomatic Rust in Simple Steps</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Learn idiomatic Rust in simple steps even if you have no former knowledge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Idiomatic Rust in Simple Steps</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Functions are reusable blocks of code. They have inputs, usually perform some sort of process, then have an output.</p>
<p>We've been using a function called <code>main</code> to run all of our programs and examples so far. This is a special function
that is called as the program starts. We've also used a few other kinds of functions and methods (special functions
attached to data types) that are built into Rust. We can make and use our own functions too though.</p>
<p>Functions can be pure, or impure. A pure function takes an input, does some processing and returns an output. This makes
the function extremely predictable. Given the same input they will always produce the same output, and nothing else
within the system will change.</p>
<style>
  img {
    display: block;
    margin: 0 auto;
  }
</style>
<p><img src="./functions/PureFunctions.svg" alt="Pure Functions" /></p>
<p>An impure function, might not always produce the same output given the same input, or may have side effects within the
system, either changing something else in the system or having some other part of the system change what the function
does.</p>
<p><img src="./functions/ImpureFunctions.svg" alt="Impure Functions" /></p>
<h2 id="a-quick-note-on-mutability"><a class="header" href="#a-quick-note-on-mutability">A Quick Note on Mutability</a></h2>
<p>Up to now, we haven't needed to change any data once it's been created. By default, all variables in Rust are implicitly
"immutable", meaning that the values inside of them can not be changed.</p>
<p>This, for example, won't compile (try to run it to see the compiler output)</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">fn main() {
</span>let one = 1;
one = one + 1;
<span class="boring">println!("one = {one}");
</span><span class="boring">}</span></code></pre></pre>
<p>Immutability is good because it prevents data from being changed by mistake which, going on the name of the variable in
the above example, is obviously what's happened here (ie, it seems like <code>one</code> should probably not contain <code>2</code>).</p>
<p>It's good to use immutable variables as much as possible, but software needs to be able to process data. If we could
never mutate values, we'd always have to depend on creating copies like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let one = 1;
let two = one + 1;
<span class="boring">println!("two = {two}");
</span><span class="boring">}</span></code></pre></pre>
<p>That's fine for small data but imagine we're processing large data like an image. Do we want to copy it every time we
make a single pixel change?</p>
<p>You can explicitly opt in to mutability by adding the word <code>mut</code> (pronounced "mute") in front of the variable name.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut message = "Hello".to_string();
message.push_str(", world!"); // Modify message by adding this data to the end
<span class="boring">println!("{message}");
</span><span class="boring">}</span></code></pre></pre>
<h2 id="creating-and-calling-functions"><a class="header" href="#creating-and-calling-functions">Creating and calling functions</a></h2>
<p>Functions are defined with the <code>fn</code> keyword (short for FuNction), followed by a name, followed by brackets <code>()</code> which
may or may not contain parameters, possibly followed by an arrow <code>-&gt;</code> and a return type (if no return type is specified
the return type is the Unit Type <code>()</code>, see the <a href="./data-types.html#the-unit-type">data types chapter</a>). This part of the
function is called the "function header". The function is completed by a code block, code between curly brackets, which
is also called the function body.</p>
<p>So lets create the simplest possible function:</p>
<pre><pre class="playground"><code class="language-rust">fn say_hello() {
    println!("Hello, world");
}

<span class="boring">fn main() {
</span><span class="boring">    say_hello();
</span><span class="boring">}</span></code></pre></pre>
<p>This function is called <code>say_hello</code>, it has no parameters and does not return anything. Because it writes to the
terminal, this function is considered to be impure.</p>
<p>We can call the function using its name and empty brackets.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn say_hello() {
</span><span class="boring">    println!("Hello, world");
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    say_hello();
}</code></pre></pre>
<p>You'll notice this function doesn't actually have any inputs or outputs. Let's start by providing an input.</p>
<h2 id="passing-parameters"><a class="header" href="#passing-parameters">Passing Parameters</a></h2>
<pre><pre class="playground"><code class="language-rust">fn say_hello(name: &amp;str) {
    println!("Hello, {name}");
}

<span class="boring">fn main() {
</span><span class="boring">    say_hello("Yuki");
</span><span class="boring">}</span></code></pre></pre>
<p>Now the function has one input (we call it a parameter) called <code>name</code>. You can see that we also provide type information
for the parameter, in this case it's a string slice (<code>&amp;str</code>). The parameter can be used as a variable within the
function, so we use it in our <code>println!</code>.</p>
<p>To pass the data into the function we place it between the brackets:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn say_hello(name: &amp;str) {
</span><span class="boring">    println!("Hello, {name}");
</span><span class="boring">}
</span><span class="boring">
</span>fn main() {
    say_hello("Yuki");
}</code></pre></pre>
<p>We can have multiple parameters too. Parameters are ordered so when you call the function, you need to match the order
they're specified. For example:</p>
<pre><pre class="playground"><code class="language-rust">fn say_hello_two(first_person: &amp;str, second_person: &amp;str) {
    println!("Hello, {first_person} and {second_person}");
}

fn main() {
    say_hello_two("Indra", "Yuki");
}</code></pre></pre>
<h2 id="returning-from-functions"><a class="header" href="#returning-from-functions">Returning from Functions</a></h2>
<p>Let's fix our function to remove the side effect. Instead of directly printing to the terminal from the function, we'll
return the string we want to display and move the side effect to main.</p>
<p>We'll make the following changes:</p>
<ul>
<li>We'll rename the function to reflect the change in behaviour (see <a href="#best-practices">Best Practices</a> below)</li>
<li>We'll add the return type (in this case <code>String</code>) to the function header, after <code>-&gt;</code></li>
<li>We'll create the String using the <code>format!</code> macro and store it in a variable <code>message</code> (note: the variable isn't
necessary, it's just for clarity)</li>
<li>We'll return the <code>message</code> from the function, remember the code blocks can be expressions, we don't need to explicitly
write <code>return</code> (though we can), we just need to make the thing we want to return the last bit of the block and forgo
the semicolon</li>
</ul>
<pre><pre class="playground"><code class="language-rust">fn create_greeting(name: &amp;str) -&gt; String {
    let message = format!("Hello, {name}");
    message
}

fn main() {
    let greeting = create_greeting("Yuki");
    println!("{greeting}");
}</code></pre></pre>
<h2 id="recursion"><a class="header" href="#recursion">Recursion</a></h2>
<p>See also: <a href="#recursion">recursion</a></p>
<p>In Rust, functions can call other functions, like how our <code>main()</code> function calls our <code>create_greeting(...)</code> function in
the previous example. A function that calls itself is described as recursive. Take for example this method for finding
the nth number in the fibonacci sequence</p>
<pre><pre class="playground"><code class="language-rust">fn find_fibonacci(n: u128) -&gt; u128 {
    if n == 0 || n == 1 { // if n equals 0 or n equals 1
        n
    } else {
        find_fibonacci(n - 1) + find_fibonacci(n - 2)
    }
}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">    let n = 11;
</span><span class="boring">    let fibonacci = find_fibonacci(n);
</span><span class="boring">    println!("The {n} value of fibonacci is {fibonacci}");
</span><span class="boring">}</span></code></pre></pre>
<blockquote>
<p>Note in this function that we use a boolean OR (<code>||</code>) in the <code>if</code> so the larger expression evaluates to true if either
the left or right parts of the expression evaluate to true. I.e. the expression is true if n is equal to 0 OR if n is
equal to 1.</p>
<p>We also use the <code>if</code>/<code>else</code> as an expression so the return of the function is equal to the values in the <code>if</code>/<code>else</code>
blocks. If the expression in the <code>if</code> is true, then we return <code>n</code>, otherwise we return the result of calling the same
function with new parameters.</p>
</blockquote>
<p>Because we call <code>find_fibonacci</code> inside of <code>find_fibonacci</code>, this is a recursion. Each time we call the function in this
way, we add another layer on <a href="./memory.html">the stack</a>. The stack is finite, so if we give the function a
large enough number, it will eventually run out of space in the stack, causing a stack overflow, and you'll see
something like:</p>
<pre><code class="language-text">thread 'main' has overflowed its stack
</code></pre>
<blockquote>
<p>Its worth noting I had to manually set the stack size to something unreasonably small</p>
</blockquote>
<p>Rust does support "tail recursion" which is technique for turning a recursive function into a loop at compile time. This
not only minimises stack usage to effectively a single function call but is also much faster. However, I think this is
an overrated feature. In any language that supports tail recursion, it's hard to guarantee the compiler will optimise
this way, and it's easy to break. My recommendation is if you need to recurse a <em>lot</em>, then consider whether you can
manually rewrite your function as a loop instead of depending on a compiler optimization.</p>
<h2 id="ownership"><a class="header" href="#ownership">Ownership</a></h2>
<h3 id="memory-management-primer"><a class="header" href="#memory-management-primer">Memory Management Primer</a></h3>
<p>Variables in Rust have to live somewhere in physical memory. This primarily comes down to the Stack, the Heap and the
binary (for a deeper explanation, see the <a href="memory.html">chapter on memory</a>). The Heap can be thought of as managed. You
ask the operating system (or other memory manager) to "allocate" you a block of memory to use for writing to and reading
from, before finally "freeing" that block and returning the memory to the operating system.</p>
<p>In some programming languages, this memory is managed manually by you. You have to ask for the memory and free it
yourself. This leads to some problems:</p>
<ul>
<li>What happens if you try to use memory that wasn't allocated?</li>
<li>What happens if you try to use memory that you already freed?</li>
<li>What happens if you try to store more data than fits?</li>
</ul>
<p>Not only is it surprisingly easy to make mistakes here, the consequences can be severe: around 70% of all security
vulnerabilities are caused by accidental misuse of memory.</p>
<p>In order to get around these problems, some programming languages use an automated method of memory management called
garbage collection. In this method, you, the software engineer, don't have to think about the actions required to get
or return memory to/from the operating system. Instead, as memory is allocated, the garbage collector built into the
language, will monitor to see which parts of your program are actively looking at that bit of memory, through a process
called reference counting. Once the number of places using that data has dropped to zero, the garbage collector can
safely free the memory.</p>
<p>This is much safer than manually managing the memory yourself, but comes with some of its own problems:</p>
<ul>
<li>The garbage collector requires additional resources to manage memory
<ul>
<li>This includes CPU time to do the work but in some cases can also require significantly more memory</li>
</ul>
</li>
<li>Managing memory by proxy is less efficient than managing it directly, meaning its slower</li>
<li>You have limited to no control over what the garbage collector does or when it does it, this can have big negative
impacts to performance at uncontrollable times</li>
</ul>
<p>Rust's method of memory management is a little different. It's low level, giving you the speed of manual memory
management, but its mechanisms are hidden behind abstractions that mitigate its risks. It's certainly not as easy to
learn, but once you get your head around it, it makes a lot of sense.</p>
<h3 id="introducing-ownership"><a class="header" href="#introducing-ownership">Introducing Ownership</a></h3>
<p>In Rust, all data is "owned". When the variable that "owns" the data goes out of scope, the data is dropped. This means
that if the data was stored on the Heap, then that bit of memory is immediately freed.</p>
<p>Let's have a play with this, first, lets look at the scope aspect of ownership:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">fn main() {
  let a = 'a'; // We create `a` in the outer scope of "main"

  { // Start of a new block, starting a nested scope

    println!("{a}"); // This works as `a` is in scope

    let b = 'b'; // We create `b` in the inner scope of this code block
    println!("{b}"); // This works as `b` is in scope

  } // End of the block, b goes out of scope

  println!("{a}"); // This still works as `a` is still in scope
  println!("{b}"); // This does not work as `b` went out of scope
}</code></pre></pre>
<p>We can see that once a variable is out of scope, it can't be used. If you run the above example (remember, you can do
that in this book by mousing over the example and hitting the play button), you'll see it won't compile and (amongst
a few other bits) gives you this message:</p>
<pre><code class="language-text">error[E0425]: cannot find value `b` in this scope
  --&gt; src/main.rs:14:14
</code></pre>
<p>Which tells us <em>exactly</em> what's wrong! Rust's compiler messages generally amazing, especially when it comes to working
with ownership, so it's worth getting used to how Rust presents its errors.</p>
<p>Next, lets look at how data can only be "owned" by one thing at a time:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">fn main() {
</span>let a = "hello".to_string(); // We create some data and give it to `a`
let b = a;                   // We give the data in `a` to `b`, transfering ownership
println!("{b}");             // This would be fine as b owns "hello"
println!("{a}");             // This won't compile, the data "moved" from `a` to `b`
<span class="boring">}</span></code></pre></pre>
<p>The statement <code>let b = a;</code> "moves" ownership of the string from <code>a</code> to <code>b</code>. Normally we wouldn't "move" data in this way
(spoilers: this is, after all, a chapter on functions), but it neatly shows that the data can't be owned by multiple
variables at once.</p>
<h3 id="move-semantics"><a class="header" href="#move-semantics">Move Semantics</a></h3>
<p>You might have noticed that we swapped from <code>char</code>s in the first ownership example to a <code>String</code> in the second. This is
because there are two mechanisms at play: "Move" and "Copy".</p>
<p>Let's try the same code with chars:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let a = 'é›ª';    // We create some data and give it to `a`
let b = a;       // We set b to be equal to a
println!("{b}"); // Prints é›ª 
println!("{a}"); // Also prints é›ª
<span class="boring">}</span></code></pre></pre>
<p>This works! But String didn't... ðŸ¤”</p>
<p>The reason for this is that <code>char</code> is Copy, that is to say that it has the <code>Copy</code> trait. We'll talk more about Traits
in a future chapter, but essentially Traits provide behaviour to Data. Things can have the <code>Copy</code> trait applied to them
if they can be trivially copied and this usually (always?) means the data exists on the stack. The reason for this is
all that "allocating" and "freeing" memory on the stack we talked about earlier requires a non-trivial amount of time
and resources.</p>
<p>When data has the Copy trait, instead of being moved from one variable to another, it's copied. This mechanism on data
that is Copy is implicit. Data that does not or can not implement Copy may still be duplicated if it implements the
trait <code>Clone</code>, which provides the <code>.clone()</code> method. We'll talk more about implementing traits in the traits section,
but <code>String</code> already implements this so here's how to use it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let a = "hello".to_string(); // We create some data and give it to `a`
let b = a.clone();           // Allocates memory on the heap and copies the data into it
println!("{b}");             // Prints "hello"
println!("{a}");             // Also prints "hello"
<span class="boring">}</span></code></pre></pre>
<p>You'll also note that we used a full fat <code>String</code> here, not a string slice reference. Here's what that would look like:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">fn main() {
</span>let a = "hello";   // `a` is a reference to data that exists in the binaries "data"
let b = a;         // references are Copy so the reference is copied from a to b
println!("{b}");   // Prints "hello"
println!("{a}");   // Also prints "hello"
<span class="boring">}</span></code></pre></pre>
<p>Because <code>"hello"</code> exists inside the binaries data you can not "Own" it. Ownership would imply that once its no longer
used it can be freed, but as its part of the binary, that wouldn't make sense. Instead, we just get a reference to where
the value exists in memory. This reference is also immutable, you can't change values in the binary. Immutable
references <em>are</em> Copy though.</p>
<p>What does this have to do with functions though?</p>
<h3 id="functions-and-ownership"><a class="header" href="#functions-and-ownership">Functions and Ownership</a></h3>
<p>When we pass data into functions through the use of parameters, the data follows the rules of move semantics.</p>
<p>Let's go back to our <code>create_greeting()</code> function. Instead of passing in a string slice reference, what would happen if
we passed in a <code>String</code>?</p>
<pre><pre class="playground"><code class="language-rust compile_fail">fn create_greeting(name: String) -&gt; String {
    let message = format!("Hello, {name}");
    message
}

fn main() {
  let yuki = "Yuki".to_string();
  let message = create_greeting(yuki);
  println!("{message}"); // This would be fine but...
  println!("{yuki}"); // This won't compile
}</code></pre></pre>
<p>In the above example, we moved ownership of the data stored in the variable <code>yuki</code> into the parameter <code>name</code> in the
function <code>create_greeting</code>. This means after the function the variable <code>yuki</code> can no longer be used.</p>
<p>Because the <code>format!</code> macro does not take ownership of the data in <code>name</code>, we could return both the message <em>and</em> the
original <code>String</code> data using a tuple.</p>
<pre><pre class="playground"><code class="language-rust">fn create_greeting(name: String) -&gt; (String, String) {
    let message = format!("Hello, {name}");
    (message, name)
}

fn main() {
  let yuki = "Yuki".to_string();
  let (message, yuki) = create_greeting(yuki);
  println!("{message}"); 
  println!("{yuki}"); // This works again
}</code></pre></pre>
<p>We've changed our <code>create_greeting()</code> function to return a tuple that includes both strings. When the function returns
we destructure the tuple (see <a href="control-flow.html">destructuring with patterns</a>) into two new variables,
<code>message</code> and <code>yuki</code>. Note: this new <code>yuki</code> is a different variable from the old <code>yuki</code>, this is called "shadowing".</p>
<p>This is obviously a terrible way to deal with ownership. Going back to our original function, you can see that we are
taking a reference to a string slice instead. The <code>String</code> type can be "dereferenced" into a reference to a string slice
(remember the internal representation of a String is the same as a string slice), so we can create a reference to our
<code>yuki</code> <code>String</code> using an ampersand:</p>
<pre><pre class="playground"><code class="language-rust">// Changed back to taking a &amp;str
fn create_greeting(name: &amp;str) -&gt; String {
    let message = format!("Hello, {name}");
    message
}

fn main() {
  let yuki = "Yuki".to_string();
  let message = create_greeting(&amp;yuki);
  println!("{message}");
  println!("{yuki}"); // Yuki's ownership was never moved so this now works
}</code></pre></pre>
<p>Let's say we wanted our function to modify the string instead. Ideally we'd want to avoid modifying data that's passed
to a function but sometimes that's not possible, if you need to do it you can pass a mutable reference.</p>
<pre><pre class="playground"><code class="language-rust">// Change &amp;str to &amp;mut String
fn create_greeting(greeting: &amp;mut String, name: &amp;str)  {
    greeting.push_str(", ");
    greeting.push_str(name);
}

fn main() {
  let mut greeting = "Hello".to_string();
  let name = "Yuki".to_string();
  create_greeting(&amp;mut greeting, &amp;name);
  println!("{greeting}");
}</code></pre></pre>
<p>Some things to note:</p>
<ul>
<li>In order to mutate greeting via a mutable reference, the variable itself must also be mutable: <code>let mut greeting ...</code></li>
<li>When we pass the reference, we are explicit that we are allowing the reference to be mutable too:
<code>create_greeting(&amp;mut greeting, ...)</code></li>
<li>The function takes a mutable reference to a String, not a string slice, as string slices are not mutable, but Strings
are.</li>
</ul>
<p>Finally, when it comes to references, you can have as many immutable references to a value as you like, OR a single
mutable reference. Mutable references are not Copy.</p>
<h3 id="lifetimes"><a class="header" href="#lifetimes">Lifetimes</a></h3>
<p>So far so clear, but it turns out that keeping track of those references is actually quite hard.</p>
<p>Let's create a function that takes a reference to a string and returns two parts to that string:</p>
<pre><pre class="playground"><code class="language-rust">fn split(input: &amp;str, at: usize) -&gt; (&amp;str, &amp;str) {
  let up_to = std::cmp::min(at, input.len()); // Prevent out of bounds
  (&amp;input[..up_to], &amp;input[up_to..])
}

fn main() {
  let input = "yuki".to_string();
  let (left, right) = split(&amp;input, 2);

  println!("Input: {input}"); // yuki
  println!("Left:  {left}");  // yu
  println!("Right: {right}"); // ki
}</code></pre></pre>
<blockquote>
<p>Note, we are taking a sub slice of the input string using ranges. <code>&amp;input[..up_to]</code> means the subslice starts at the
beginning of the string and runs up to, but does not include the "up_to"th element (remember indexing starts at 0, so
if up_to is 2, then the sub slice includes bytes 0 and 1 but not 2). <code>&amp;input[up_to..]</code> starts at the "up_to"th byte
and continues until the end of the "input" slice. Also note that these are ranges of bytes, not characters so there is
a danger here if using multibyte characters. Try not to split strings like this as it's not guaranteed the result is a
valid utf-8 string.</p>
</blockquote>
<p>The function split takes a reference to a string, a point to split at, and the returns everything on the left of the
split and everything on the right. The cool thing here is that the string isn't duplicated, the values <code>left</code> and
<code>right</code> are references that point to the inside of our input string!</p>
<p>How does Rust know that though? Let's confuse it a bit.</p>
<p>Instead of splitting at a particular point, we'll find a sub string inside the input string, then split around that:</p>
<pre><pre class="playground"><code class="language-rust compile_fail">fn split(input: &amp;str, sub_string: &amp;str) -&gt; (&amp;str, &amp;str) {
  if let Some(found_at) = input.find(sub_string) {
    (&amp;input[..found_at], &amp;input[found_at + sub_string.len()..])
  } else {
    (&amp;input[..], &amp;input[input.len()..])
  }
}

fn main() {
  let input = "yuki".to_string();
  let sub_string = "uk";
  let (left, right) = split(&amp;input, sub_string);

  println!("Input: {input}"); // yuki
  println!("Left:  {left}"); // y
  println!("Right: {right}"); // i
}</code></pre></pre>
<p>This example won't compile, we get the error: <code>expected named lifetime parameter</code>, what does that mean?</p>
<p>We also get guidance from the Rust compiler on how to fix our problem, and what it suggests will work, but once you
understand the problem, you'll see there's a better way to solve it.</p>
<p>A lifetime is Rust's way of tracking reference usage. A reference needs to be tied back to its owning variable and this
relationship must be understood at compile time.</p>
<p>Remember the stack? Let's tie what we know about ownership to what we know about the stack.</p>
<ul>
<li>Some data is stored on the stack, some is stored on the heap</li>
<li>Heap data is tied back to variables on the stack that "own" the heap data</li>
<li>As we enter a function, all the space required for the stack data is added to the top of the stack</li>
<li>Further functions go up the stack</li>
<li>As functions come to an end they are removed from the top of the stack</li>
<li>Owned data that is not returned down the stack is freed</li>
</ul>
<p>When it comes to references, we need to make sure that a reference to owned data does not out live the owned data.</p>
<p>For example, lets create a string on the heap called <code>my_string</code>. We'll then return a reference to that string, but not
the string itself. This would mean that when the function comes to an end, the variable <code>my_string</code> goes out of scope,
so the data that it owns on the Heap is freed... what would our reference point at now? Luckily Rust won't let us do
this:</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn bad() -&gt; &amp;str {
  let my_string = "Oh no!".to_string();
  &amp;my_string
}
<span class="boring">}</span></code></pre></pre>
<p>In order to prevent this, Rust tracks the lifetimes of each reference and its owned data. It can often do this
automatically. In the first version of our function Rust can see that only one reference enters the function, no other
references are in play, so Rust knows that the two references that are returned <em>must</em> be tied to the same data as the
incoming reference.</p>
<p>In the second version of our function, we pass two references in, now Rust is now less sure about which data the
returned references should be tied to. The suggestion the Rust compiler gives us is to tie all the references to the
same lifetime. This actually is a valid approach as Rust will use the shortest living bit of data to tie the references
to.</p>
<p>Let's do what it says. Rust lifetimes are annotated with generic labels. If we're being lazy we might use a single
lettered label like <code>'a</code>, though if a lot of lifetimes are at play it's definitely better to use longer, clearer labels.</p>
<p>We'll change the header of our function to include the lifetime <code>'a</code>. First we tell Rust we want to use a lifetime by
putting it inside triangle brackets after the function name. Then we mark each reference with that lifetime.</p>
<pre><pre class="playground"><code class="language-rust">fn split&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;'a str) -&gt; (&amp;'a str, &amp;'a str) {
    // ...
<span class="boring">  if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">    (&amp;input[..found_at], &amp;input[found_at + sub_string.len()..])
</span><span class="boring">  } else {
</span><span class="boring">    (&amp;input[..], &amp;input[input.len()..])
</span><span class="boring">  }
</span>}
<span class="boring">
</span><span class="boring">fn main() {
</span><span class="boring">  let input = "yuki".to_string();
</span><span class="boring">  let sub_string = "uk";
</span><span class="boring">  let (left, right) = split(&amp;input, sub_string);
</span><span class="boring">
</span><span class="boring">  println!("Input: {input}"); // yuki
</span><span class="boring">  println!("Left:  {left}"); // y
</span><span class="boring">  println!("Right: {right}"); // i
</span><span class="boring">}</span></code></pre></pre>
<p>You can run the above and see this example works just fine, however, it's not ideal. We've tied all the references to
the same lifetime. The following shows that we can't compile code that we know should work.</p>
<pre><pre class="playground"><code class="language-rust compile_fail"><span class="boring">fn split&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;'a str) -&gt; (&amp;'a str, &amp;'a str) {
</span><span class="boring">    if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">        (&amp;input[..found_at], &amp;input[found_at + sub_string.len()..])
</span><span class="boring">    } else {
</span><span class="boring">        (&amp;input[..], &amp;input[input.len()..])
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">fn main() {
</span>let input = "yuki".to_string();

let (left, right) = {
    let sub_string = "uk".to_string();
    split(&amp;input, &amp;sub_string)
};

println!("Input: {input}"); // yuki
println!("Left:  {left}"); // y
println!("Right: {right}"); // i
<span class="boring">}</span></code></pre></pre>
<p>This is contrived but here we've created an inner scope for our sub string. When that scope ends, that substring will be
freed. You and I know that the left and right references are tied to the input variable in the outer scope, but we told
Rust that it should tie all the lifetimes together. Since the sub string lasts the least amount of time, that's the
lifetime it used.</p>
<p>To fix this problem we can just remove the lifetime annotation from the sub_string parameter. Now everything works
as we'd expect:</p>
<pre><pre class="playground"><code class="language-rust">fn split&lt;'a&gt;(input: &amp;'a str, sub_string: &amp;str) -&gt; (&amp;'a str, &amp;'a str) {
  // ...
<span class="boring">  if let Some(found_at) = input.find(sub_string) {
</span><span class="boring">    (&amp;input[..found_at], &amp;input[found_at + 1..])
</span><span class="boring">  } else {
</span><span class="boring">    (&amp;input[..], &amp;input[input.len()..])
</span><span class="boring">  }
</span>}

fn main() {
    let input = "yuki".to_string();
    
    let (left, right) = {
        let sub_string = "uk".to_string();
        split(&amp;input, &amp;sub_string)
    };
    
    println!("Input: {input}"); // yuki
    println!("Left:  {left}"); // y
    println!("Right: {right}"); // i
}</code></pre></pre>
<p>References and lifetimes get really tricky. Here's how I like to think about them. Imagine a person flying a kite. The
person is the owner of the data, the kite is the reference, and the string tying them together is the lifetime.</p>
<p>The kite can go up and down the stack freely, but it can't go below where the person is standing, that's the equivalent
of the ground.</p>
<p>Multiple people can fly their kites through the same functions, and each one has its own kite string (lifetime).</p>
<p>Its even possible to entwine the kites. Imagine a function that takes two string references and returns the longest.
This is like a function that accepts two kites but only the largest is returned. Because you don't know who that kite
belongs to, it can't go below the person standing highest on the stack.</p>
<p>Lifetimes can be incredibly powerful, there's no need to fear them. One amazing example is that you can have a string
that contains some data, for example it could be a serialized format like JSON or YAML, or it could be something like
an Advent of Code input string. Lifetimes mean that you bring that String into your program, allocating the memory for
it once, then turn it into a complex data structure. So long as the original String exists, the data structure can need
not allocate any further memory, which is incredibly efficient.</p>
<pre><pre class="playground"><code class="language-rust">struct User&lt;'a&gt; {
  name: &amp;'a str,
  fur_color: &amp;'a str,
}


fn parse_user&lt;'a&gt;(input: &amp;'a str) -&gt; User&lt;'a&gt; {
    // ...
<span class="boring">    // ok, you caught me, this isn't a real parser
</span><span class="boring">    let mut iter = input.lines();
</span><span class="boring">    let name = &amp;iter.next().unwrap()[6..];
</span><span class="boring">    let fur_color = &amp;iter.next().unwrap()[5..];
</span><span class="boring">    User {
</span><span class="boring">      name,
</span><span class="boring">      fur_color,
</span><span class="boring">    }
</span>}

fn main() {
    let user = "name: Yuki
fur: white"
            .to_string();
    let User { name, fur_color } = parse_user(&amp;user);
    println!("User {name} is a {fur_color} cat");
}</code></pre></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<p>Here are some best practices when it comes to working with functions:</p>
<ul>
<li>Create a function whenever a section of code can be described in a few words</li>
<li>The function name should describe what that code is doing</li>
<li>Functions should only do one thing, avoid big branches inside functions</li>
<li>Keep functions short, but not too short. Functions should be set of instructions grouped together, too few, and it may
not be worth the function, too many, and it may need to be broken down into more functions</li>
<li>Do not take ownership unless you expressly need to own the data</li>
<li><em>Try</em> to avoid mutable parameters</li>
<li>Be specific about your lifetimes, if using more than one or two, try naming them</li>
</ul>
<h2 id="homework"><a class="header" href="#homework">Homework</a></h2>
<p>This time I'd like you to create a function that splits our string like before, but instead of returning a left and
right side it splits every part of the string.</p>
<p>There is already a split method on string slices, but I'd like you to only use find, and create a recursive function.</p>
<p>You'll need to use a collection type to store all the chunks created by the split, I suggest using <code>Vec</code> (see the
<a href="https://doc.rust-lang.org/std/vec/struct.Vec.html">Documentation</a>) which is built into Rusts standard library.</p>
<p>A Vec is a variably sized array that you can push new items on to the end of using the <code>.push(...)</code> method.</p>
<p>To check whether your Vec contains the correct information after the program has run, use the <code>dbg!</code> macro (we'll talk
more about how this works another time, all you need to know is it will work for a Vec of string slice references).</p>
<p>The header of your function might look something like this:</p>
<pre><code class="language-rust ignore">fn split(input: &amp;str, split_at: &amp;str, collection: &amp;mut Vec&lt;&amp;str&gt;)</code></pre>
<p>but you need to work out what the lifetimes will be.</p>
<p>If your main function looks like this:</p>
<pre><code class="language-rust ignore">let test_str = "Hello, world!";
let split_at = "l";
let mut collection = Vec::new();

split(test_str, split_at, &amp;mut collection);

dbg!(collection);</code></pre>
<p>Then your output should look something like this:</p>
<pre><code class="language-text">[src\main.rs:17:5] collection = [
    "He",
    "",
    "o, wor",
    "d!",
]
</code></pre>
<p>This isn't an easy task, and will require thinking about the lifetimes carefully.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../language-basics/control-flow.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../language-basics/tests.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../language-basics/control-flow.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../language-basics/tests.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>

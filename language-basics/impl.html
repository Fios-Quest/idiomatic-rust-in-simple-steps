<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Giving types functionality - Idiomatic Rust in Simple Steps</title>


        <!-- Custom HTML head -->

        <meta name="description" content="Learn idiomatic Rust in simple steps even if you have no former knowledge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Idiomatic Rust in Simple Steps</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="giving-types-functionality"><a class="header" href="#giving-types-functionality">Giving types functionality</a></h1>
<p>Next we're going to learn how to add functionality to data by modelling a common emotional pattern followed by my cat,
Yuki.</p>
<h2 id="yuki-states"><a class="header" href="#yuki-states">Yuki States</a></h2>
<p>We'll model 3 emotional states of my Cat, give him behaviours unique to each state, and allow him to transition between
those states.</p>
<style>
  img {
    display: block;
    margin: 0 auto;
  }
</style>
<p><img src="./impl/YukiStateMachine.svg" alt="YukiStateMachine.svg" /></p>
<p>So what is the behaviour we want to model in these states?</p>
<h3 id="mischievous"><a class="header" href="#mischievous">Mischievous</a></h3>
<ul>
<li>We'll initialise Yuki in the Mischievous state because that's how he wakes up.</li>
<li>In this state he'll make a lot of fun little noises</li>
<li>He'll also try to get up to various naughtiness</li>
<li>If we forget to feed him he'll get Hangry</li>
</ul>
<h3 id="hangry-hungry-and-angry"><a class="header" href="#hangry-hungry-and-angry">Hangry (Hungry and Angry)</a></h3>
<ul>
<li>While hangry, he only really makes one noise, a desperate plea to "pay attention and do your job"</li>
<li>He'll get hyper focused on getting your attention and may choose violence</li>
<li>Once he's eaten, he'll get Eepy</li>
</ul>
<h3 id="eepy-sleepy"><a class="header" href="#eepy-sleepy">Eepy (Sleepy)</a></h3>
<ul>
<li>Once he's eaten, he'll get sleepy, he won't make any noises he'll just settle down in one of his beds</li>
<li>Once he's slept, he'll get back to his mischeivous state</li>
</ul>
<h2 id="making-a-cat"><a class="header" href="#making-a-cat">Making a Cat</a></h2>
<p>Let's create a new project with <code>cargo new yuki-state-machine</code> and open it in our IDE of choice.</p>
<p>For this project we're going to need to organise our code a bit. We've talked a little bit about modules before, they're
Rust's way of organising and grouping code. We've created modules to contain tests, that we've then excluded from our
build. You can create them with the <code>mod</code> keyword, then a name, then either:</p>
<ul>
<li>a block of code surrounded by curly brackets</li>
<li>a file called the same thing as the module (e.g. <code>mod my_module</code> and a file called <code>my_module.rs</code>)</li>
<li>a directory called the same thing as the module and a file called <code>mod.rs</code> (e.g. <code>mod my_module</code> and a file called
<code>my_module/mod.rs</code>)</li>
</ul>
<p>We're going to use all of these techniques in this project, though only the latter two today.</p>
<p>To organise our cat code away from the main binary, lets create a cat module inside our main file, so it looks something
like this:</p>
<pre><code class="language-rust ignore">// File: main.rs

mod cat;

fn main() {
    println!("Hello, world!");
}</code></pre>
<p>If you're using VSCode, RustRover or similar, you might be able to use the context menu to create <code>cat.rs</code> by
putting the cursor over <code>cat</code> and activating the context actions (in VSCode that's <code>Ctrl</code>/<code>‚åò</code> + <code>.</code>, in IntelliJ
products like RustRover it's <code>Alt</code>/<code>‚å•</code> + <code>enter</code>). If you aren't able to do that, create a file called <code>cat.rs</code> in your
<code>src</code> folder.</p>
<p>Inside our <code>cat.rs</code> file lets create a structure to hold a cat, we'll make it public by putting the word <code>pub</code> in front
of the struct.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: cat.rs

pub struct Cat {
    name: String,
}
<span class="boring">}</span></code></pre></pre>
<p>We can access the <code>Cat</code> struct back in our <code>main</code> function either by giving a full reference to the <code>Cat</code> struct in its
module, <code>cat::Cat</code> or by using the <code>use</code> keyword. However, you'll find we can't actually <em>create</em> the structure.</p>
<pre><pre class="playground"><code class="language-rust compile_fail no_run"><span class="boring">// This would be in your `cat.rs`, I need to put it here to make the code work in mdbook
</span><span class="boring">mod cat {
</span><span class="boring">  pub struct Cat {
</span><span class="boring">    name: String,
</span><span class="boring">  }
</span><span class="boring">}
</span><span class="boring">
</span>// File: main.rs

mod cat;

use cat::Cat;

fn main() {
    let yuki = Cat { name: "Yuki".to_string() };
}</code></pre></pre>
<pre><code class="language-text">   |
6  |     let yuki = Cat { name: "Yuki".to_string() };
   |                      ^^^^^^^^^^^^^^^^^^^^^^^^ private field
</code></pre>
<p>This is because although <code>Cat</code> is public, its <code>name</code> is not.</p>
<p>We could, of course, simply make <code>name</code> public, but this means anything can access it at any time and, if your <code>cat</code> is
mutable, the name can be changed. We don't want anything renaming Yuki, so, we'll manage the property privately.</p>
<p>To create the object then, we'll need a "constructor", a function that is associated with our <code>Cat</code> type, that returns
an instantiated object. To do this we need to use an <code>impl</code> block.</p>
<h2 id="impl"><a class="header" href="#impl">impl</a></h2>
<p>In Rust, code that is associated with specific types is called "implementation" code, and lives inside an <code>impl</code> block.</p>
<p><code>impl</code> blocks are incredibly flexible, and we'll see more of this in the next chapter, for now though, the simplest use
of the block is:</p>
<pre><code class="language-rust ignore">impl TypeName {
    // code goes here
}</code></pre>
<p>Our constructor is simply a function that lives inside the impl block of <code>Cat</code>, takes the cat's name, and returns an
instantiated <code>Cat</code> with the given name. One nice thing about <code>impl</code> blocks is that they have a special shortcut when
referring to the type that is being implemented called <code>Self</code>. This means that while we <em>could</em> specifically return
the <code>Cat</code> type, we could also use <code>Self</code>. There are a lot of benefits to the latter in more advanced code, so we'll
use that here.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: cat.rs

pub struct Cat {
    name: String,
}

impl Cat {
    pub fn new(name: String) -&gt; Self {
        Self { name }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Above, the <code>new</code> function takes a <code>String</code> and returns a <code>Cat</code>. Here we can instantiate the <code>Cat</code> type with <code>Self</code> too,
and inside the <code>impl</code> block, we have access to the private <code>name</code> field. Finally, because the <code>name</code> variable is called
the same as thing as the <code>name</code> field, writing <code>Self { name: name }</code> is redundant, we can just write <code>Self { name }</code>.</p>
<p>Let's make our <code>Cat</code> implementation slightly more useful by adding a function that will get the name of our cat too. In
order to get the name we'll create a function with a special parameter <code>&amp;self</code>. You might notice a couple of odd things
about this. First, it has no type, and second, the variable name itself gets the <code>&amp;</code> which would normally be on the
type, to show that it is a reference.</p>
<p><code>self</code> is a keyword, that translates in the parameters of a function header to <code>self: Self</code>, ie, a variable called
<code>self</code> with the type of whatever the implementation is for. When you use <code>&amp;self</code> it instead translates to <code>self: &amp;Self</code>.
Similarly, <code>&amp;mut self</code> translates to <code>self: &amp;mut Self</code>.</p>
<p>We don't need to take ownership, or have a mutable reference, so for our function we'll use <code>&amp;self</code> to get an immutable
reference.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: cat.rs

<span class="boring">pub struct Cat {
</span><span class="boring">    name: String,
</span><span class="boring">}
</span><span class="boring">
</span>impl Cat {
    pub fn new(name: String) -&gt; Self { // ...
<span class="boring">        Self { name }
</span><span class="boring">    }
</span>
    pub fn get_name(&amp;self) -&gt; &amp;str {
        &amp;self.name
    }
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Note:</strong> We can safely return a reference to owned data at this point because the function acts like any other, there
is only one reference coming in, <code>&amp;self</code>, and one reference going out <code>&amp;str</code>, they must have the same lifetime. Rust
will not allow you to compile any code where you keep the <code>&amp;str</code> beyond the point where whatever the owner of <code>&amp;self</code>
is goes out of scope.</p>
</blockquote>
<p>Any implementation function where the first parameter is some form of <code>self</code> may be referred to as a "method", and is
available on the instantiated type. Any other function in the implementation is called a "static method".</p>
<p>We can finally create a working program, so returning to <code>main</code>, let's use our new implementation:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">// This would be in your `cat.rs`, I need to put it here to make the code work in mdbook
</span><span class="boring">mod cat {
</span><span class="boring">    pub struct Cat {
</span><span class="boring">        name: String,
</span><span class="boring">    }
</span><span class="boring">    impl Cat {
</span><span class="boring">        pub fn new(name: String) -&gt; Self {
</span><span class="boring">           Self { name }
</span><span class="boring">        }
</span><span class="boring">        pub fn get_name(&amp;self) -&gt; &amp;str {
</span><span class="boring">            &amp;self.name
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>// File: main.rs

// ...
<span class="boring">use cat::Cat;
</span>
fn main() {
    let mut yuki = Cat::new("Yuki".to_string());
    println!("Our cat is called {}", yuki.get_name());
}</code></pre></pre>
<p>Great, lets move on to Yuki's state!</p>
<h2 id="state-machines-and-rust"><a class="header" href="#state-machines-and-rust">State Machines and Rust</a></h2>
<p>We want to represent three of Yuki's many "states", but in particular, we want to move between them in a very specific
way.</p>
<p>A naive approach to this could use an <code>enum</code> to represent the states, and then we could have methods that change the
state.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: cat.rs

pub enum CatState {
    Mischievous,
    Hangry,
    Eepy,
}

pub struct Cat {
    name: String,
    state: CatState,
}

impl Cat {
    pub fn new(name: String) -&gt; Self {
       Self { 
          name,
          state: CatState::Mischievous, // Our default state
       }
    }
  
    pub fn get_name(&amp;self) -&gt; &amp;str { // ...
<span class="boring">        &amp;self.name
</span><span class="boring">    }
</span>
    pub fn forget_to_feed(&amp;mut self) {
        self.state = CatState::Hangry
    }

    pub fn feed(&amp;mut self) {
        self.state = CatState::Eepy
    }

    pub fn sleep(&amp;mut self) {
        self.state = CatState::Mischievous
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Here we use methods which take a mutable reference to self (<code>&amp;mut self</code>) so that we can modify the state.</p>
<p>But let's look again at the diagram:</p>
<p><img src="./impl/YukiStateMachine.svg" alt="YukiStateMachine.svg" /></p>
<p>A Hangry cat doesn't become Mischievous because it slept. What should happen if we try to call <code>sleep</code> on a Hangry cat?
Should it do nothing? Should it throw an error? Does it even make sense for this to be an option?</p>
<p>Furthermore, if we look back at the specification, a Hangry cat may choose violence, but Eepy cats and Mischievous cats
won't.</p>
<p>Instead, we could use a pattern called a State Machine. In a State Machine we transition fully between different states,
and those states have different functionality.</p>
<p>Let's make our states unit structs instead of an enum</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: cat.rs

pub struct Mischievous;
pub struct Hangry;
pub struct Eepy;
<span class="boring">}</span></code></pre></pre>
<p>We can then apply the functionality to each struct in turn:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: cat.rs

<span class="boring">pub struct Mischievous;
</span><span class="boring">pub struct Hangry;
</span><span class="boring">pub struct Eepy;
</span>impl Mischievous {
    pub fn forget_to_feed(self) -&gt; Hangry {
        Hangry
    }
}

impl Hangry {
    pub fn feed(self) -&gt; Eepy {
        Eepy
    }
}

impl Eepy {
    pub fn sleep(self) -&gt; Mischievous {
        Mischievous
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This is <em>much</em> more ergonomic as <code>Hangry</code> simply does not have the method <code>sleep</code>, meaning you get compile time checking
that your cat states are being used correctly.</p>
<p>At this point, we don't have any data about our cat though. There are a few ways we could deal with this. We could
extend our states to be the cat like this:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: cat.rs

pub struct Mischievous {
    name: String,
}

pub struct Hangry {
    name: String,
}

pub struct Eepy {
    name: String,
}

impl Mischievous {
    pub fn new(name: String) -&gt; Self {
        Self { name }
    }
  
    pub fn forget_to_feed(self) -&gt; Hangry {
        Hangry::new(self.name)
    }
}

impl Hangry {
    pub fn new(name: String) -&gt; Self {
        Self { name }
    }
  
    pub fn feed(self) -&gt; Eepy {
        Eepy::new(self.name)
    }
}

impl Eepy {
    pub fn new(name: String) -&gt; Self {
        Self { name }
    }
  
    pub fn sleep(self) -&gt; Mischievous {
        Mischievous::new(self.name)
    }
}
<span class="boring">}</span></code></pre></pre>
<blockquote>
<p><strong>Note:</strong> Each state transition consumes itself, and passes its owned data onto the new state. This saves memory
allocations and makes sure that you don't have an "old" state hanging around.</p>
</blockquote>
<p>This is fine... but it's not very flexible. Instead, we're going to put the <em>whole</em> cat inside the state.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: cat.rs

// ---------- Cat ----------
pub struct Cat {
    name: String,
}

// ---------- States ----------
pub struct Mischievous {
    cat: Cat,
}

pub struct Hangry {
    cat: Cat,
}

pub struct Eepy {
    cat: Cat,
}
<span class="boring">}</span></code></pre></pre>
<p>You might think this is no better, and you'd be right! Whether the cat's information is stored directly in the state or
not we haven't made this more flexible... but, what if the states were generic?</p>
<h2 id="generics"><a class="header" href="#generics">Generics</a></h2>
<p>Generics are a way that we can create a template where some of the details are filled in later. We're going to get
deeper into this in the next chapter, but we can use rudimentary generics to manage our states.</p>
<p>Functions, Structs and Enums can all be made generic by adding triangle brackets after their name, containing a list of
generic parameters. Very often you might see a single letter generic name, particularly you might see something like
<code>&lt;T&gt;</code> as you do with <code>Option&lt;T&gt;</code>, however, you might want to hint about the purposed of the type like the Error <code>E</code> in
<code>Result&lt;T, E&gt;</code>.</p>
<p>You can even use whole words, though this is seen less.</p>
<p>For our purposes, we'll use the letter <code>A</code> to represent "Animal".</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: cat.rs

pub struct Mischievous&lt;A&gt; {
    animal: A,
}

pub struct Hangry&lt;A&gt; {
    animal: A,
}

pub struct Eepy&lt;A&gt; {
    animal: A,
}
<span class="boring">}</span></code></pre></pre>
<p>Later we can fill in the Generic and make it a "concrete" type, in our case this will eventually look like
<code>Mischievous&lt;Cat&gt;</code>.</p>
<p>Next we'll need to update our implementations. Implementations that involve Generic parts, need to list those
after the <code>impl</code> to save confusing implementations on generic types and implementations on concrete variants of generic
types (don't worry if that doesn't quite make sense, just remember to put the generic parameters after the <code>impl</code>).</p>
<p>Once we've specified the generic parameters of the impl block, we don't need to respecify them for each function so long
as the type is being used consistently. So, our <code>new</code> functions can use <code>A</code> for the animal parameter, and that will be
linked to our state's generic <code>A</code>, and our state changes can use <code>A</code> to show that when the state changes, the generic
type will remain the same.</p>
<p>I'm also going to add a quick extra function, <code>describe</code>, to each implementation for use at the end.</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: cat.rs

pub struct Mischievous&lt;A&gt; {
    animal: A,
}

pub struct Hangry&lt;A&gt; {
    animal: A,
}

pub struct Eepy&lt;A&gt; {
    animal: A,
}

impl&lt;A&gt; Mischievous&lt;A&gt; {
    pub fn new(animal: A) -&gt; Self {
        Self { animal }
    }

    pub fn forget_to_feed(self) -&gt; Hangry&lt;A&gt; {
        Hangry::new(self.animal)
    }
    
    pub fn describe(&amp;self) -&gt; String {
        "Trying to break into a wardrobe by pulling on exposed clothing".to_string()
    }
}

impl&lt;A&gt; Hangry&lt;A&gt; {
    pub fn new(animal: A) -&gt; Self {
        Self { animal }
    }

    pub fn feed(self) -&gt; Eepy&lt;A&gt; {
        Eepy::new(self.animal)
    }
    
    pub fn describe(&amp;self) -&gt; String {
        "Being loud doesn't get what they want, they choose violence and attack!".to_string()
    }
}

impl&lt;A&gt; Eepy&lt;A&gt; {
    pub fn new(animal: A) -&gt; Self {
        Self { animal }
    }

    pub fn sleep(self) -&gt; Mischievous&lt;A&gt; {
        Mischievous::new(self.animal)
    }
    
    pub fn describe(&amp;self) -&gt; String {
        "Look at the precious baby sleeping üòç".to_string()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Finally, lets update our cat implementation to return a concrete <code>Mischievous&lt;Cat&gt;</code> type:</p>
<pre><pre class="playground"><code class="language-rust no_run"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// File: cat.rs

<span class="boring">pub struct Cat {
</span><span class="boring">    name: String,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">pub struct Mischievous&lt;A&gt; {
</span><span class="boring">  animal: A,
</span><span class="boring">}
</span><span class="boring">
</span><span class="boring">impl&lt;A&gt; Mischievous&lt;A&gt; {
</span><span class="boring">    pub fn new(animal: A) -&gt; Self {
</span><span class="boring">        Mischievous { animal }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">
</span>impl Cat {
    pub fn new(name: String) -&gt; Mischievous&lt;Cat&gt; {
        Mischievous::new(Self { name })
    }
}
<span class="boring">}</span></code></pre></pre>
<p>We can now play with all of this in our main function:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">mod cat { // Everything here should be in `cat.rs`, I can't do that and have runnable code though ;) 
</span><span class="boring">    pub struct Cat {
</span><span class="boring">        name: String,
</span><span class="boring">    }
</span><span class="boring">   
</span><span class="boring">    impl Cat {
</span><span class="boring">      pub fn new(name: String) -&gt; Mischievous&lt;Cat&gt; {
</span><span class="boring">        Mischievous::new(Self { name })
</span><span class="boring">      }
</span><span class="boring">    }
</span><span class="boring">    
</span><span class="boring">    pub struct Mischievous&lt;A&gt; {
</span><span class="boring">        animal: A,
</span><span class="boring">    }
</span><span class="boring">    
</span><span class="boring">    pub struct Hangry&lt;A&gt; {
</span><span class="boring">        animal: A,
</span><span class="boring">    }
</span><span class="boring">    
</span><span class="boring">    pub struct Eepy&lt;A&gt; {
</span><span class="boring">        animal: A,
</span><span class="boring">    }
</span><span class="boring">    
</span><span class="boring">    impl&lt;A&gt; Mischievous&lt;A&gt; {
</span><span class="boring">        pub fn new(animal: A) -&gt; Self {
</span><span class="boring">            Self { animal }
</span><span class="boring">        }
</span><span class="boring">    
</span><span class="boring">        pub fn forget_to_feed(self) -&gt; Hangry&lt;A&gt; {
</span><span class="boring">            Hangry::new(self.animal)
</span><span class="boring">        }
</span><span class="boring">        
</span><span class="boring">        pub fn describe(&amp;self) -&gt; String {
</span><span class="boring">            "Trying to break into a wardrobe by pulling on exposed clothing".to_string()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    
</span><span class="boring">    impl&lt;A&gt; Hangry&lt;A&gt; {
</span><span class="boring">        pub fn new(animal: A) -&gt; Self {
</span><span class="boring">            Self { animal }
</span><span class="boring">        }
</span><span class="boring">    
</span><span class="boring">        pub fn feed(self) -&gt; Eepy&lt;A&gt; {
</span><span class="boring">            Eepy::new(self.animal)
</span><span class="boring">        }
</span><span class="boring">        
</span><span class="boring">        pub fn describe(&amp;self) -&gt; String {
</span><span class="boring">            "Being loud doesn't get what they want, they choose violence and attack!".to_string()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">    
</span><span class="boring">    impl&lt;A&gt; Eepy&lt;A&gt; {
</span><span class="boring">        pub fn new(animal: A) -&gt; Self {
</span><span class="boring">            Self { animal }
</span><span class="boring">        }
</span><span class="boring">    
</span><span class="boring">        pub fn sleep(self) -&gt; Mischievous&lt;A&gt; {
</span><span class="boring">            Mischievous::new(self.animal)
</span><span class="boring">        }
</span><span class="boring">        
</span><span class="boring">        pub fn describe(&amp;self) -&gt; String {
</span><span class="boring">            "Look at the precious baby sleeping üòç".to_string()
</span><span class="boring">        }
</span><span class="boring">    }
</span><span class="boring">}
</span><span class="boring">use cat::Cat;
</span>// File: main.rs

// ...

fn main() {
  let mischievous_yuki = Cat::new("Yuki".to_string());
  println!("{}", mischievous_yuki.describe());
  println!();
  
  let hangry_yuki = mischievous_yuki.forget_to_feed();
  println!("{}", hangry_yuki.describe());
  println!();
  
  let sleepy_yuki = hangry_yuki.feed();
  println!("{}", sleepy_yuki.describe());
  println!();
  
  let mischievous_yuki = sleepy_yuki.sleep();
  println!("{}", mischievous_yuki.describe());
  println!();
}</code></pre></pre>
<h2 id="tidying-up"><a class="header" href="#tidying-up">Tidying up</a></h2>
<p>Before we finish the chapter, our code has gotten a bit messy, we should clean it up. Now that our states are not
Cat specific, they should be moved out of <code>cat.rs</code>.</p>
<p>I recommend splitting your files like this:</p>
<p><img src="./impl/project-layout.png" alt="project-layout.png" /></p>
<p>You will need to <code>use</code> each state in the appropriate file being used, and you need to make your individual state modules
public in your general state <code>mod.rs</code>.</p>
<p>I'd like you to try to organise this project yourself, but if you get stuck, you can see it on our
<a href="https://github.com/Fios-Quest/yuki-state-machine-impl-example">GitHub</a>.</p>
<h2 id="next-chapter"><a class="header" href="#next-chapter">Next Chapter</a></h2>
<p>This is cool... but we've got a slight problem. We can't get Yuki's name, and really his actions should belong to him,
not be part of the state (I try not to choose violence when I'm hangry for example).</p>
<p>We should move some of this behaviour to the Cat type, but how can we access details on our Cat type when we
don't know that our Generic states will contain Cats until runtime?</p>
<p>In the next chapter we'll discuss Traits which provide a way to resolve this, as well as some other cool things they
can do with Generics!</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../language-basics/clippy-and-fmt.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../language-basics/traits.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../language-basics/clippy-and-fmt.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../language-basics/traits.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../editor.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
